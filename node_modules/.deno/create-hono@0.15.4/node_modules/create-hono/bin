#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/yoctocolors-cjs/index.js
var require_yoctocolors_cjs = __commonJS({
  "node_modules/yoctocolors-cjs/index.js"(exports, module2) {
    var tty2 = require("node:tty");
    var hasColors = tty2?.WriteStream?.prototype?.hasColors?.() ?? false;
    var format2 = (open, close) => {
      if (!hasColors) {
        return (input) => input;
      }
      const openCode = `\x1B[${open}m`;
      const closeCode = `\x1B[${close}m`;
      return (input) => {
        const string = input + "";
        let index = string.indexOf(closeCode);
        if (index === -1) {
          return openCode + string + closeCode;
        }
        let result = openCode;
        let lastIndex = 0;
        while (index !== -1) {
          result += string.slice(lastIndex, index) + openCode;
          lastIndex = index + closeCode.length;
          index = string.indexOf(closeCode, lastIndex);
        }
        result += string.slice(lastIndex) + closeCode;
        return result;
      };
    };
    var colors4 = {};
    colors4.reset = format2(0, 0);
    colors4.bold = format2(1, 22);
    colors4.dim = format2(2, 22);
    colors4.italic = format2(3, 23);
    colors4.underline = format2(4, 24);
    colors4.overline = format2(53, 55);
    colors4.inverse = format2(7, 27);
    colors4.hidden = format2(8, 28);
    colors4.strikethrough = format2(9, 29);
    colors4.black = format2(30, 39);
    colors4.red = format2(31, 39);
    colors4.green = format2(32, 39);
    colors4.yellow = format2(33, 39);
    colors4.blue = format2(34, 39);
    colors4.magenta = format2(35, 39);
    colors4.cyan = format2(36, 39);
    colors4.white = format2(37, 39);
    colors4.gray = format2(90, 39);
    colors4.bgBlack = format2(40, 49);
    colors4.bgRed = format2(41, 49);
    colors4.bgGreen = format2(42, 49);
    colors4.bgYellow = format2(43, 49);
    colors4.bgBlue = format2(44, 49);
    colors4.bgMagenta = format2(45, 49);
    colors4.bgCyan = format2(46, 49);
    colors4.bgWhite = format2(47, 49);
    colors4.bgGray = format2(100, 49);
    colors4.redBright = format2(91, 39);
    colors4.greenBright = format2(92, 39);
    colors4.yellowBright = format2(93, 39);
    colors4.blueBright = format2(94, 39);
    colors4.magentaBright = format2(95, 39);
    colors4.cyanBright = format2(96, 39);
    colors4.whiteBright = format2(97, 39);
    colors4.bgRedBright = format2(101, 49);
    colors4.bgGreenBright = format2(102, 49);
    colors4.bgYellowBright = format2(103, 49);
    colors4.bgBlueBright = format2(104, 49);
    colors4.bgMagentaBright = format2(105, 49);
    colors4.bgCyanBright = format2(106, 49);
    colors4.bgWhiteBright = format2(107, 49);
    module2.exports = colors4;
  }
});

// node_modules/cli-width/index.js
var require_cli_width = __commonJS({
  "node_modules/cli-width/index.js"(exports, module2) {
    "use strict";
    module2.exports = cliWidth2;
    function normalizeOpts(options) {
      const defaultOpts = {
        defaultWidth: 0,
        output: process.stdout,
        tty: require("tty")
      };
      if (!options) {
        return defaultOpts;
      }
      Object.keys(defaultOpts).forEach(function(key) {
        if (!options[key]) {
          options[key] = defaultOpts[key];
        }
      });
      return options;
    }
    function cliWidth2(options) {
      const opts = normalizeOpts(options);
      if (opts.output.getWindowSize) {
        return opts.output.getWindowSize()[0] || opts.defaultWidth;
      }
      if (opts.tty.getWindowSize) {
        return opts.tty.getWindowSize()[1] || opts.defaultWidth;
      }
      if (opts.output.columns) {
        return opts.output.columns;
      }
      if (process.env.CLI_WIDTH) {
        const width = parseInt(process.env.CLI_WIDTH, 10);
        if (!isNaN(width) && width !== 0) {
          return width;
        }
      }
      return opts.defaultWidth;
    }
  }
});

// node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  "node_modules/ansi-regex/index.js"(exports, module2) {
    "use strict";
    module2.exports = ({ onlyFirst = false } = {}) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});

// node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS({
  "node_modules/strip-ansi/index.js"(exports, module2) {
    "use strict";
    var ansiRegex = require_ansi_regex();
    module2.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
  }
});

// node_modules/wrap-ansi/node_modules/is-fullwidth-code-point/index.js
var require_is_fullwidth_code_point = __commonJS({
  "node_modules/wrap-ansi/node_modules/is-fullwidth-code-point/index.js"(exports, module2) {
    "use strict";
    var isFullwidthCodePoint = (codePoint) => {
      if (Number.isNaN(codePoint)) {
        return false;
      }
      if (codePoint >= 4352 && (codePoint <= 4447 || // Hangul Jamo
      codePoint === 9001 || // LEFT-POINTING ANGLE BRACKET
      codePoint === 9002 || // RIGHT-POINTING ANGLE BRACKET
      // CJK Radicals Supplement .. Enclosed CJK Letters and Months
      11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
      12880 <= codePoint && codePoint <= 19903 || // CJK Unified Ideographs .. Yi Radicals
      19968 <= codePoint && codePoint <= 42182 || // Hangul Jamo Extended-A
      43360 <= codePoint && codePoint <= 43388 || // Hangul Syllables
      44032 <= codePoint && codePoint <= 55203 || // CJK Compatibility Ideographs
      63744 <= codePoint && codePoint <= 64255 || // Vertical Forms
      65040 <= codePoint && codePoint <= 65049 || // CJK Compatibility Forms .. Small Form Variants
      65072 <= codePoint && codePoint <= 65131 || // Halfwidth and Fullwidth Forms
      65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || // Kana Supplement
      110592 <= codePoint && codePoint <= 110593 || // Enclosed Ideographic Supplement
      127488 <= codePoint && codePoint <= 127569 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
      131072 <= codePoint && codePoint <= 262141)) {
        return true;
      }
      return false;
    };
    module2.exports = isFullwidthCodePoint;
    module2.exports.default = isFullwidthCodePoint;
  }
});

// node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS({
  "node_modules/emoji-regex/index.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
    };
  }
});

// node_modules/wrap-ansi/node_modules/string-width/index.js
var require_string_width = __commonJS({
  "node_modules/wrap-ansi/node_modules/string-width/index.js"(exports, module2) {
    "use strict";
    var stripAnsi2 = require_strip_ansi();
    var isFullwidthCodePoint = require_is_fullwidth_code_point();
    var emojiRegex = require_emoji_regex();
    var stringWidth = (string) => {
      if (typeof string !== "string" || string.length === 0) {
        return 0;
      }
      string = stripAnsi2(string);
      if (string.length === 0) {
        return 0;
      }
      string = string.replace(emojiRegex(), "  ");
      let width = 0;
      for (let i = 0; i < string.length; i++) {
        const code = string.codePointAt(i);
        if (code <= 31 || code >= 127 && code <= 159) {
          continue;
        }
        if (code >= 768 && code <= 879) {
          continue;
        }
        if (code > 65535) {
          i++;
        }
        width += isFullwidthCodePoint(code) ? 2 : 1;
      }
      return width;
    };
    module2.exports = stringWidth;
    module2.exports.default = stringWidth;
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color-convert/conversions.js"(exports, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color-convert/route.js"(exports, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path6 = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path6.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path6;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color-convert/index.js"(exports, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/wrap-ansi/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/wrap-ansi/node_modules/ansi-styles/index.js"(exports, module2) {
    "use strict";
    var wrapAnsi162 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi2562 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m2 = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity2, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles3 = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles3[name] = wrap(identity2, offset);
        } else if (typeof suite === "object") {
          styles3[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles3;
    };
    function assembleStyles2() {
      const codes = /* @__PURE__ */ new Map();
      const styles3 = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles3.color.gray = styles3.color.blackBright;
      styles3.bgColor.bgGray = styles3.bgColor.bgBlackBright;
      styles3.color.grey = styles3.color.blackBright;
      styles3.bgColor.bgGrey = styles3.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles3)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles3[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles3[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles3, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles3, "codes", {
        value: codes,
        enumerable: false
      });
      styles3.color.close = "\x1B[39m";
      styles3.bgColor.close = "\x1B[49m";
      setLazyProperty(styles3.color, "ansi", () => makeDynamicStyles(wrapAnsi162, "ansi16", ansi2ansi, false));
      setLazyProperty(styles3.color, "ansi256", () => makeDynamicStyles(wrapAnsi2562, "ansi256", ansi2ansi, false));
      setLazyProperty(styles3.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m2, "rgb", rgb2rgb, false));
      setLazyProperty(styles3.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi162, "ansi16", ansi2ansi, true));
      setLazyProperty(styles3.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi2562, "ansi256", ansi2ansi, true));
      setLazyProperty(styles3.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m2, "rgb", rgb2rgb, true));
      return styles3;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles2
    });
  }
});

// node_modules/wrap-ansi/index.js
var require_wrap_ansi = __commonJS({
  "node_modules/wrap-ansi/index.js"(exports, module2) {
    "use strict";
    var stringWidth = require_string_width();
    var stripAnsi2 = require_strip_ansi();
    var ansiStyles2 = require_ansi_styles();
    var ESCAPES = /* @__PURE__ */ new Set([
      "\x1B",
      "\x9B"
    ]);
    var END_CODE = 39;
    var wrapAnsi2 = (code) => `${ESCAPES.values().next().value}[${code}m`;
    var wordLengths = (string) => string.split(" ").map((character) => stringWidth(character));
    var wrapWord = (rows, word, columns) => {
      const characters = [...word];
      let isInsideEscape = false;
      let visible = stringWidth(stripAnsi2(rows[rows.length - 1]));
      for (const [index, character] of characters.entries()) {
        const characterLength = stringWidth(character);
        if (visible + characterLength <= columns) {
          rows[rows.length - 1] += character;
        } else {
          rows.push(character);
          visible = 0;
        }
        if (ESCAPES.has(character)) {
          isInsideEscape = true;
        } else if (isInsideEscape && character === "m") {
          isInsideEscape = false;
          continue;
        }
        if (isInsideEscape) {
          continue;
        }
        visible += characterLength;
        if (visible === columns && index < characters.length - 1) {
          rows.push("");
          visible = 0;
        }
      }
      if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
        rows[rows.length - 2] += rows.pop();
      }
    };
    var stringVisibleTrimSpacesRight = (str) => {
      const words = str.split(" ");
      let last = words.length;
      while (last > 0) {
        if (stringWidth(words[last - 1]) > 0) {
          break;
        }
        last--;
      }
      if (last === words.length) {
        return str;
      }
      return words.slice(0, last).join(" ") + words.slice(last).join("");
    };
    var exec2 = (string, columns, options = {}) => {
      if (options.trim !== false && string.trim() === "") {
        return "";
      }
      let pre = "";
      let ret = "";
      let escapeCode;
      const lengths = wordLengths(string);
      let rows = [""];
      for (const [index, word] of string.split(" ").entries()) {
        if (options.trim !== false) {
          rows[rows.length - 1] = rows[rows.length - 1].trimLeft();
        }
        let rowLength = stringWidth(rows[rows.length - 1]);
        if (index !== 0) {
          if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
            rows.push("");
            rowLength = 0;
          }
          if (rowLength > 0 || options.trim === false) {
            rows[rows.length - 1] += " ";
            rowLength++;
          }
        }
        if (options.hard && lengths[index] > columns) {
          const remainingColumns = columns - rowLength;
          const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
          const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
          if (breaksStartingNextLine < breaksStartingThisLine) {
            rows.push("");
          }
          wrapWord(rows, word, columns);
          continue;
        }
        if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
          if (options.wordWrap === false && rowLength < columns) {
            wrapWord(rows, word, columns);
            continue;
          }
          rows.push("");
        }
        if (rowLength + lengths[index] > columns && options.wordWrap === false) {
          wrapWord(rows, word, columns);
          continue;
        }
        rows[rows.length - 1] += word;
      }
      if (options.trim !== false) {
        rows = rows.map(stringVisibleTrimSpacesRight);
      }
      pre = rows.join("\n");
      for (const [index, character] of [...pre].entries()) {
        ret += character;
        if (ESCAPES.has(character)) {
          const code2 = parseFloat(/\d[^m]*/.exec(pre.slice(index, index + 4)));
          escapeCode = code2 === END_CODE ? null : code2;
        }
        const code = ansiStyles2.codes.get(Number(escapeCode));
        if (escapeCode && code) {
          if (pre[index + 1] === "\n") {
            ret += wrapAnsi2(code);
          } else if (character === "\n") {
            ret += wrapAnsi2(escapeCode);
          }
        }
      }
      return ret;
    };
    module2.exports = (string, columns, options) => {
      return String(string).normalize().replace(/\r\n/g, "\n").split("\n").map((line) => exec2(line, columns, options)).join("\n");
    };
  }
});

// node_modules/mute-stream/lib/index.js
var require_lib = __commonJS({
  "node_modules/mute-stream/lib/index.js"(exports, module2) {
    var Stream = require("stream");
    var MuteStream2 = class extends Stream {
      #isTTY = null;
      constructor(opts = {}) {
        super(opts);
        this.writable = this.readable = true;
        this.muted = false;
        this.on("pipe", this._onpipe);
        this.replace = opts.replace;
        this._prompt = opts.prompt || null;
        this._hadControl = false;
      }
      #destSrc(key, def) {
        if (this._dest) {
          return this._dest[key];
        }
        if (this._src) {
          return this._src[key];
        }
        return def;
      }
      #proxy(method, ...args) {
        if (typeof this._dest?.[method] === "function") {
          this._dest[method](...args);
        }
        if (typeof this._src?.[method] === "function") {
          this._src[method](...args);
        }
      }
      get isTTY() {
        if (this.#isTTY !== null) {
          return this.#isTTY;
        }
        return this.#destSrc("isTTY", false);
      }
      // basically just get replace the getter/setter with a regular value
      set isTTY(val) {
        this.#isTTY = val;
      }
      get rows() {
        return this.#destSrc("rows");
      }
      get columns() {
        return this.#destSrc("columns");
      }
      mute() {
        this.muted = true;
      }
      unmute() {
        this.muted = false;
      }
      _onpipe(src) {
        this._src = src;
      }
      pipe(dest, options) {
        this._dest = dest;
        return super.pipe(dest, options);
      }
      pause() {
        if (this._src) {
          return this._src.pause();
        }
      }
      resume() {
        if (this._src) {
          return this._src.resume();
        }
      }
      write(c) {
        if (this.muted) {
          if (!this.replace) {
            return true;
          }
          if (c.match(/^\u001b/)) {
            if (c.indexOf(this._prompt) === 0) {
              c = c.slice(this._prompt.length);
              c = c.replace(/./g, this.replace);
              c = this._prompt + c;
            }
            this._hadControl = true;
            return this.emit("data", c);
          } else {
            if (this._prompt && this._hadControl && c.indexOf(this._prompt) === 0) {
              this._hadControl = false;
              this.emit("data", this._prompt);
              c = c.slice(this._prompt.length);
            }
            c = c.toString().replace(/./g, this.replace);
          }
        }
        this.emit("data", c);
      }
      end(c) {
        if (this.muted) {
          if (c && this.replace) {
            c = c.toString().replace(/./g, this.replace);
          } else {
            c = null;
          }
        }
        if (c) {
          this.emit("data", c);
        }
        this.emit("end");
      }
      destroy(...args) {
        return this.#proxy("destroy", ...args);
      }
      destroySoon(...args) {
        return this.#proxy("destroySoon", ...args);
      }
      close(...args) {
        return this.#proxy("close", ...args);
      }
    };
    module2.exports = MuteStream2;
  }
});

// node_modules/signal-exit/dist/mjs/signals.js
var signals;
var init_signals = __esm({
  "node_modules/signal-exit/dist/mjs/signals.js"() {
    signals = [];
    signals.push("SIGHUP", "SIGINT", "SIGTERM");
    if (process.platform !== "win32") {
      signals.push(
        "SIGALRM",
        "SIGABRT",
        "SIGVTALRM",
        "SIGXCPU",
        "SIGXFSZ",
        "SIGUSR2",
        "SIGTRAP",
        "SIGSYS",
        "SIGQUIT",
        "SIGIOT"
        // should detect profiler and enable/disable accordingly.
        // see #21
        // 'SIGPROF'
      );
    }
    if (process.platform === "linux") {
      signals.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");
    }
  }
});

// node_modules/signal-exit/dist/mjs/index.js
var processOk, kExitEmitter, global2, ObjectDefineProperty, Emitter, SignalExitBase, signalExitWrap, SignalExitFallback, SignalExit, process3, onExit, load, unload;
var init_mjs = __esm({
  "node_modules/signal-exit/dist/mjs/index.js"() {
    init_signals();
    processOk = (process9) => !!process9 && typeof process9 === "object" && typeof process9.removeListener === "function" && typeof process9.emit === "function" && typeof process9.reallyExit === "function" && typeof process9.listeners === "function" && typeof process9.kill === "function" && typeof process9.pid === "number" && typeof process9.on === "function";
    kExitEmitter = Symbol.for("signal-exit emitter");
    global2 = globalThis;
    ObjectDefineProperty = Object.defineProperty.bind(Object);
    Emitter = class {
      emitted = {
        afterExit: false,
        exit: false
      };
      listeners = {
        afterExit: [],
        exit: []
      };
      count = 0;
      id = Math.random();
      constructor() {
        if (global2[kExitEmitter]) {
          return global2[kExitEmitter];
        }
        ObjectDefineProperty(global2, kExitEmitter, {
          value: this,
          writable: false,
          enumerable: false,
          configurable: false
        });
      }
      on(ev, fn) {
        this.listeners[ev].push(fn);
      }
      removeListener(ev, fn) {
        const list = this.listeners[ev];
        const i = list.indexOf(fn);
        if (i === -1) {
          return;
        }
        if (i === 0 && list.length === 1) {
          list.length = 0;
        } else {
          list.splice(i, 1);
        }
      }
      emit(ev, code, signal) {
        if (this.emitted[ev]) {
          return false;
        }
        this.emitted[ev] = true;
        let ret = false;
        for (const fn of this.listeners[ev]) {
          ret = fn(code, signal) === true || ret;
        }
        if (ev === "exit") {
          ret = this.emit("afterExit", code, signal) || ret;
        }
        return ret;
      }
    };
    SignalExitBase = class {
    };
    signalExitWrap = (handler) => {
      return {
        onExit(cb, opts) {
          return handler.onExit(cb, opts);
        },
        load() {
          return handler.load();
        },
        unload() {
          return handler.unload();
        }
      };
    };
    SignalExitFallback = class extends SignalExitBase {
      onExit() {
        return () => {
        };
      }
      load() {
      }
      unload() {
      }
    };
    SignalExit = class extends SignalExitBase {
      // "SIGHUP" throws an `ENOSYS` error on Windows,
      // so use a supported signal instead
      /* c8 ignore start */
      #hupSig = process3.platform === "win32" ? "SIGINT" : "SIGHUP";
      /* c8 ignore stop */
      #emitter = new Emitter();
      #process;
      #originalProcessEmit;
      #originalProcessReallyExit;
      #sigListeners = {};
      #loaded = false;
      constructor(process9) {
        super();
        this.#process = process9;
        this.#sigListeners = {};
        for (const sig of signals) {
          this.#sigListeners[sig] = () => {
            const listeners = this.#process.listeners(sig);
            let { count } = this.#emitter;
            const p = process9;
            if (typeof p.__signal_exit_emitter__ === "object" && typeof p.__signal_exit_emitter__.count === "number") {
              count += p.__signal_exit_emitter__.count;
            }
            if (listeners.length === count) {
              this.unload();
              const ret = this.#emitter.emit("exit", null, sig);
              const s = sig === "SIGHUP" ? this.#hupSig : sig;
              if (!ret)
                process9.kill(process9.pid, s);
            }
          };
        }
        this.#originalProcessReallyExit = process9.reallyExit;
        this.#originalProcessEmit = process9.emit;
      }
      onExit(cb, opts) {
        if (!processOk(this.#process)) {
          return () => {
          };
        }
        if (this.#loaded === false) {
          this.load();
        }
        const ev = opts?.alwaysLast ? "afterExit" : "exit";
        this.#emitter.on(ev, cb);
        return () => {
          this.#emitter.removeListener(ev, cb);
          if (this.#emitter.listeners["exit"].length === 0 && this.#emitter.listeners["afterExit"].length === 0) {
            this.unload();
          }
        };
      }
      load() {
        if (this.#loaded) {
          return;
        }
        this.#loaded = true;
        this.#emitter.count += 1;
        for (const sig of signals) {
          try {
            const fn = this.#sigListeners[sig];
            if (fn)
              this.#process.on(sig, fn);
          } catch (_) {
          }
        }
        this.#process.emit = (ev, ...a) => {
          return this.#processEmit(ev, ...a);
        };
        this.#process.reallyExit = (code) => {
          return this.#processReallyExit(code);
        };
      }
      unload() {
        if (!this.#loaded) {
          return;
        }
        this.#loaded = false;
        signals.forEach((sig) => {
          const listener = this.#sigListeners[sig];
          if (!listener) {
            throw new Error("Listener not defined for signal: " + sig);
          }
          try {
            this.#process.removeListener(sig, listener);
          } catch (_) {
          }
        });
        this.#process.emit = this.#originalProcessEmit;
        this.#process.reallyExit = this.#originalProcessReallyExit;
        this.#emitter.count -= 1;
      }
      #processReallyExit(code) {
        if (!processOk(this.#process)) {
          return 0;
        }
        this.#process.exitCode = code || 0;
        this.#emitter.emit("exit", this.#process.exitCode, null);
        return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);
      }
      #processEmit(ev, ...args) {
        const og = this.#originalProcessEmit;
        if (ev === "exit" && processOk(this.#process)) {
          if (typeof args[0] === "number") {
            this.#process.exitCode = args[0];
          }
          const ret = og.call(this.#process, ev, ...args);
          this.#emitter.emit("exit", this.#process.exitCode, null);
          return ret;
        } else {
          return og.call(this.#process, ev, ...args);
        }
      }
    };
    process3 = globalThis.process;
    ({
      onExit: (
        /**
         * Called when the process is exiting, whether via signal, explicit
         * exit, or running out of stuff to do.
         *
         * If the global process object is not suitable for instrumentation,
         * then this will be a no-op.
         *
         * Returns a function that may be used to unload signal-exit.
         */
        onExit
      ),
      load: (
        /**
         * Load the listeners.  Likely you never need to call this, unless
         * doing a rather deep integration with signal-exit functionality.
         * Mostly exposed for the benefit of testing.
         *
         * @internal
         */
        load
      ),
      unload: (
        /**
         * Unload the listeners.  Likely you never need to call this, unless
         * doing a rather deep integration with signal-exit functionality.
         * Mostly exposed for the benefit of testing.
         *
         * @internal
         */
        unload
      )
    } = signalExitWrap(processOk(process3) ? new SignalExit(process3) : new SignalExitFallback()));
  }
});

// node_modules/ansi-escapes/index.js
var require_ansi_escapes = __commonJS({
  "node_modules/ansi-escapes/index.js"(exports, module2) {
    "use strict";
    var ansiEscapes3 = module2.exports;
    module2.exports.default = ansiEscapes3;
    var ESC = "\x1B[";
    var OSC = "\x1B]";
    var BEL = "\x07";
    var SEP = ";";
    var isTerminalApp = process.env.TERM_PROGRAM === "Apple_Terminal";
    ansiEscapes3.cursorTo = (x, y) => {
      if (typeof x !== "number") {
        throw new TypeError("The `x` argument is required");
      }
      if (typeof y !== "number") {
        return ESC + (x + 1) + "G";
      }
      return ESC + (y + 1) + ";" + (x + 1) + "H";
    };
    ansiEscapes3.cursorMove = (x, y) => {
      if (typeof x !== "number") {
        throw new TypeError("The `x` argument is required");
      }
      let ret = "";
      if (x < 0) {
        ret += ESC + -x + "D";
      } else if (x > 0) {
        ret += ESC + x + "C";
      }
      if (y < 0) {
        ret += ESC + -y + "A";
      } else if (y > 0) {
        ret += ESC + y + "B";
      }
      return ret;
    };
    ansiEscapes3.cursorUp = (count = 1) => ESC + count + "A";
    ansiEscapes3.cursorDown = (count = 1) => ESC + count + "B";
    ansiEscapes3.cursorForward = (count = 1) => ESC + count + "C";
    ansiEscapes3.cursorBackward = (count = 1) => ESC + count + "D";
    ansiEscapes3.cursorLeft = ESC + "G";
    ansiEscapes3.cursorSavePosition = isTerminalApp ? "\x1B7" : ESC + "s";
    ansiEscapes3.cursorRestorePosition = isTerminalApp ? "\x1B8" : ESC + "u";
    ansiEscapes3.cursorGetPosition = ESC + "6n";
    ansiEscapes3.cursorNextLine = ESC + "E";
    ansiEscapes3.cursorPrevLine = ESC + "F";
    ansiEscapes3.cursorHide = ESC + "?25l";
    ansiEscapes3.cursorShow = ESC + "?25h";
    ansiEscapes3.eraseLines = (count) => {
      let clear = "";
      for (let i = 0; i < count; i++) {
        clear += ansiEscapes3.eraseLine + (i < count - 1 ? ansiEscapes3.cursorUp() : "");
      }
      if (count) {
        clear += ansiEscapes3.cursorLeft;
      }
      return clear;
    };
    ansiEscapes3.eraseEndLine = ESC + "K";
    ansiEscapes3.eraseStartLine = ESC + "1K";
    ansiEscapes3.eraseLine = ESC + "2K";
    ansiEscapes3.eraseDown = ESC + "J";
    ansiEscapes3.eraseUp = ESC + "1J";
    ansiEscapes3.eraseScreen = ESC + "2J";
    ansiEscapes3.scrollUp = ESC + "S";
    ansiEscapes3.scrollDown = ESC + "T";
    ansiEscapes3.clearScreen = "\x1Bc";
    ansiEscapes3.clearTerminal = process.platform === "win32" ? `${ansiEscapes3.eraseScreen}${ESC}0f` : (
      // 1. Erases the screen (Only done in case `2` is not supported)
      // 2. Erases the whole screen including scrollback buffer
      // 3. Moves cursor to the top-left position
      // More info: https://www.real-world-systems.com/docs/ANSIcode.html
      `${ansiEscapes3.eraseScreen}${ESC}3J${ESC}H`
    );
    ansiEscapes3.beep = BEL;
    ansiEscapes3.link = (text, url) => {
      return [
        OSC,
        "8",
        SEP,
        SEP,
        url,
        BEL,
        text,
        OSC,
        "8",
        SEP,
        SEP,
        BEL
      ].join("");
    };
    ansiEscapes3.image = (buffer, options = {}) => {
      let ret = `${OSC}1337;File=inline=1`;
      if (options.width) {
        ret += `;width=${options.width}`;
      }
      if (options.height) {
        ret += `;height=${options.height}`;
      }
      if (options.preserveAspectRatio === false) {
        ret += ";preserveAspectRatio=0";
      }
      return ret + ":" + buffer.toString("base64") + BEL;
    };
    ansiEscapes3.iTerm = {
      setCwd: (cwd2 = process.cwd()) => `${OSC}50;CurrentDir=${cwd2}${BEL}`,
      annotation: (message, options = {}) => {
        let ret = `${OSC}1337;`;
        const hasX = typeof options.x !== "undefined";
        const hasY = typeof options.y !== "undefined";
        if ((hasX || hasY) && !(hasX && hasY && typeof options.length !== "undefined")) {
          throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
        }
        message = message.replace(/\|/g, "");
        ret += options.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=";
        if (options.length > 0) {
          ret += (hasX ? [message, options.length, options.x, options.y] : [options.length, message]).join("|");
        } else {
          ret += message;
        }
        return ret + BEL;
      }
    };
  }
});

// node_modules/commander/lib/error.js
var require_error = __commonJS({
  "node_modules/commander/lib/error.js"(exports) {
    var CommanderError2 = class extends Error {
      /**
       * Constructs the CommanderError class
       * @param {number} exitCode suggested exit code which could be used with process.exit
       * @param {string} code an id string representing the error
       * @param {string} message human-readable description of the error
       */
      constructor(exitCode, code, message) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
        this.code = code;
        this.exitCode = exitCode;
        this.nestedError = void 0;
      }
    };
    var InvalidArgumentError2 = class extends CommanderError2 {
      /**
       * Constructs the InvalidArgumentError class
       * @param {string} [message] explanation of why argument is invalid
       */
      constructor(message) {
        super(1, "commander.invalidArgument", message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
      }
    };
    exports.CommanderError = CommanderError2;
    exports.InvalidArgumentError = InvalidArgumentError2;
  }
});

// node_modules/commander/lib/argument.js
var require_argument = __commonJS({
  "node_modules/commander/lib/argument.js"(exports) {
    var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var Argument2 = class {
      /**
       * Initialize a new command argument with the given name and description.
       * The default is that the argument is required, and you can explicitly
       * indicate this with <> around the name. Put [] around the name for an optional argument.
       *
       * @param {string} name
       * @param {string} [description]
       */
      constructor(name, description) {
        this.description = description || "";
        this.variadic = false;
        this.parseArg = void 0;
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.argChoices = void 0;
        switch (name[0]) {
          case "<":
            this.required = true;
            this._name = name.slice(1, -1);
            break;
          case "[":
            this.required = false;
            this._name = name.slice(1, -1);
            break;
          default:
            this.required = true;
            this._name = name;
            break;
        }
        if (this._name.length > 3 && this._name.slice(-3) === "...") {
          this.variadic = true;
          this._name = this._name.slice(0, -3);
        }
      }
      /**
       * Return argument name.
       *
       * @return {string}
       */
      name() {
        return this._name;
      }
      /**
       * @package
       */
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      /**
       * Set the default value, and optionally supply the description to be displayed in the help.
       *
       * @param {*} value
       * @param {string} [description]
       * @return {Argument}
       */
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      /**
       * Set the custom handler for processing CLI command arguments into argument values.
       *
       * @param {Function} [fn]
       * @return {Argument}
       */
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      /**
       * Only allow argument value to be one of choices.
       *
       * @param {string[]} values
       * @return {Argument}
       */
      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError2(
              `Allowed choices are ${this.argChoices.join(", ")}.`
            );
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      /**
       * Make argument required.
       *
       * @returns {Argument}
       */
      argRequired() {
        this.required = true;
        return this;
      }
      /**
       * Make argument optional.
       *
       * @returns {Argument}
       */
      argOptional() {
        this.required = false;
        return this;
      }
    };
    function humanReadableArgName(arg) {
      const nameOutput = arg.name() + (arg.variadic === true ? "..." : "");
      return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
    }
    exports.Argument = Argument2;
    exports.humanReadableArgName = humanReadableArgName;
  }
});

// node_modules/commander/lib/help.js
var require_help = __commonJS({
  "node_modules/commander/lib/help.js"(exports) {
    var { humanReadableArgName } = require_argument();
    var Help2 = class {
      constructor() {
        this.helpWidth = void 0;
        this.sortSubcommands = false;
        this.sortOptions = false;
        this.showGlobalOptions = false;
      }
      /**
       * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
       *
       * @param {Command} cmd
       * @returns {Command[]}
       */
      visibleCommands(cmd) {
        const visibleCommands = cmd.commands.filter((cmd2) => !cmd2._hidden);
        const helpCommand = cmd._getHelpCommand();
        if (helpCommand && !helpCommand._hidden) {
          visibleCommands.push(helpCommand);
        }
        if (this.sortSubcommands) {
          visibleCommands.sort((a, b) => {
            return a.name().localeCompare(b.name());
          });
        }
        return visibleCommands;
      }
      /**
       * Compare options for sort.
       *
       * @param {Option} a
       * @param {Option} b
       * @returns {number}
       */
      compareOptions(a, b) {
        const getSortKey = (option) => {
          return option.short ? option.short.replace(/^-/, "") : option.long.replace(/^--/, "");
        };
        return getSortKey(a).localeCompare(getSortKey(b));
      }
      /**
       * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
       *
       * @param {Command} cmd
       * @returns {Option[]}
       */
      visibleOptions(cmd) {
        const visibleOptions = cmd.options.filter((option) => !option.hidden);
        const helpOption = cmd._getHelpOption();
        if (helpOption && !helpOption.hidden) {
          const removeShort = helpOption.short && cmd._findOption(helpOption.short);
          const removeLong = helpOption.long && cmd._findOption(helpOption.long);
          if (!removeShort && !removeLong) {
            visibleOptions.push(helpOption);
          } else if (helpOption.long && !removeLong) {
            visibleOptions.push(
              cmd.createOption(helpOption.long, helpOption.description)
            );
          } else if (helpOption.short && !removeShort) {
            visibleOptions.push(
              cmd.createOption(helpOption.short, helpOption.description)
            );
          }
        }
        if (this.sortOptions) {
          visibleOptions.sort(this.compareOptions);
        }
        return visibleOptions;
      }
      /**
       * Get an array of the visible global options. (Not including help.)
       *
       * @param {Command} cmd
       * @returns {Option[]}
       */
      visibleGlobalOptions(cmd) {
        if (!this.showGlobalOptions)
          return [];
        const globalOptions = [];
        for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
          const visibleOptions = ancestorCmd.options.filter(
            (option) => !option.hidden
          );
          globalOptions.push(...visibleOptions);
        }
        if (this.sortOptions) {
          globalOptions.sort(this.compareOptions);
        }
        return globalOptions;
      }
      /**
       * Get an array of the arguments if any have a description.
       *
       * @param {Command} cmd
       * @returns {Argument[]}
       */
      visibleArguments(cmd) {
        if (cmd._argsDescription) {
          cmd.registeredArguments.forEach((argument) => {
            argument.description = argument.description || cmd._argsDescription[argument.name()] || "";
          });
        }
        if (cmd.registeredArguments.find((argument) => argument.description)) {
          return cmd.registeredArguments;
        }
        return [];
      }
      /**
       * Get the command term to show in the list of subcommands.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      subcommandTerm(cmd) {
        const args = cmd.registeredArguments.map((arg) => humanReadableArgName(arg)).join(" ");
        return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + // simplistic check for non-help option
        (args ? " " + args : "");
      }
      /**
       * Get the option term to show in the list of options.
       *
       * @param {Option} option
       * @returns {string}
       */
      optionTerm(option) {
        return option.flags;
      }
      /**
       * Get the argument term to show in the list of arguments.
       *
       * @param {Argument} argument
       * @returns {string}
       */
      argumentTerm(argument) {
        return argument.name();
      }
      /**
       * Get the longest command term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestSubcommandTermLength(cmd, helper) {
        return helper.visibleCommands(cmd).reduce((max, command) => {
          return Math.max(max, helper.subcommandTerm(command).length);
        }, 0);
      }
      /**
       * Get the longest option term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestOptionTermLength(cmd, helper) {
        return helper.visibleOptions(cmd).reduce((max, option) => {
          return Math.max(max, helper.optionTerm(option).length);
        }, 0);
      }
      /**
       * Get the longest global option term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestGlobalOptionTermLength(cmd, helper) {
        return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
          return Math.max(max, helper.optionTerm(option).length);
        }, 0);
      }
      /**
       * Get the longest argument term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestArgumentTermLength(cmd, helper) {
        return helper.visibleArguments(cmd).reduce((max, argument) => {
          return Math.max(max, helper.argumentTerm(argument).length);
        }, 0);
      }
      /**
       * Get the command usage to be displayed at the top of the built-in help.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      commandUsage(cmd) {
        let cmdName = cmd._name;
        if (cmd._aliases[0]) {
          cmdName = cmdName + "|" + cmd._aliases[0];
        }
        let ancestorCmdNames = "";
        for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
          ancestorCmdNames = ancestorCmd.name() + " " + ancestorCmdNames;
        }
        return ancestorCmdNames + cmdName + " " + cmd.usage();
      }
      /**
       * Get the description for the command.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      commandDescription(cmd) {
        return cmd.description();
      }
      /**
       * Get the subcommand summary to show in the list of subcommands.
       * (Fallback to description for backwards compatibility.)
       *
       * @param {Command} cmd
       * @returns {string}
       */
      subcommandDescription(cmd) {
        return cmd.summary() || cmd.description();
      }
      /**
       * Get the option description to show in the list of options.
       *
       * @param {Option} option
       * @return {string}
       */
      optionDescription(option) {
        const extraInfo = [];
        if (option.argChoices) {
          extraInfo.push(
            // use stringify to match the display of the default value
            `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
          );
        }
        if (option.defaultValue !== void 0) {
          const showDefault = option.required || option.optional || option.isBoolean() && typeof option.defaultValue === "boolean";
          if (showDefault) {
            extraInfo.push(
              `default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`
            );
          }
        }
        if (option.presetArg !== void 0 && option.optional) {
          extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
        }
        if (option.envVar !== void 0) {
          extraInfo.push(`env: ${option.envVar}`);
        }
        if (extraInfo.length > 0) {
          return `${option.description} (${extraInfo.join(", ")})`;
        }
        return option.description;
      }
      /**
       * Get the argument description to show in the list of arguments.
       *
       * @param {Argument} argument
       * @return {string}
       */
      argumentDescription(argument) {
        const extraInfo = [];
        if (argument.argChoices) {
          extraInfo.push(
            // use stringify to match the display of the default value
            `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
          );
        }
        if (argument.defaultValue !== void 0) {
          extraInfo.push(
            `default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`
          );
        }
        if (extraInfo.length > 0) {
          const extraDescripton = `(${extraInfo.join(", ")})`;
          if (argument.description) {
            return `${argument.description} ${extraDescripton}`;
          }
          return extraDescripton;
        }
        return argument.description;
      }
      /**
       * Generate the built-in help text.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {string}
       */
      formatHelp(cmd, helper) {
        const termWidth = helper.padWidth(cmd, helper);
        const helpWidth = helper.helpWidth || 80;
        const itemIndentWidth = 2;
        const itemSeparatorWidth = 2;
        function formatItem(term, description) {
          if (description) {
            const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
            return helper.wrap(
              fullText,
              helpWidth - itemIndentWidth,
              termWidth + itemSeparatorWidth
            );
          }
          return term;
        }
        function formatList(textArray) {
          return textArray.join("\n").replace(/^/gm, " ".repeat(itemIndentWidth));
        }
        let output = [`Usage: ${helper.commandUsage(cmd)}`, ""];
        const commandDescription = helper.commandDescription(cmd);
        if (commandDescription.length > 0) {
          output = output.concat([
            helper.wrap(commandDescription, helpWidth, 0),
            ""
          ]);
        }
        const argumentList = helper.visibleArguments(cmd).map((argument) => {
          return formatItem(
            helper.argumentTerm(argument),
            helper.argumentDescription(argument)
          );
        });
        if (argumentList.length > 0) {
          output = output.concat(["Arguments:", formatList(argumentList), ""]);
        }
        const optionList = helper.visibleOptions(cmd).map((option) => {
          return formatItem(
            helper.optionTerm(option),
            helper.optionDescription(option)
          );
        });
        if (optionList.length > 0) {
          output = output.concat(["Options:", formatList(optionList), ""]);
        }
        if (this.showGlobalOptions) {
          const globalOptionList = helper.visibleGlobalOptions(cmd).map((option) => {
            return formatItem(
              helper.optionTerm(option),
              helper.optionDescription(option)
            );
          });
          if (globalOptionList.length > 0) {
            output = output.concat([
              "Global Options:",
              formatList(globalOptionList),
              ""
            ]);
          }
        }
        const commandList = helper.visibleCommands(cmd).map((cmd2) => {
          return formatItem(
            helper.subcommandTerm(cmd2),
            helper.subcommandDescription(cmd2)
          );
        });
        if (commandList.length > 0) {
          output = output.concat(["Commands:", formatList(commandList), ""]);
        }
        return output.join("\n");
      }
      /**
       * Calculate the pad width from the maximum term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      padWidth(cmd, helper) {
        return Math.max(
          helper.longestOptionTermLength(cmd, helper),
          helper.longestGlobalOptionTermLength(cmd, helper),
          helper.longestSubcommandTermLength(cmd, helper),
          helper.longestArgumentTermLength(cmd, helper)
        );
      }
      /**
       * Wrap the given string to width characters per line, with lines after the first indented.
       * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
       *
       * @param {string} str
       * @param {number} width
       * @param {number} indent
       * @param {number} [minColumnWidth=40]
       * @return {string}
       *
       */
      wrap(str, width, indent, minColumnWidth = 40) {
        const indents = " \\f\\t\\v\xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF";
        const manualIndent = new RegExp(`[\\n][${indents}]+`);
        if (str.match(manualIndent))
          return str;
        const columnWidth = width - indent;
        if (columnWidth < minColumnWidth)
          return str;
        const leadingStr = str.slice(0, indent);
        const columnText = str.slice(indent).replace("\r\n", "\n");
        const indentString = " ".repeat(indent);
        const zeroWidthSpace = "\u200B";
        const breaks = `\\s${zeroWidthSpace}`;
        const regex = new RegExp(
          `
|.{1,${columnWidth - 1}}([${breaks}]|$)|[^${breaks}]+?([${breaks}]|$)`,
          "g"
        );
        const lines2 = columnText.match(regex) || [];
        return leadingStr + lines2.map((line, i) => {
          if (line === "\n")
            return "";
          return (i > 0 ? indentString : "") + line.trimEnd();
        }).join("\n");
      }
    };
    exports.Help = Help2;
  }
});

// node_modules/commander/lib/option.js
var require_option = __commonJS({
  "node_modules/commander/lib/option.js"(exports) {
    var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var Option2 = class {
      /**
       * Initialize a new `Option` with the given `flags` and `description`.
       *
       * @param {string} flags
       * @param {string} [description]
       */
      constructor(flags, description) {
        this.flags = flags;
        this.description = description || "";
        this.required = flags.includes("<");
        this.optional = flags.includes("[");
        this.variadic = /\w\.\.\.[>\]]$/.test(flags);
        this.mandatory = false;
        const optionFlags = splitOptionFlags(flags);
        this.short = optionFlags.shortFlag;
        this.long = optionFlags.longFlag;
        this.negate = false;
        if (this.long) {
          this.negate = this.long.startsWith("--no-");
        }
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.presetArg = void 0;
        this.envVar = void 0;
        this.parseArg = void 0;
        this.hidden = false;
        this.argChoices = void 0;
        this.conflictsWith = [];
        this.implied = void 0;
      }
      /**
       * Set the default value, and optionally supply the description to be displayed in the help.
       *
       * @param {*} value
       * @param {string} [description]
       * @return {Option}
       */
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      /**
       * Preset to use when option used without option-argument, especially optional but also boolean and negated.
       * The custom processing (parseArg) is called.
       *
       * @example
       * new Option('--color').default('GREYSCALE').preset('RGB');
       * new Option('--donate [amount]').preset('20').argParser(parseFloat);
       *
       * @param {*} arg
       * @return {Option}
       */
      preset(arg) {
        this.presetArg = arg;
        return this;
      }
      /**
       * Add option name(s) that conflict with this option.
       * An error will be displayed if conflicting options are found during parsing.
       *
       * @example
       * new Option('--rgb').conflicts('cmyk');
       * new Option('--js').conflicts(['ts', 'jsx']);
       *
       * @param {(string | string[])} names
       * @return {Option}
       */
      conflicts(names) {
        this.conflictsWith = this.conflictsWith.concat(names);
        return this;
      }
      /**
       * Specify implied option values for when this option is set and the implied options are not.
       *
       * The custom processing (parseArg) is not called on the implied values.
       *
       * @example
       * program
       *   .addOption(new Option('--log', 'write logging information to file'))
       *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
       *
       * @param {object} impliedOptionValues
       * @return {Option}
       */
      implies(impliedOptionValues) {
        let newImplied = impliedOptionValues;
        if (typeof impliedOptionValues === "string") {
          newImplied = { [impliedOptionValues]: true };
        }
        this.implied = Object.assign(this.implied || {}, newImplied);
        return this;
      }
      /**
       * Set environment variable to check for option value.
       *
       * An environment variable is only used if when processed the current option value is
       * undefined, or the source of the current value is 'default' or 'config' or 'env'.
       *
       * @param {string} name
       * @return {Option}
       */
      env(name) {
        this.envVar = name;
        return this;
      }
      /**
       * Set the custom handler for processing CLI option arguments into option values.
       *
       * @param {Function} [fn]
       * @return {Option}
       */
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      /**
       * Whether the option is mandatory and must have a value after parsing.
       *
       * @param {boolean} [mandatory=true]
       * @return {Option}
       */
      makeOptionMandatory(mandatory = true) {
        this.mandatory = !!mandatory;
        return this;
      }
      /**
       * Hide option in help.
       *
       * @param {boolean} [hide=true]
       * @return {Option}
       */
      hideHelp(hide = true) {
        this.hidden = !!hide;
        return this;
      }
      /**
       * @package
       */
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      /**
       * Only allow option value to be one of choices.
       *
       * @param {string[]} values
       * @return {Option}
       */
      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError2(
              `Allowed choices are ${this.argChoices.join(", ")}.`
            );
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      /**
       * Return option name.
       *
       * @return {string}
       */
      name() {
        if (this.long) {
          return this.long.replace(/^--/, "");
        }
        return this.short.replace(/^-/, "");
      }
      /**
       * Return option name, in a camelcase format that can be used
       * as a object attribute key.
       *
       * @return {string}
       */
      attributeName() {
        return camelcase(this.name().replace(/^no-/, ""));
      }
      /**
       * Check if `arg` matches the short or long flag.
       *
       * @param {string} arg
       * @return {boolean}
       * @package
       */
      is(arg) {
        return this.short === arg || this.long === arg;
      }
      /**
       * Return whether a boolean option.
       *
       * Options are one of boolean, negated, required argument, or optional argument.
       *
       * @return {boolean}
       * @package
       */
      isBoolean() {
        return !this.required && !this.optional && !this.negate;
      }
    };
    var DualOptions = class {
      /**
       * @param {Option[]} options
       */
      constructor(options) {
        this.positiveOptions = /* @__PURE__ */ new Map();
        this.negativeOptions = /* @__PURE__ */ new Map();
        this.dualOptions = /* @__PURE__ */ new Set();
        options.forEach((option) => {
          if (option.negate) {
            this.negativeOptions.set(option.attributeName(), option);
          } else {
            this.positiveOptions.set(option.attributeName(), option);
          }
        });
        this.negativeOptions.forEach((value, key) => {
          if (this.positiveOptions.has(key)) {
            this.dualOptions.add(key);
          }
        });
      }
      /**
       * Did the value come from the option, and not from possible matching dual option?
       *
       * @param {*} value
       * @param {Option} option
       * @returns {boolean}
       */
      valueFromOption(value, option) {
        const optionKey = option.attributeName();
        if (!this.dualOptions.has(optionKey))
          return true;
        const preset = this.negativeOptions.get(optionKey).presetArg;
        const negativeValue = preset !== void 0 ? preset : false;
        return option.negate === (negativeValue === value);
      }
    };
    function camelcase(str) {
      return str.split("-").reduce((str2, word) => {
        return str2 + word[0].toUpperCase() + word.slice(1);
      });
    }
    function splitOptionFlags(flags) {
      let shortFlag;
      let longFlag;
      const flagParts = flags.split(/[ |,]+/);
      if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1]))
        shortFlag = flagParts.shift();
      longFlag = flagParts.shift();
      if (!shortFlag && /^-[^-]$/.test(longFlag)) {
        shortFlag = longFlag;
        longFlag = void 0;
      }
      return { shortFlag, longFlag };
    }
    exports.Option = Option2;
    exports.DualOptions = DualOptions;
  }
});

// node_modules/commander/lib/suggestSimilar.js
var require_suggestSimilar = __commonJS({
  "node_modules/commander/lib/suggestSimilar.js"(exports) {
    var maxDistance = 3;
    function editDistance(a, b) {
      if (Math.abs(a.length - b.length) > maxDistance)
        return Math.max(a.length, b.length);
      const d = [];
      for (let i = 0; i <= a.length; i++) {
        d[i] = [i];
      }
      for (let j = 0; j <= b.length; j++) {
        d[0][j] = j;
      }
      for (let j = 1; j <= b.length; j++) {
        for (let i = 1; i <= a.length; i++) {
          let cost = 1;
          if (a[i - 1] === b[j - 1]) {
            cost = 0;
          } else {
            cost = 1;
          }
          d[i][j] = Math.min(
            d[i - 1][j] + 1,
            // deletion
            d[i][j - 1] + 1,
            // insertion
            d[i - 1][j - 1] + cost
            // substitution
          );
          if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
            d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
          }
        }
      }
      return d[a.length][b.length];
    }
    function suggestSimilar(word, candidates) {
      if (!candidates || candidates.length === 0)
        return "";
      candidates = Array.from(new Set(candidates));
      const searchingOptions = word.startsWith("--");
      if (searchingOptions) {
        word = word.slice(2);
        candidates = candidates.map((candidate) => candidate.slice(2));
      }
      let similar = [];
      let bestDistance = maxDistance;
      const minSimilarity = 0.4;
      candidates.forEach((candidate) => {
        if (candidate.length <= 1)
          return;
        const distance = editDistance(word, candidate);
        const length = Math.max(word.length, candidate.length);
        const similarity = (length - distance) / length;
        if (similarity > minSimilarity) {
          if (distance < bestDistance) {
            bestDistance = distance;
            similar = [candidate];
          } else if (distance === bestDistance) {
            similar.push(candidate);
          }
        }
      });
      similar.sort((a, b) => a.localeCompare(b));
      if (searchingOptions) {
        similar = similar.map((candidate) => `--${candidate}`);
      }
      if (similar.length > 1) {
        return `
(Did you mean one of ${similar.join(", ")}?)`;
      }
      if (similar.length === 1) {
        return `
(Did you mean ${similar[0]}?)`;
      }
      return "";
    }
    exports.suggestSimilar = suggestSimilar;
  }
});

// node_modules/commander/lib/command.js
var require_command = __commonJS({
  "node_modules/commander/lib/command.js"(exports) {
    var EventEmitter2 = require("node:events").EventEmitter;
    var childProcess2 = require("node:child_process");
    var path6 = require("node:path");
    var fs2 = require("node:fs");
    var process9 = require("node:process");
    var { Argument: Argument2, humanReadableArgName } = require_argument();
    var { CommanderError: CommanderError2 } = require_error();
    var { Help: Help2 } = require_help();
    var { Option: Option2, DualOptions } = require_option();
    var { suggestSimilar } = require_suggestSimilar();
    var Command2 = class extends EventEmitter2 {
      /**
       * Initialize a new `Command`.
       *
       * @param {string} [name]
       */
      constructor(name) {
        super();
        this.commands = [];
        this.options = [];
        this.parent = null;
        this._allowUnknownOption = false;
        this._allowExcessArguments = true;
        this.registeredArguments = [];
        this._args = this.registeredArguments;
        this.args = [];
        this.rawArgs = [];
        this.processedArgs = [];
        this._scriptPath = null;
        this._name = name || "";
        this._optionValues = {};
        this._optionValueSources = {};
        this._storeOptionsAsProperties = false;
        this._actionHandler = null;
        this._executableHandler = false;
        this._executableFile = null;
        this._executableDir = null;
        this._defaultCommandName = null;
        this._exitCallback = null;
        this._aliases = [];
        this._combineFlagAndOptionalValue = true;
        this._description = "";
        this._summary = "";
        this._argsDescription = void 0;
        this._enablePositionalOptions = false;
        this._passThroughOptions = false;
        this._lifeCycleHooks = {};
        this._showHelpAfterError = false;
        this._showSuggestionAfterError = true;
        this._outputConfiguration = {
          writeOut: (str) => process9.stdout.write(str),
          writeErr: (str) => process9.stderr.write(str),
          getOutHelpWidth: () => process9.stdout.isTTY ? process9.stdout.columns : void 0,
          getErrHelpWidth: () => process9.stderr.isTTY ? process9.stderr.columns : void 0,
          outputError: (str, write) => write(str)
        };
        this._hidden = false;
        this._helpOption = void 0;
        this._addImplicitHelpCommand = void 0;
        this._helpCommand = void 0;
        this._helpConfiguration = {};
      }
      /**
       * Copy settings that are useful to have in common across root command and subcommands.
       *
       * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
       *
       * @param {Command} sourceCommand
       * @return {Command} `this` command for chaining
       */
      copyInheritedSettings(sourceCommand) {
        this._outputConfiguration = sourceCommand._outputConfiguration;
        this._helpOption = sourceCommand._helpOption;
        this._helpCommand = sourceCommand._helpCommand;
        this._helpConfiguration = sourceCommand._helpConfiguration;
        this._exitCallback = sourceCommand._exitCallback;
        this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
        this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
        this._allowExcessArguments = sourceCommand._allowExcessArguments;
        this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
        this._showHelpAfterError = sourceCommand._showHelpAfterError;
        this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
        return this;
      }
      /**
       * @returns {Command[]}
       * @private
       */
      _getCommandAndAncestors() {
        const result = [];
        for (let command = this; command; command = command.parent) {
          result.push(command);
        }
        return result;
      }
      /**
       * Define a command.
       *
       * There are two styles of command: pay attention to where to put the description.
       *
       * @example
       * // Command implemented using action handler (description is supplied separately to `.command`)
       * program
       *   .command('clone <source> [destination]')
       *   .description('clone a repository into a newly created directory')
       *   .action((source, destination) => {
       *     console.log('clone command called');
       *   });
       *
       * // Command implemented using separate executable file (description is second parameter to `.command`)
       * program
       *   .command('start <service>', 'start named service')
       *   .command('stop [service]', 'stop named service, or all if no name supplied');
       *
       * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
       * @param {(object | string)} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
       * @param {object} [execOpts] - configuration options (for executable)
       * @return {Command} returns new command for action handler, or `this` for executable command
       */
      command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
        let desc = actionOptsOrExecDesc;
        let opts = execOpts;
        if (typeof desc === "object" && desc !== null) {
          opts = desc;
          desc = null;
        }
        opts = opts || {};
        const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
        const cmd = this.createCommand(name);
        if (desc) {
          cmd.description(desc);
          cmd._executableHandler = true;
        }
        if (opts.isDefault)
          this._defaultCommandName = cmd._name;
        cmd._hidden = !!(opts.noHelp || opts.hidden);
        cmd._executableFile = opts.executableFile || null;
        if (args)
          cmd.arguments(args);
        this._registerCommand(cmd);
        cmd.parent = this;
        cmd.copyInheritedSettings(this);
        if (desc)
          return this;
        return cmd;
      }
      /**
       * Factory routine to create a new unattached command.
       *
       * See .command() for creating an attached subcommand, which uses this routine to
       * create the command. You can override createCommand to customise subcommands.
       *
       * @param {string} [name]
       * @return {Command} new command
       */
      createCommand(name) {
        return new Command2(name);
      }
      /**
       * You can customise the help with a subclass of Help by overriding createHelp,
       * or by overriding Help properties using configureHelp().
       *
       * @return {Help}
       */
      createHelp() {
        return Object.assign(new Help2(), this.configureHelp());
      }
      /**
       * You can customise the help by overriding Help properties using configureHelp(),
       * or with a subclass of Help by overriding createHelp().
       *
       * @param {object} [configuration] - configuration options
       * @return {(Command | object)} `this` command for chaining, or stored configuration
       */
      configureHelp(configuration) {
        if (configuration === void 0)
          return this._helpConfiguration;
        this._helpConfiguration = configuration;
        return this;
      }
      /**
       * The default output goes to stdout and stderr. You can customise this for special
       * applications. You can also customise the display of errors by overriding outputError.
       *
       * The configuration properties are all functions:
       *
       *     // functions to change where being written, stdout and stderr
       *     writeOut(str)
       *     writeErr(str)
       *     // matching functions to specify width for wrapping help
       *     getOutHelpWidth()
       *     getErrHelpWidth()
       *     // functions based on what is being written out
       *     outputError(str, write) // used for displaying errors, and not used for displaying help
       *
       * @param {object} [configuration] - configuration options
       * @return {(Command | object)} `this` command for chaining, or stored configuration
       */
      configureOutput(configuration) {
        if (configuration === void 0)
          return this._outputConfiguration;
        Object.assign(this._outputConfiguration, configuration);
        return this;
      }
      /**
       * Display the help or a custom message after an error occurs.
       *
       * @param {(boolean|string)} [displayHelp]
       * @return {Command} `this` command for chaining
       */
      showHelpAfterError(displayHelp = true) {
        if (typeof displayHelp !== "string")
          displayHelp = !!displayHelp;
        this._showHelpAfterError = displayHelp;
        return this;
      }
      /**
       * Display suggestion of similar commands for unknown commands, or options for unknown options.
       *
       * @param {boolean} [displaySuggestion]
       * @return {Command} `this` command for chaining
       */
      showSuggestionAfterError(displaySuggestion = true) {
        this._showSuggestionAfterError = !!displaySuggestion;
        return this;
      }
      /**
       * Add a prepared subcommand.
       *
       * See .command() for creating an attached subcommand which inherits settings from its parent.
       *
       * @param {Command} cmd - new subcommand
       * @param {object} [opts] - configuration options
       * @return {Command} `this` command for chaining
       */
      addCommand(cmd, opts) {
        if (!cmd._name) {
          throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
        }
        opts = opts || {};
        if (opts.isDefault)
          this._defaultCommandName = cmd._name;
        if (opts.noHelp || opts.hidden)
          cmd._hidden = true;
        this._registerCommand(cmd);
        cmd.parent = this;
        cmd._checkForBrokenPassThrough();
        return this;
      }
      /**
       * Factory routine to create a new unattached argument.
       *
       * See .argument() for creating an attached argument, which uses this routine to
       * create the argument. You can override createArgument to return a custom argument.
       *
       * @param {string} name
       * @param {string} [description]
       * @return {Argument} new argument
       */
      createArgument(name, description) {
        return new Argument2(name, description);
      }
      /**
       * Define argument syntax for command.
       *
       * The default is that the argument is required, and you can explicitly
       * indicate this with <> around the name. Put [] around the name for an optional argument.
       *
       * @example
       * program.argument('<input-file>');
       * program.argument('[output-file]');
       *
       * @param {string} name
       * @param {string} [description]
       * @param {(Function|*)} [fn] - custom argument processing function
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */
      argument(name, description, fn, defaultValue) {
        const argument = this.createArgument(name, description);
        if (typeof fn === "function") {
          argument.default(defaultValue).argParser(fn);
        } else {
          argument.default(fn);
        }
        this.addArgument(argument);
        return this;
      }
      /**
       * Define argument syntax for command, adding multiple at once (without descriptions).
       *
       * See also .argument().
       *
       * @example
       * program.arguments('<cmd> [env]');
       *
       * @param {string} names
       * @return {Command} `this` command for chaining
       */
      arguments(names) {
        names.trim().split(/ +/).forEach((detail) => {
          this.argument(detail);
        });
        return this;
      }
      /**
       * Define argument syntax for command, adding a prepared argument.
       *
       * @param {Argument} argument
       * @return {Command} `this` command for chaining
       */
      addArgument(argument) {
        const previousArgument = this.registeredArguments.slice(-1)[0];
        if (previousArgument && previousArgument.variadic) {
          throw new Error(
            `only the last argument can be variadic '${previousArgument.name()}'`
          );
        }
        if (argument.required && argument.defaultValue !== void 0 && argument.parseArg === void 0) {
          throw new Error(
            `a default value for a required argument is never used: '${argument.name()}'`
          );
        }
        this.registeredArguments.push(argument);
        return this;
      }
      /**
       * Customise or override default help command. By default a help command is automatically added if your command has subcommands.
       *
       * @example
       *    program.helpCommand('help [cmd]');
       *    program.helpCommand('help [cmd]', 'show help');
       *    program.helpCommand(false); // suppress default help command
       *    program.helpCommand(true); // add help command even if no subcommands
       *
       * @param {string|boolean} enableOrNameAndArgs - enable with custom name and/or arguments, or boolean to override whether added
       * @param {string} [description] - custom description
       * @return {Command} `this` command for chaining
       */
      helpCommand(enableOrNameAndArgs, description) {
        if (typeof enableOrNameAndArgs === "boolean") {
          this._addImplicitHelpCommand = enableOrNameAndArgs;
          return this;
        }
        enableOrNameAndArgs = enableOrNameAndArgs ?? "help [command]";
        const [, helpName, helpArgs] = enableOrNameAndArgs.match(/([^ ]+) *(.*)/);
        const helpDescription = description ?? "display help for command";
        const helpCommand = this.createCommand(helpName);
        helpCommand.helpOption(false);
        if (helpArgs)
          helpCommand.arguments(helpArgs);
        if (helpDescription)
          helpCommand.description(helpDescription);
        this._addImplicitHelpCommand = true;
        this._helpCommand = helpCommand;
        return this;
      }
      /**
       * Add prepared custom help command.
       *
       * @param {(Command|string|boolean)} helpCommand - custom help command, or deprecated enableOrNameAndArgs as for `.helpCommand()`
       * @param {string} [deprecatedDescription] - deprecated custom description used with custom name only
       * @return {Command} `this` command for chaining
       */
      addHelpCommand(helpCommand, deprecatedDescription) {
        if (typeof helpCommand !== "object") {
          this.helpCommand(helpCommand, deprecatedDescription);
          return this;
        }
        this._addImplicitHelpCommand = true;
        this._helpCommand = helpCommand;
        return this;
      }
      /**
       * Lazy create help command.
       *
       * @return {(Command|null)}
       * @package
       */
      _getHelpCommand() {
        const hasImplicitHelpCommand = this._addImplicitHelpCommand ?? (this.commands.length && !this._actionHandler && !this._findCommand("help"));
        if (hasImplicitHelpCommand) {
          if (this._helpCommand === void 0) {
            this.helpCommand(void 0, void 0);
          }
          return this._helpCommand;
        }
        return null;
      }
      /**
       * Add hook for life cycle event.
       *
       * @param {string} event
       * @param {Function} listener
       * @return {Command} `this` command for chaining
       */
      hook(event, listener) {
        const allowedValues = ["preSubcommand", "preAction", "postAction"];
        if (!allowedValues.includes(event)) {
          throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        if (this._lifeCycleHooks[event]) {
          this._lifeCycleHooks[event].push(listener);
        } else {
          this._lifeCycleHooks[event] = [listener];
        }
        return this;
      }
      /**
       * Register callback to use as replacement for calling process.exit.
       *
       * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
       * @return {Command} `this` command for chaining
       */
      exitOverride(fn) {
        if (fn) {
          this._exitCallback = fn;
        } else {
          this._exitCallback = (err) => {
            if (err.code !== "commander.executeSubCommandAsync") {
              throw err;
            } else {
            }
          };
        }
        return this;
      }
      /**
       * Call process.exit, and _exitCallback if defined.
       *
       * @param {number} exitCode exit code for using with process.exit
       * @param {string} code an id string representing the error
       * @param {string} message human-readable description of the error
       * @return never
       * @private
       */
      _exit(exitCode, code, message) {
        if (this._exitCallback) {
          this._exitCallback(new CommanderError2(exitCode, code, message));
        }
        process9.exit(exitCode);
      }
      /**
       * Register callback `fn` for the command.
       *
       * @example
       * program
       *   .command('serve')
       *   .description('start service')
       *   .action(function() {
       *      // do work here
       *   });
       *
       * @param {Function} fn
       * @return {Command} `this` command for chaining
       */
      action(fn) {
        const listener = (args) => {
          const expectedArgsCount = this.registeredArguments.length;
          const actionArgs = args.slice(0, expectedArgsCount);
          if (this._storeOptionsAsProperties) {
            actionArgs[expectedArgsCount] = this;
          } else {
            actionArgs[expectedArgsCount] = this.opts();
          }
          actionArgs.push(this);
          return fn.apply(this, actionArgs);
        };
        this._actionHandler = listener;
        return this;
      }
      /**
       * Factory routine to create a new unattached option.
       *
       * See .option() for creating an attached option, which uses this routine to
       * create the option. You can override createOption to return a custom option.
       *
       * @param {string} flags
       * @param {string} [description]
       * @return {Option} new option
       */
      createOption(flags, description) {
        return new Option2(flags, description);
      }
      /**
       * Wrap parseArgs to catch 'commander.invalidArgument'.
       *
       * @param {(Option | Argument)} target
       * @param {string} value
       * @param {*} previous
       * @param {string} invalidArgumentMessage
       * @private
       */
      _callParseArg(target, value, previous, invalidArgumentMessage) {
        try {
          return target.parseArg(value, previous);
        } catch (err) {
          if (err.code === "commander.invalidArgument") {
            const message = `${invalidArgumentMessage} ${err.message}`;
            this.error(message, { exitCode: err.exitCode, code: err.code });
          }
          throw err;
        }
      }
      /**
       * Check for option flag conflicts.
       * Register option if no conflicts found, or throw on conflict.
       *
       * @param {Option} option
       * @private
       */
      _registerOption(option) {
        const matchingOption = option.short && this._findOption(option.short) || option.long && this._findOption(option.long);
        if (matchingOption) {
          const matchingFlag = option.long && this._findOption(option.long) ? option.long : option.short;
          throw new Error(`Cannot add option '${option.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${matchingFlag}'
-  already used by option '${matchingOption.flags}'`);
        }
        this.options.push(option);
      }
      /**
       * Check for command name and alias conflicts with existing commands.
       * Register command if no conflicts found, or throw on conflict.
       *
       * @param {Command} command
       * @private
       */
      _registerCommand(command) {
        const knownBy = (cmd) => {
          return [cmd.name()].concat(cmd.aliases());
        };
        const alreadyUsed = knownBy(command).find(
          (name) => this._findCommand(name)
        );
        if (alreadyUsed) {
          const existingCmd = knownBy(this._findCommand(alreadyUsed)).join("|");
          const newCmd = knownBy(command).join("|");
          throw new Error(
            `cannot add command '${newCmd}' as already have command '${existingCmd}'`
          );
        }
        this.commands.push(command);
      }
      /**
       * Add an option.
       *
       * @param {Option} option
       * @return {Command} `this` command for chaining
       */
      addOption(option) {
        this._registerOption(option);
        const oname = option.name();
        const name = option.attributeName();
        if (option.negate) {
          const positiveLongFlag = option.long.replace(/^--no-/, "--");
          if (!this._findOption(positiveLongFlag)) {
            this.setOptionValueWithSource(
              name,
              option.defaultValue === void 0 ? true : option.defaultValue,
              "default"
            );
          }
        } else if (option.defaultValue !== void 0) {
          this.setOptionValueWithSource(name, option.defaultValue, "default");
        }
        const handleOptionValue = (val, invalidValueMessage, valueSource) => {
          if (val == null && option.presetArg !== void 0) {
            val = option.presetArg;
          }
          const oldValue = this.getOptionValue(name);
          if (val !== null && option.parseArg) {
            val = this._callParseArg(option, val, oldValue, invalidValueMessage);
          } else if (val !== null && option.variadic) {
            val = option._concatValue(val, oldValue);
          }
          if (val == null) {
            if (option.negate) {
              val = false;
            } else if (option.isBoolean() || option.optional) {
              val = true;
            } else {
              val = "";
            }
          }
          this.setOptionValueWithSource(name, val, valueSource);
        };
        this.on("option:" + oname, (val) => {
          const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
          handleOptionValue(val, invalidValueMessage, "cli");
        });
        if (option.envVar) {
          this.on("optionEnv:" + oname, (val) => {
            const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
            handleOptionValue(val, invalidValueMessage, "env");
          });
        }
        return this;
      }
      /**
       * Internal implementation shared by .option() and .requiredOption()
       *
       * @return {Command} `this` command for chaining
       * @private
       */
      _optionEx(config2, flags, description, fn, defaultValue) {
        if (typeof flags === "object" && flags instanceof Option2) {
          throw new Error(
            "To add an Option object use addOption() instead of option() or requiredOption()"
          );
        }
        const option = this.createOption(flags, description);
        option.makeOptionMandatory(!!config2.mandatory);
        if (typeof fn === "function") {
          option.default(defaultValue).argParser(fn);
        } else if (fn instanceof RegExp) {
          const regex = fn;
          fn = (val, def) => {
            const m = regex.exec(val);
            return m ? m[0] : def;
          };
          option.default(defaultValue).argParser(fn);
        } else {
          option.default(fn);
        }
        return this.addOption(option);
      }
      /**
       * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.
       *
       * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required
       * option-argument is indicated by `<>` and an optional option-argument by `[]`.
       *
       * See the README for more details, and see also addOption() and requiredOption().
       *
       * @example
       * program
       *     .option('-p, --pepper', 'add pepper')
       *     .option('-p, --pizza-type <TYPE>', 'type of pizza') // required option-argument
       *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default
       *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function
       *
       * @param {string} flags
       * @param {string} [description]
       * @param {(Function|*)} [parseArg] - custom option processing function or default value
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */
      option(flags, description, parseArg, defaultValue) {
        return this._optionEx({}, flags, description, parseArg, defaultValue);
      }
      /**
       * Add a required option which must have a value after parsing. This usually means
       * the option must be specified on the command line. (Otherwise the same as .option().)
       *
       * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
       *
       * @param {string} flags
       * @param {string} [description]
       * @param {(Function|*)} [parseArg] - custom option processing function or default value
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */
      requiredOption(flags, description, parseArg, defaultValue) {
        return this._optionEx(
          { mandatory: true },
          flags,
          description,
          parseArg,
          defaultValue
        );
      }
      /**
       * Alter parsing of short flags with optional values.
       *
       * @example
       * // for `.option('-f,--flag [value]'):
       * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
       * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
       *
       * @param {boolean} [combine] - if `true` or omitted, an optional value can be specified directly after the flag.
       * @return {Command} `this` command for chaining
       */
      combineFlagAndOptionalValue(combine = true) {
        this._combineFlagAndOptionalValue = !!combine;
        return this;
      }
      /**
       * Allow unknown options on the command line.
       *
       * @param {boolean} [allowUnknown] - if `true` or omitted, no error will be thrown for unknown options.
       * @return {Command} `this` command for chaining
       */
      allowUnknownOption(allowUnknown = true) {
        this._allowUnknownOption = !!allowUnknown;
        return this;
      }
      /**
       * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
       *
       * @param {boolean} [allowExcess] - if `true` or omitted, no error will be thrown for excess arguments.
       * @return {Command} `this` command for chaining
       */
      allowExcessArguments(allowExcess = true) {
        this._allowExcessArguments = !!allowExcess;
        return this;
      }
      /**
       * Enable positional options. Positional means global options are specified before subcommands which lets
       * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
       * The default behaviour is non-positional and global options may appear anywhere on the command line.
       *
       * @param {boolean} [positional]
       * @return {Command} `this` command for chaining
       */
      enablePositionalOptions(positional = true) {
        this._enablePositionalOptions = !!positional;
        return this;
      }
      /**
       * Pass through options that come after command-arguments rather than treat them as command-options,
       * so actual command-options come before command-arguments. Turning this on for a subcommand requires
       * positional options to have been enabled on the program (parent commands).
       * The default behaviour is non-positional and options may appear before or after command-arguments.
       *
       * @param {boolean} [passThrough] for unknown options.
       * @return {Command} `this` command for chaining
       */
      passThroughOptions(passThrough = true) {
        this._passThroughOptions = !!passThrough;
        this._checkForBrokenPassThrough();
        return this;
      }
      /**
       * @private
       */
      _checkForBrokenPassThrough() {
        if (this.parent && this._passThroughOptions && !this.parent._enablePositionalOptions) {
          throw new Error(
            `passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`
          );
        }
      }
      /**
       * Whether to store option values as properties on command object,
       * or store separately (specify false). In both cases the option values can be accessed using .opts().
       *
       * @param {boolean} [storeAsProperties=true]
       * @return {Command} `this` command for chaining
       */
      storeOptionsAsProperties(storeAsProperties = true) {
        if (this.options.length) {
          throw new Error("call .storeOptionsAsProperties() before adding options");
        }
        if (Object.keys(this._optionValues).length) {
          throw new Error(
            "call .storeOptionsAsProperties() before setting option values"
          );
        }
        this._storeOptionsAsProperties = !!storeAsProperties;
        return this;
      }
      /**
       * Retrieve option value.
       *
       * @param {string} key
       * @return {object} value
       */
      getOptionValue(key) {
        if (this._storeOptionsAsProperties) {
          return this[key];
        }
        return this._optionValues[key];
      }
      /**
       * Store option value.
       *
       * @param {string} key
       * @param {object} value
       * @return {Command} `this` command for chaining
       */
      setOptionValue(key, value) {
        return this.setOptionValueWithSource(key, value, void 0);
      }
      /**
       * Store option value and where the value came from.
       *
       * @param {string} key
       * @param {object} value
       * @param {string} source - expected values are default/config/env/cli/implied
       * @return {Command} `this` command for chaining
       */
      setOptionValueWithSource(key, value, source) {
        if (this._storeOptionsAsProperties) {
          this[key] = value;
        } else {
          this._optionValues[key] = value;
        }
        this._optionValueSources[key] = source;
        return this;
      }
      /**
       * Get source of option value.
       * Expected values are default | config | env | cli | implied
       *
       * @param {string} key
       * @return {string}
       */
      getOptionValueSource(key) {
        return this._optionValueSources[key];
      }
      /**
       * Get source of option value. See also .optsWithGlobals().
       * Expected values are default | config | env | cli | implied
       *
       * @param {string} key
       * @return {string}
       */
      getOptionValueSourceWithGlobals(key) {
        let source;
        this._getCommandAndAncestors().forEach((cmd) => {
          if (cmd.getOptionValueSource(key) !== void 0) {
            source = cmd.getOptionValueSource(key);
          }
        });
        return source;
      }
      /**
       * Get user arguments from implied or explicit arguments.
       * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
       *
       * @private
       */
      _prepareUserArgs(argv, parseOptions) {
        if (argv !== void 0 && !Array.isArray(argv)) {
          throw new Error("first parameter to parse must be array or undefined");
        }
        parseOptions = parseOptions || {};
        if (argv === void 0 && parseOptions.from === void 0) {
          if (process9.versions?.electron) {
            parseOptions.from = "electron";
          }
          const execArgv = process9.execArgv ?? [];
          if (execArgv.includes("-e") || execArgv.includes("--eval") || execArgv.includes("-p") || execArgv.includes("--print")) {
            parseOptions.from = "eval";
          }
        }
        if (argv === void 0) {
          argv = process9.argv;
        }
        this.rawArgs = argv.slice();
        let userArgs;
        switch (parseOptions.from) {
          case void 0:
          case "node":
            this._scriptPath = argv[1];
            userArgs = argv.slice(2);
            break;
          case "electron":
            if (process9.defaultApp) {
              this._scriptPath = argv[1];
              userArgs = argv.slice(2);
            } else {
              userArgs = argv.slice(1);
            }
            break;
          case "user":
            userArgs = argv.slice(0);
            break;
          case "eval":
            userArgs = argv.slice(1);
            break;
          default:
            throw new Error(
              `unexpected parse option { from: '${parseOptions.from}' }`
            );
        }
        if (!this._name && this._scriptPath)
          this.nameFromFilename(this._scriptPath);
        this._name = this._name || "program";
        return userArgs;
      }
      /**
       * Parse `argv`, setting options and invoking commands when defined.
       *
       * Use parseAsync instead of parse if any of your action handlers are async.
       *
       * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
       *
       * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
       * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
       * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
       * - `'user'`: just user arguments
       *
       * @example
       * program.parse(); // parse process.argv and auto-detect electron and special node flags
       * program.parse(process.argv); // assume argv[0] is app and argv[1] is script
       * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
       *
       * @param {string[]} [argv] - optional, defaults to process.argv
       * @param {object} [parseOptions] - optionally specify style of options with from: node/user/electron
       * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
       * @return {Command} `this` command for chaining
       */
      parse(argv, parseOptions) {
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        this._parseCommand([], userArgs);
        return this;
      }
      /**
       * Parse `argv`, setting options and invoking commands when defined.
       *
       * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
       *
       * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
       * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
       * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
       * - `'user'`: just user arguments
       *
       * @example
       * await program.parseAsync(); // parse process.argv and auto-detect electron and special node flags
       * await program.parseAsync(process.argv); // assume argv[0] is app and argv[1] is script
       * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
       *
       * @param {string[]} [argv]
       * @param {object} [parseOptions]
       * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
       * @return {Promise}
       */
      async parseAsync(argv, parseOptions) {
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        await this._parseCommand([], userArgs);
        return this;
      }
      /**
       * Execute a sub-command executable.
       *
       * @private
       */
      _executeSubCommand(subcommand, args) {
        args = args.slice();
        let launchWithNode = false;
        const sourceExt = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
        function findFile(baseDir, baseName) {
          const localBin = path6.resolve(baseDir, baseName);
          if (fs2.existsSync(localBin))
            return localBin;
          if (sourceExt.includes(path6.extname(baseName)))
            return void 0;
          const foundExt = sourceExt.find(
            (ext) => fs2.existsSync(`${localBin}${ext}`)
          );
          if (foundExt)
            return `${localBin}${foundExt}`;
          return void 0;
        }
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();
        let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
        let executableDir = this._executableDir || "";
        if (this._scriptPath) {
          let resolvedScriptPath;
          try {
            resolvedScriptPath = fs2.realpathSync(this._scriptPath);
          } catch (err) {
            resolvedScriptPath = this._scriptPath;
          }
          executableDir = path6.resolve(
            path6.dirname(resolvedScriptPath),
            executableDir
          );
        }
        if (executableDir) {
          let localFile = findFile(executableDir, executableFile);
          if (!localFile && !subcommand._executableFile && this._scriptPath) {
            const legacyName = path6.basename(
              this._scriptPath,
              path6.extname(this._scriptPath)
            );
            if (legacyName !== this._name) {
              localFile = findFile(
                executableDir,
                `${legacyName}-${subcommand._name}`
              );
            }
          }
          executableFile = localFile || executableFile;
        }
        launchWithNode = sourceExt.includes(path6.extname(executableFile));
        let proc;
        if (process9.platform !== "win32") {
          if (launchWithNode) {
            args.unshift(executableFile);
            args = incrementNodeInspectorPort(process9.execArgv).concat(args);
            proc = childProcess2.spawn(process9.argv[0], args, { stdio: "inherit" });
          } else {
            proc = childProcess2.spawn(executableFile, args, { stdio: "inherit" });
          }
        } else {
          args.unshift(executableFile);
          args = incrementNodeInspectorPort(process9.execArgv).concat(args);
          proc = childProcess2.spawn(process9.execPath, args, { stdio: "inherit" });
        }
        if (!proc.killed) {
          const signals2 = ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"];
          signals2.forEach((signal) => {
            process9.on(signal, () => {
              if (proc.killed === false && proc.exitCode === null) {
                proc.kill(signal);
              }
            });
          });
        }
        const exitCallback = this._exitCallback;
        proc.on("close", (code) => {
          code = code ?? 1;
          if (!exitCallback) {
            process9.exit(code);
          } else {
            exitCallback(
              new CommanderError2(
                code,
                "commander.executeSubCommandAsync",
                "(close)"
              )
            );
          }
        });
        proc.on("error", (err) => {
          if (err.code === "ENOENT") {
            const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : "no directory for search for local subcommand, use .executableDir() to supply a custom directory";
            const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
            throw new Error(executableMissing);
          } else if (err.code === "EACCES") {
            throw new Error(`'${executableFile}' not executable`);
          }
          if (!exitCallback) {
            process9.exit(1);
          } else {
            const wrappedError = new CommanderError2(
              1,
              "commander.executeSubCommandAsync",
              "(error)"
            );
            wrappedError.nestedError = err;
            exitCallback(wrappedError);
          }
        });
        this.runningCommand = proc;
      }
      /**
       * @private
       */
      _dispatchSubcommand(commandName, operands, unknown) {
        const subCommand = this._findCommand(commandName);
        if (!subCommand)
          this.help({ error: true });
        let promiseChain;
        promiseChain = this._chainOrCallSubCommandHook(
          promiseChain,
          subCommand,
          "preSubcommand"
        );
        promiseChain = this._chainOrCall(promiseChain, () => {
          if (subCommand._executableHandler) {
            this._executeSubCommand(subCommand, operands.concat(unknown));
          } else {
            return subCommand._parseCommand(operands, unknown);
          }
        });
        return promiseChain;
      }
      /**
       * Invoke help directly if possible, or dispatch if necessary.
       * e.g. help foo
       *
       * @private
       */
      _dispatchHelpCommand(subcommandName) {
        if (!subcommandName) {
          this.help();
        }
        const subCommand = this._findCommand(subcommandName);
        if (subCommand && !subCommand._executableHandler) {
          subCommand.help();
        }
        return this._dispatchSubcommand(
          subcommandName,
          [],
          [this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? "--help"]
        );
      }
      /**
       * Check this.args against expected this.registeredArguments.
       *
       * @private
       */
      _checkNumberOfArguments() {
        this.registeredArguments.forEach((arg, i) => {
          if (arg.required && this.args[i] == null) {
            this.missingArgument(arg.name());
          }
        });
        if (this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) {
          return;
        }
        if (this.args.length > this.registeredArguments.length) {
          this._excessArguments(this.args);
        }
      }
      /**
       * Process this.args using this.registeredArguments and save as this.processedArgs!
       *
       * @private
       */
      _processArguments() {
        const myParseArg = (argument, value, previous) => {
          let parsedValue = value;
          if (value !== null && argument.parseArg) {
            const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
            parsedValue = this._callParseArg(
              argument,
              value,
              previous,
              invalidValueMessage
            );
          }
          return parsedValue;
        };
        this._checkNumberOfArguments();
        const processedArgs = [];
        this.registeredArguments.forEach((declaredArg, index) => {
          let value = declaredArg.defaultValue;
          if (declaredArg.variadic) {
            if (index < this.args.length) {
              value = this.args.slice(index);
              if (declaredArg.parseArg) {
                value = value.reduce((processed, v) => {
                  return myParseArg(declaredArg, v, processed);
                }, declaredArg.defaultValue);
              }
            } else if (value === void 0) {
              value = [];
            }
          } else if (index < this.args.length) {
            value = this.args[index];
            if (declaredArg.parseArg) {
              value = myParseArg(declaredArg, value, declaredArg.defaultValue);
            }
          }
          processedArgs[index] = value;
        });
        this.processedArgs = processedArgs;
      }
      /**
       * Once we have a promise we chain, but call synchronously until then.
       *
       * @param {(Promise|undefined)} promise
       * @param {Function} fn
       * @return {(Promise|undefined)}
       * @private
       */
      _chainOrCall(promise, fn) {
        if (promise && promise.then && typeof promise.then === "function") {
          return promise.then(() => fn());
        }
        return fn();
      }
      /**
       *
       * @param {(Promise|undefined)} promise
       * @param {string} event
       * @return {(Promise|undefined)}
       * @private
       */
      _chainOrCallHooks(promise, event) {
        let result = promise;
        const hooks = [];
        this._getCommandAndAncestors().reverse().filter((cmd) => cmd._lifeCycleHooks[event] !== void 0).forEach((hookedCommand) => {
          hookedCommand._lifeCycleHooks[event].forEach((callback) => {
            hooks.push({ hookedCommand, callback });
          });
        });
        if (event === "postAction") {
          hooks.reverse();
        }
        hooks.forEach((hookDetail) => {
          result = this._chainOrCall(result, () => {
            return hookDetail.callback(hookDetail.hookedCommand, this);
          });
        });
        return result;
      }
      /**
       *
       * @param {(Promise|undefined)} promise
       * @param {Command} subCommand
       * @param {string} event
       * @return {(Promise|undefined)}
       * @private
       */
      _chainOrCallSubCommandHook(promise, subCommand, event) {
        let result = promise;
        if (this._lifeCycleHooks[event] !== void 0) {
          this._lifeCycleHooks[event].forEach((hook) => {
            result = this._chainOrCall(result, () => {
              return hook(this, subCommand);
            });
          });
        }
        return result;
      }
      /**
       * Process arguments in context of this command.
       * Returns action result, in case it is a promise.
       *
       * @private
       */
      _parseCommand(operands, unknown) {
        const parsed = this.parseOptions(unknown);
        this._parseOptionsEnv();
        this._parseOptionsImplied();
        operands = operands.concat(parsed.operands);
        unknown = parsed.unknown;
        this.args = operands.concat(unknown);
        if (operands && this._findCommand(operands[0])) {
          return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
        }
        if (this._getHelpCommand() && operands[0] === this._getHelpCommand().name()) {
          return this._dispatchHelpCommand(operands[1]);
        }
        if (this._defaultCommandName) {
          this._outputHelpIfRequested(unknown);
          return this._dispatchSubcommand(
            this._defaultCommandName,
            operands,
            unknown
          );
        }
        if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
          this.help({ error: true });
        }
        this._outputHelpIfRequested(parsed.unknown);
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();
        const checkForUnknownOptions = () => {
          if (parsed.unknown.length > 0) {
            this.unknownOption(parsed.unknown[0]);
          }
        };
        const commandEvent = `command:${this.name()}`;
        if (this._actionHandler) {
          checkForUnknownOptions();
          this._processArguments();
          let promiseChain;
          promiseChain = this._chainOrCallHooks(promiseChain, "preAction");
          promiseChain = this._chainOrCall(
            promiseChain,
            () => this._actionHandler(this.processedArgs)
          );
          if (this.parent) {
            promiseChain = this._chainOrCall(promiseChain, () => {
              this.parent.emit(commandEvent, operands, unknown);
            });
          }
          promiseChain = this._chainOrCallHooks(promiseChain, "postAction");
          return promiseChain;
        }
        if (this.parent && this.parent.listenerCount(commandEvent)) {
          checkForUnknownOptions();
          this._processArguments();
          this.parent.emit(commandEvent, operands, unknown);
        } else if (operands.length) {
          if (this._findCommand("*")) {
            return this._dispatchSubcommand("*", operands, unknown);
          }
          if (this.listenerCount("command:*")) {
            this.emit("command:*", operands, unknown);
          } else if (this.commands.length) {
            this.unknownCommand();
          } else {
            checkForUnknownOptions();
            this._processArguments();
          }
        } else if (this.commands.length) {
          checkForUnknownOptions();
          this.help({ error: true });
        } else {
          checkForUnknownOptions();
          this._processArguments();
        }
      }
      /**
       * Find matching command.
       *
       * @private
       * @return {Command | undefined}
       */
      _findCommand(name) {
        if (!name)
          return void 0;
        return this.commands.find(
          (cmd) => cmd._name === name || cmd._aliases.includes(name)
        );
      }
      /**
       * Return an option matching `arg` if any.
       *
       * @param {string} arg
       * @return {Option}
       * @package
       */
      _findOption(arg) {
        return this.options.find((option) => option.is(arg));
      }
      /**
       * Display an error message if a mandatory option does not have a value.
       * Called after checking for help flags in leaf subcommand.
       *
       * @private
       */
      _checkForMissingMandatoryOptions() {
        this._getCommandAndAncestors().forEach((cmd) => {
          cmd.options.forEach((anOption) => {
            if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === void 0) {
              cmd.missingMandatoryOptionValue(anOption);
            }
          });
        });
      }
      /**
       * Display an error message if conflicting options are used together in this.
       *
       * @private
       */
      _checkForConflictingLocalOptions() {
        const definedNonDefaultOptions = this.options.filter((option) => {
          const optionKey = option.attributeName();
          if (this.getOptionValue(optionKey) === void 0) {
            return false;
          }
          return this.getOptionValueSource(optionKey) !== "default";
        });
        const optionsWithConflicting = definedNonDefaultOptions.filter(
          (option) => option.conflictsWith.length > 0
        );
        optionsWithConflicting.forEach((option) => {
          const conflictingAndDefined = definedNonDefaultOptions.find(
            (defined) => option.conflictsWith.includes(defined.attributeName())
          );
          if (conflictingAndDefined) {
            this._conflictingOption(option, conflictingAndDefined);
          }
        });
      }
      /**
       * Display an error message if conflicting options are used together.
       * Called after checking for help flags in leaf subcommand.
       *
       * @private
       */
      _checkForConflictingOptions() {
        this._getCommandAndAncestors().forEach((cmd) => {
          cmd._checkForConflictingLocalOptions();
        });
      }
      /**
       * Parse options from `argv` removing known options,
       * and return argv split into operands and unknown arguments.
       *
       * Examples:
       *
       *     argv => operands, unknown
       *     --known kkk op => [op], []
       *     op --known kkk => [op], []
       *     sub --unknown uuu op => [sub], [--unknown uuu op]
       *     sub -- --unknown uuu op => [sub --unknown uuu op], []
       *
       * @param {string[]} argv
       * @return {{operands: string[], unknown: string[]}}
       */
      parseOptions(argv) {
        const operands = [];
        const unknown = [];
        let dest = operands;
        const args = argv.slice();
        function maybeOption(arg) {
          return arg.length > 1 && arg[0] === "-";
        }
        let activeVariadicOption = null;
        while (args.length) {
          const arg = args.shift();
          if (arg === "--") {
            if (dest === unknown)
              dest.push(arg);
            dest.push(...args);
            break;
          }
          if (activeVariadicOption && !maybeOption(arg)) {
            this.emit(`option:${activeVariadicOption.name()}`, arg);
            continue;
          }
          activeVariadicOption = null;
          if (maybeOption(arg)) {
            const option = this._findOption(arg);
            if (option) {
              if (option.required) {
                const value = args.shift();
                if (value === void 0)
                  this.optionMissingArgument(option);
                this.emit(`option:${option.name()}`, value);
              } else if (option.optional) {
                let value = null;
                if (args.length > 0 && !maybeOption(args[0])) {
                  value = args.shift();
                }
                this.emit(`option:${option.name()}`, value);
              } else {
                this.emit(`option:${option.name()}`);
              }
              activeVariadicOption = option.variadic ? option : null;
              continue;
            }
          }
          if (arg.length > 2 && arg[0] === "-" && arg[1] !== "-") {
            const option = this._findOption(`-${arg[1]}`);
            if (option) {
              if (option.required || option.optional && this._combineFlagAndOptionalValue) {
                this.emit(`option:${option.name()}`, arg.slice(2));
              } else {
                this.emit(`option:${option.name()}`);
                args.unshift(`-${arg.slice(2)}`);
              }
              continue;
            }
          }
          if (/^--[^=]+=/.test(arg)) {
            const index = arg.indexOf("=");
            const option = this._findOption(arg.slice(0, index));
            if (option && (option.required || option.optional)) {
              this.emit(`option:${option.name()}`, arg.slice(index + 1));
              continue;
            }
          }
          if (maybeOption(arg)) {
            dest = unknown;
          }
          if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
            if (this._findCommand(arg)) {
              operands.push(arg);
              if (args.length > 0)
                unknown.push(...args);
              break;
            } else if (this._getHelpCommand() && arg === this._getHelpCommand().name()) {
              operands.push(arg);
              if (args.length > 0)
                operands.push(...args);
              break;
            } else if (this._defaultCommandName) {
              unknown.push(arg);
              if (args.length > 0)
                unknown.push(...args);
              break;
            }
          }
          if (this._passThroughOptions) {
            dest.push(arg);
            if (args.length > 0)
              dest.push(...args);
            break;
          }
          dest.push(arg);
        }
        return { operands, unknown };
      }
      /**
       * Return an object containing local option values as key-value pairs.
       *
       * @return {object}
       */
      opts() {
        if (this._storeOptionsAsProperties) {
          const result = {};
          const len = this.options.length;
          for (let i = 0; i < len; i++) {
            const key = this.options[i].attributeName();
            result[key] = key === this._versionOptionName ? this._version : this[key];
          }
          return result;
        }
        return this._optionValues;
      }
      /**
       * Return an object containing merged local and global option values as key-value pairs.
       *
       * @return {object}
       */
      optsWithGlobals() {
        return this._getCommandAndAncestors().reduce(
          (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),
          {}
        );
      }
      /**
       * Display error message and exit (or call exitOverride).
       *
       * @param {string} message
       * @param {object} [errorOptions]
       * @param {string} [errorOptions.code] - an id string representing the error
       * @param {number} [errorOptions.exitCode] - used with process.exit
       */
      error(message, errorOptions) {
        this._outputConfiguration.outputError(
          `${message}
`,
          this._outputConfiguration.writeErr
        );
        if (typeof this._showHelpAfterError === "string") {
          this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);
        } else if (this._showHelpAfterError) {
          this._outputConfiguration.writeErr("\n");
          this.outputHelp({ error: true });
        }
        const config2 = errorOptions || {};
        const exitCode = config2.exitCode || 1;
        const code = config2.code || "commander.error";
        this._exit(exitCode, code, message);
      }
      /**
       * Apply any option related environment variables, if option does
       * not have a value from cli or client code.
       *
       * @private
       */
      _parseOptionsEnv() {
        this.options.forEach((option) => {
          if (option.envVar && option.envVar in process9.env) {
            const optionKey = option.attributeName();
            if (this.getOptionValue(optionKey) === void 0 || ["default", "config", "env"].includes(
              this.getOptionValueSource(optionKey)
            )) {
              if (option.required || option.optional) {
                this.emit(`optionEnv:${option.name()}`, process9.env[option.envVar]);
              } else {
                this.emit(`optionEnv:${option.name()}`);
              }
            }
          }
        });
      }
      /**
       * Apply any implied option values, if option is undefined or default value.
       *
       * @private
       */
      _parseOptionsImplied() {
        const dualHelper = new DualOptions(this.options);
        const hasCustomOptionValue = (optionKey) => {
          return this.getOptionValue(optionKey) !== void 0 && !["default", "implied"].includes(this.getOptionValueSource(optionKey));
        };
        this.options.filter(
          (option) => option.implied !== void 0 && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(
            this.getOptionValue(option.attributeName()),
            option
          )
        ).forEach((option) => {
          Object.keys(option.implied).filter((impliedKey) => !hasCustomOptionValue(impliedKey)).forEach((impliedKey) => {
            this.setOptionValueWithSource(
              impliedKey,
              option.implied[impliedKey],
              "implied"
            );
          });
        });
      }
      /**
       * Argument `name` is missing.
       *
       * @param {string} name
       * @private
       */
      missingArgument(name) {
        const message = `error: missing required argument '${name}'`;
        this.error(message, { code: "commander.missingArgument" });
      }
      /**
       * `Option` is missing an argument.
       *
       * @param {Option} option
       * @private
       */
      optionMissingArgument(option) {
        const message = `error: option '${option.flags}' argument missing`;
        this.error(message, { code: "commander.optionMissingArgument" });
      }
      /**
       * `Option` does not have a value, and is a mandatory option.
       *
       * @param {Option} option
       * @private
       */
      missingMandatoryOptionValue(option) {
        const message = `error: required option '${option.flags}' not specified`;
        this.error(message, { code: "commander.missingMandatoryOptionValue" });
      }
      /**
       * `Option` conflicts with another option.
       *
       * @param {Option} option
       * @param {Option} conflictingOption
       * @private
       */
      _conflictingOption(option, conflictingOption) {
        const findBestOptionFromValue = (option2) => {
          const optionKey = option2.attributeName();
          const optionValue = this.getOptionValue(optionKey);
          const negativeOption = this.options.find(
            (target) => target.negate && optionKey === target.attributeName()
          );
          const positiveOption = this.options.find(
            (target) => !target.negate && optionKey === target.attributeName()
          );
          if (negativeOption && (negativeOption.presetArg === void 0 && optionValue === false || negativeOption.presetArg !== void 0 && optionValue === negativeOption.presetArg)) {
            return negativeOption;
          }
          return positiveOption || option2;
        };
        const getErrorMessage = (option2) => {
          const bestOption = findBestOptionFromValue(option2);
          const optionKey = bestOption.attributeName();
          const source = this.getOptionValueSource(optionKey);
          if (source === "env") {
            return `environment variable '${bestOption.envVar}'`;
          }
          return `option '${bestOption.flags}'`;
        };
        const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
        this.error(message, { code: "commander.conflictingOption" });
      }
      /**
       * Unknown option `flag`.
       *
       * @param {string} flag
       * @private
       */
      unknownOption(flag) {
        if (this._allowUnknownOption)
          return;
        let suggestion = "";
        if (flag.startsWith("--") && this._showSuggestionAfterError) {
          let candidateFlags = [];
          let command = this;
          do {
            const moreFlags = command.createHelp().visibleOptions(command).filter((option) => option.long).map((option) => option.long);
            candidateFlags = candidateFlags.concat(moreFlags);
            command = command.parent;
          } while (command && !command._enablePositionalOptions);
          suggestion = suggestSimilar(flag, candidateFlags);
        }
        const message = `error: unknown option '${flag}'${suggestion}`;
        this.error(message, { code: "commander.unknownOption" });
      }
      /**
       * Excess arguments, more than expected.
       *
       * @param {string[]} receivedArgs
       * @private
       */
      _excessArguments(receivedArgs) {
        if (this._allowExcessArguments)
          return;
        const expected = this.registeredArguments.length;
        const s = expected === 1 ? "" : "s";
        const forSubcommand = this.parent ? ` for '${this.name()}'` : "";
        const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
        this.error(message, { code: "commander.excessArguments" });
      }
      /**
       * Unknown command.
       *
       * @private
       */
      unknownCommand() {
        const unknownName = this.args[0];
        let suggestion = "";
        if (this._showSuggestionAfterError) {
          const candidateNames = [];
          this.createHelp().visibleCommands(this).forEach((command) => {
            candidateNames.push(command.name());
            if (command.alias())
              candidateNames.push(command.alias());
          });
          suggestion = suggestSimilar(unknownName, candidateNames);
        }
        const message = `error: unknown command '${unknownName}'${suggestion}`;
        this.error(message, { code: "commander.unknownCommand" });
      }
      /**
       * Get or set the program version.
       *
       * This method auto-registers the "-V, --version" option which will print the version number.
       *
       * You can optionally supply the flags and description to override the defaults.
       *
       * @param {string} [str]
       * @param {string} [flags]
       * @param {string} [description]
       * @return {(this | string | undefined)} `this` command for chaining, or version string if no arguments
       */
      version(str, flags, description) {
        if (str === void 0)
          return this._version;
        this._version = str;
        flags = flags || "-V, --version";
        description = description || "output the version number";
        const versionOption = this.createOption(flags, description);
        this._versionOptionName = versionOption.attributeName();
        this._registerOption(versionOption);
        this.on("option:" + versionOption.name(), () => {
          this._outputConfiguration.writeOut(`${str}
`);
          this._exit(0, "commander.version", str);
        });
        return this;
      }
      /**
       * Set the description.
       *
       * @param {string} [str]
       * @param {object} [argsDescription]
       * @return {(string|Command)}
       */
      description(str, argsDescription) {
        if (str === void 0 && argsDescription === void 0)
          return this._description;
        this._description = str;
        if (argsDescription) {
          this._argsDescription = argsDescription;
        }
        return this;
      }
      /**
       * Set the summary. Used when listed as subcommand of parent.
       *
       * @param {string} [str]
       * @return {(string|Command)}
       */
      summary(str) {
        if (str === void 0)
          return this._summary;
        this._summary = str;
        return this;
      }
      /**
       * Set an alias for the command.
       *
       * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
       *
       * @param {string} [alias]
       * @return {(string|Command)}
       */
      alias(alias) {
        if (alias === void 0)
          return this._aliases[0];
        let command = this;
        if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
          command = this.commands[this.commands.length - 1];
        }
        if (alias === command._name)
          throw new Error("Command alias can't be the same as its name");
        const matchingCommand = this.parent?._findCommand(alias);
        if (matchingCommand) {
          const existingCmd = [matchingCommand.name()].concat(matchingCommand.aliases()).join("|");
          throw new Error(
            `cannot add alias '${alias}' to command '${this.name()}' as already have command '${existingCmd}'`
          );
        }
        command._aliases.push(alias);
        return this;
      }
      /**
       * Set aliases for the command.
       *
       * Only the first alias is shown in the auto-generated help.
       *
       * @param {string[]} [aliases]
       * @return {(string[]|Command)}
       */
      aliases(aliases2) {
        if (aliases2 === void 0)
          return this._aliases;
        aliases2.forEach((alias) => this.alias(alias));
        return this;
      }
      /**
       * Set / get the command usage `str`.
       *
       * @param {string} [str]
       * @return {(string|Command)}
       */
      usage(str) {
        if (str === void 0) {
          if (this._usage)
            return this._usage;
          const args = this.registeredArguments.map((arg) => {
            return humanReadableArgName(arg);
          });
          return [].concat(
            this.options.length || this._helpOption !== null ? "[options]" : [],
            this.commands.length ? "[command]" : [],
            this.registeredArguments.length ? args : []
          ).join(" ");
        }
        this._usage = str;
        return this;
      }
      /**
       * Get or set the name of the command.
       *
       * @param {string} [str]
       * @return {(string|Command)}
       */
      name(str) {
        if (str === void 0)
          return this._name;
        this._name = str;
        return this;
      }
      /**
       * Set the name of the command from script filename, such as process.argv[1],
       * or require.main.filename, or __filename.
       *
       * (Used internally and public although not documented in README.)
       *
       * @example
       * program.nameFromFilename(require.main.filename);
       *
       * @param {string} filename
       * @return {Command}
       */
      nameFromFilename(filename) {
        this._name = path6.basename(filename, path6.extname(filename));
        return this;
      }
      /**
       * Get or set the directory for searching for executable subcommands of this command.
       *
       * @example
       * program.executableDir(__dirname);
       * // or
       * program.executableDir('subcommands');
       *
       * @param {string} [path]
       * @return {(string|null|Command)}
       */
      executableDir(path7) {
        if (path7 === void 0)
          return this._executableDir;
        this._executableDir = path7;
        return this;
      }
      /**
       * Return program help documentation.
       *
       * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
       * @return {string}
       */
      helpInformation(contextOptions) {
        const helper = this.createHelp();
        if (helper.helpWidth === void 0) {
          helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
        }
        return helper.formatHelp(this, helper);
      }
      /**
       * @private
       */
      _getHelpContext(contextOptions) {
        contextOptions = contextOptions || {};
        const context = { error: !!contextOptions.error };
        let write;
        if (context.error) {
          write = (arg) => this._outputConfiguration.writeErr(arg);
        } else {
          write = (arg) => this._outputConfiguration.writeOut(arg);
        }
        context.write = contextOptions.write || write;
        context.command = this;
        return context;
      }
      /**
       * Output help information for this command.
       *
       * Outputs built-in help, and custom text added using `.addHelpText()`.
       *
       * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
       */
      outputHelp(contextOptions) {
        let deprecatedCallback;
        if (typeof contextOptions === "function") {
          deprecatedCallback = contextOptions;
          contextOptions = void 0;
        }
        const context = this._getHelpContext(contextOptions);
        this._getCommandAndAncestors().reverse().forEach((command) => command.emit("beforeAllHelp", context));
        this.emit("beforeHelp", context);
        let helpInformation = this.helpInformation(context);
        if (deprecatedCallback) {
          helpInformation = deprecatedCallback(helpInformation);
          if (typeof helpInformation !== "string" && !Buffer.isBuffer(helpInformation)) {
            throw new Error("outputHelp callback must return a string or a Buffer");
          }
        }
        context.write(helpInformation);
        if (this._getHelpOption()?.long) {
          this.emit(this._getHelpOption().long);
        }
        this.emit("afterHelp", context);
        this._getCommandAndAncestors().forEach(
          (command) => command.emit("afterAllHelp", context)
        );
      }
      /**
       * You can pass in flags and a description to customise the built-in help option.
       * Pass in false to disable the built-in help option.
       *
       * @example
       * program.helpOption('-?, --help' 'show help'); // customise
       * program.helpOption(false); // disable
       *
       * @param {(string | boolean)} flags
       * @param {string} [description]
       * @return {Command} `this` command for chaining
       */
      helpOption(flags, description) {
        if (typeof flags === "boolean") {
          if (flags) {
            this._helpOption = this._helpOption ?? void 0;
          } else {
            this._helpOption = null;
          }
          return this;
        }
        flags = flags ?? "-h, --help";
        description = description ?? "display help for command";
        this._helpOption = this.createOption(flags, description);
        return this;
      }
      /**
       * Lazy create help option.
       * Returns null if has been disabled with .helpOption(false).
       *
       * @returns {(Option | null)} the help option
       * @package
       */
      _getHelpOption() {
        if (this._helpOption === void 0) {
          this.helpOption(void 0, void 0);
        }
        return this._helpOption;
      }
      /**
       * Supply your own option to use for the built-in help option.
       * This is an alternative to using helpOption() to customise the flags and description etc.
       *
       * @param {Option} option
       * @return {Command} `this` command for chaining
       */
      addHelpOption(option) {
        this._helpOption = option;
        return this;
      }
      /**
       * Output help information and exit.
       *
       * Outputs built-in help, and custom text added using `.addHelpText()`.
       *
       * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
       */
      help(contextOptions) {
        this.outputHelp(contextOptions);
        let exitCode = process9.exitCode || 0;
        if (exitCode === 0 && contextOptions && typeof contextOptions !== "function" && contextOptions.error) {
          exitCode = 1;
        }
        this._exit(exitCode, "commander.help", "(outputHelp)");
      }
      /**
       * Add additional text to be displayed with the built-in help.
       *
       * Position is 'before' or 'after' to affect just this command,
       * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
       *
       * @param {string} position - before or after built-in help
       * @param {(string | Function)} text - string to add, or a function returning a string
       * @return {Command} `this` command for chaining
       */
      addHelpText(position, text) {
        const allowedValues = ["beforeAll", "before", "after", "afterAll"];
        if (!allowedValues.includes(position)) {
          throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        const helpEvent = `${position}Help`;
        this.on(helpEvent, (context) => {
          let helpStr;
          if (typeof text === "function") {
            helpStr = text({ error: context.error, command: context.command });
          } else {
            helpStr = text;
          }
          if (helpStr) {
            context.write(`${helpStr}
`);
          }
        });
        return this;
      }
      /**
       * Output help information if help flags specified
       *
       * @param {Array} args - array of options to search for help flags
       * @private
       */
      _outputHelpIfRequested(args) {
        const helpOption = this._getHelpOption();
        const helpRequested = helpOption && args.find((arg) => helpOption.is(arg));
        if (helpRequested) {
          this.outputHelp();
          this._exit(0, "commander.helpDisplayed", "(outputHelp)");
        }
      }
    };
    function incrementNodeInspectorPort(args) {
      return args.map((arg) => {
        if (!arg.startsWith("--inspect")) {
          return arg;
        }
        let debugOption;
        let debugHost = "127.0.0.1";
        let debugPort = "9229";
        let match;
        if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
          debugOption = match[1];
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
          debugOption = match[1];
          if (/^\d+$/.test(match[3])) {
            debugPort = match[3];
          } else {
            debugHost = match[3];
          }
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
          debugOption = match[1];
          debugHost = match[3];
          debugPort = match[4];
        }
        if (debugOption && debugPort !== "0") {
          return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
        }
        return arg;
      });
    }
    exports.Command = Command2;
  }
});

// node_modules/commander/index.js
var require_commander = __commonJS({
  "node_modules/commander/index.js"(exports) {
    var { Argument: Argument2 } = require_argument();
    var { Command: Command2 } = require_command();
    var { CommanderError: CommanderError2, InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var { Help: Help2 } = require_help();
    var { Option: Option2 } = require_option();
    exports.program = new Command2();
    exports.createCommand = (name) => new Command2(name);
    exports.createOption = (flags, description) => new Option2(flags, description);
    exports.createArgument = (name, description) => new Argument2(name, description);
    exports.Command = Command2;
    exports.Option = Option2;
    exports.Argument = Argument2;
    exports.Help = Help2;
    exports.CommanderError = CommanderError2;
    exports.InvalidArgumentError = InvalidArgumentError2;
    exports.InvalidOptionArgumentError = InvalidArgumentError2;
  }
});

// node_modules/tar/lib/high-level-opt.js
var require_high_level_opt = __commonJS({
  "node_modules/tar/lib/high-level-opt.js"(exports, module2) {
    "use strict";
    var argmap = /* @__PURE__ */ new Map([
      ["C", "cwd"],
      ["f", "file"],
      ["z", "gzip"],
      ["P", "preservePaths"],
      ["U", "unlink"],
      ["strip-components", "strip"],
      ["stripComponents", "strip"],
      ["keep-newer", "newer"],
      ["keepNewer", "newer"],
      ["keep-newer-files", "newer"],
      ["keepNewerFiles", "newer"],
      ["k", "keep"],
      ["keep-existing", "keep"],
      ["keepExisting", "keep"],
      ["m", "noMtime"],
      ["no-mtime", "noMtime"],
      ["p", "preserveOwner"],
      ["L", "follow"],
      ["h", "follow"]
    ]);
    module2.exports = (opt) => opt ? Object.keys(opt).map((k) => [
      argmap.has(k) ? argmap.get(k) : k,
      opt[k]
    ]).reduce((set, kv) => (set[kv[0]] = kv[1], set), /* @__PURE__ */ Object.create(null)) : {};
  }
});

// node_modules/minipass/index.js
var require_minipass = __commonJS({
  "node_modules/minipass/index.js"(exports) {
    "use strict";
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var EE = require("events");
    var Stream = require("stream");
    var stringdecoder = require("string_decoder");
    var SD = stringdecoder.StringDecoder;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFER = Symbol("buffer");
    var PIPES = Symbol("pipes");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var ERROR = Symbol("error");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var ABORT = Symbol("abort");
    var ABORTED = Symbol("aborted");
    var SIGNAL = Symbol("signal");
    var defer = (fn) => Promise.resolve().then(fn);
    var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
    var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
    var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    var Pipe = class {
      constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // istanbul ignore next - only here for the prototype
      proxyErrors() {
      }
      end() {
        this.unpipe();
        if (this.opts.end)
          this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src.on("error", this.proxyErrors);
      }
    };
    var Minipass = class extends Stream {
      constructor(options) {
        super();
        this[FLOWING] = false;
        this[PAUSED] = false;
        this[PIPES] = [];
        this[BUFFER] = [];
        this[OBJECTMODE] = options && options.objectMode || false;
        if (this[OBJECTMODE])
          this[ENCODING] = null;
        else
          this[ENCODING] = options && options.encoding || null;
        if (this[ENCODING] === "buffer")
          this[ENCODING] = null;
        this[ASYNC] = options && !!options.async || false;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this[EMITTED_ERROR] = null;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
        if (options && options.debugExposeBuffer === true) {
          Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
        }
        if (options && options.debugExposePipes === true) {
          Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
        }
        this[SIGNAL] = options && options.signal;
        this[ABORTED] = false;
        if (this[SIGNAL]) {
          this[SIGNAL].addEventListener("abort", () => this[ABORT]());
          if (this[SIGNAL].aborted) {
            this[ABORT]();
          }
        }
      }
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      get encoding() {
        return this[ENCODING];
      }
      set encoding(enc) {
        if (this[OBJECTMODE])
          throw new Error("cannot set encoding in objectMode");
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
          throw new Error("cannot change encoding");
        if (this[ENCODING] !== enc) {
          this[DECODER] = enc ? new SD(enc) : null;
          if (this[BUFFER].length)
            this[BUFFER] = this[BUFFER].map((chunk) => this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
      }
      setEncoding(enc) {
        this.encoding = enc;
      }
      get objectMode() {
        return this[OBJECTMODE];
      }
      set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
      }
      get ["async"]() {
        return this[ASYNC];
      }
      set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
      }
      // drop everything and get out of the flow completely
      [ABORT]() {
        this[ABORTED] = true;
        this.emit("abort", this[SIGNAL].reason);
        this.destroy(this[SIGNAL].reason);
      }
      get aborted() {
        return this[ABORTED];
      }
      set aborted(_) {
      }
      write(chunk, encoding, cb) {
        if (this[ABORTED])
          return false;
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit(
            "error",
            Object.assign(
              new Error("Cannot call write after a stream was destroyed"),
              { code: "ERR_STREAM_DESTROYED" }
            )
          );
          return true;
        }
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (!encoding)
          encoding = "utf8";
        const fn = this[ASYNC] ? defer : (f) => f();
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBuffer(chunk))
            chunk = Buffer.from(chunk);
          else if (typeof chunk !== "string")
            this.objectMode = true;
        }
        if (this[OBJECTMODE]) {
          if (this.flowing && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          if (this.flowing)
            this.emit("data", chunk);
          else
            this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING])
          chunk = this[DECODER].write(chunk);
        if (this.flowing && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this.flowing)
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      read(n) {
        if (this[DESTROYED])
          return null;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE])
          n = null;
        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
          if (this.encoding)
            this[BUFFER] = [this[BUFFER].join("")];
          else
            this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])];
        }
        const ret = this[READ](n || null, this[BUFFER][0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (n === chunk.length || n === null)
          this[BUFFERSHIFT]();
        else {
          this[BUFFER][0] = chunk.slice(n);
          chunk = chunk.slice(0, n);
          this[BUFFERLENGTH] -= n;
        }
        this.emit("data", chunk);
        if (!this[BUFFER].length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function")
          cb = chunk, chunk = null;
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (chunk)
          this.write(chunk, encoding);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this.flowing || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED])
          return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this[BUFFER].length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      resume() {
        return this[RESUME]();
      }
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
      }
      get destroyed() {
        return this[DESTROYED];
      }
      get flowing() {
        return this[FLOWING];
      }
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        this[BUFFER].push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] -= 1;
        else
          this[BUFFERLENGTH] -= this[BUFFER][0].length;
        return this[BUFFER].shift();
      }
      [FLUSH](noDrain) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
        if (!noDrain && !this[BUFFER].length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        this.emit("data", chunk);
        return this.flowing;
      }
      pipe(dest, opts) {
        if (this[DESTROYED])
          return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end)
            dest.end();
        } else {
          this[PIPES].push(
            !opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts)
          );
          if (this[ASYNC])
            defer(() => this[RESUME]());
          else
            this[RESUME]();
        }
        return dest;
      }
      unpipe(dest) {
        const p = this[PIPES].find((p2) => p2.dest === dest);
        if (p) {
          this[PIPES].splice(this[PIPES].indexOf(p), 1);
          p.unpipe();
        }
      }
      addListener(ev, fn) {
        return this.on(ev, fn);
      }
      on(ev, fn) {
        const ret = super.on(ev, fn);
        if (ev === "data" && !this[PIPES].length && !this.flowing)
          this[RESUME]();
        else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
          super.emit("readable");
        else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          if (this[ASYNC])
            defer(() => fn.call(this, this[EMITTED_ERROR]));
          else
            fn.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      emit(ev, data, ...extra) {
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
          return;
        else if (ev === "data") {
          return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          super.emit(ERROR, data);
          const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, data, ...extra);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p of this[PIPES]) {
          if (p.dest.write(data) === false)
            this.pause();
        }
        const ret = super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END])
          return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[ASYNC])
          defer(() => this[EMITEND2]());
        else
          this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p of this[PIPES]) {
              p.dest.write(data);
            }
            super.emit("data", data);
          }
        }
        for (const p of this[PIPES]) {
          p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      // const all = await stream.collect()
      collect() {
        const buf = [];
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        return p.then(() => buf);
      }
      // const data = await stream.concat()
      concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then(
          (buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength)
        );
      }
      // stream.promise().then(() => done, er => emitted error)
      promise() {
        return new Promise((resolve2, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve2());
        });
      }
      // for await (let chunk of stream)
      [ASYNCITERATOR]() {
        let stopped = false;
        const stop = () => {
          this.pause();
          stopped = true;
          return Promise.resolve({ done: true });
        };
        const next = () => {
          if (stopped)
            return stop();
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return stop();
          let resolve2 = null;
          let reject = null;
          const onerr = (er) => {
            this.removeListener("data", ondata);
            this.removeListener("end", onend);
            this.removeListener(DESTROYED, ondestroy);
            stop();
            reject(er);
          };
          const ondata = (value) => {
            this.removeListener("error", onerr);
            this.removeListener("end", onend);
            this.removeListener(DESTROYED, ondestroy);
            this.pause();
            resolve2({ value, done: !!this[EOF] });
          };
          const onend = () => {
            this.removeListener("error", onerr);
            this.removeListener("data", ondata);
            this.removeListener(DESTROYED, ondestroy);
            stop();
            resolve2({ done: true });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve2 = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return {
          next,
          throw: stop,
          return: stop,
          [ASYNCITERATOR]() {
            return this;
          }
        };
      }
      // for (let chunk of stream)
      [ITERATOR]() {
        let stopped = false;
        const stop = () => {
          this.pause();
          this.removeListener(ERROR, stop);
          this.removeListener(DESTROYED, stop);
          this.removeListener("end", stop);
          stopped = true;
          return { done: true };
        };
        const next = () => {
          if (stopped)
            return stop();
          const value = this.read();
          return value === null ? stop() : { value };
        };
        this.once("end", stop);
        this.once(ERROR, stop);
        this.once(DESTROYED, stop);
        return {
          next,
          throw: stop,
          return: stop,
          [ITERATOR]() {
            return this;
          }
        };
      }
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this[BUFFER].length = 0;
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === "function" && !this[CLOSED])
          this.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      static isStream(s) {
        return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && // readable
        (typeof s.pipe === "function" || // writable
        typeof s.write === "function" && typeof s.end === "function"));
      }
    };
    exports.Minipass = Minipass;
  }
});

// node_modules/minizlib/constants.js
var require_constants = __commonJS({
  "node_modules/minizlib/constants.js"(exports, module2) {
    var realZlibConstants = require("zlib").constants || /* istanbul ignore next */
    { ZLIB_VERNUM: 4736 };
    module2.exports = Object.freeze(Object.assign(/* @__PURE__ */ Object.create(null), {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      Z_VERSION_ERROR: -6,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      DEFLATE: 1,
      INFLATE: 2,
      GZIP: 3,
      GUNZIP: 4,
      DEFLATERAW: 5,
      INFLATERAW: 6,
      UNZIP: 7,
      BROTLI_DECODE: 8,
      BROTLI_ENCODE: 9,
      Z_MIN_WINDOWBITS: 8,
      Z_MAX_WINDOWBITS: 15,
      Z_DEFAULT_WINDOWBITS: 15,
      Z_MIN_CHUNK: 64,
      Z_MAX_CHUNK: Infinity,
      Z_DEFAULT_CHUNK: 16384,
      Z_MIN_MEMLEVEL: 1,
      Z_MAX_MEMLEVEL: 9,
      Z_DEFAULT_MEMLEVEL: 8,
      Z_MIN_LEVEL: -1,
      Z_MAX_LEVEL: 9,
      Z_DEFAULT_LEVEL: -1,
      BROTLI_OPERATION_PROCESS: 0,
      BROTLI_OPERATION_FLUSH: 1,
      BROTLI_OPERATION_FINISH: 2,
      BROTLI_OPERATION_EMIT_METADATA: 3,
      BROTLI_MODE_GENERIC: 0,
      BROTLI_MODE_TEXT: 1,
      BROTLI_MODE_FONT: 2,
      BROTLI_DEFAULT_MODE: 0,
      BROTLI_MIN_QUALITY: 0,
      BROTLI_MAX_QUALITY: 11,
      BROTLI_DEFAULT_QUALITY: 11,
      BROTLI_MIN_WINDOW_BITS: 10,
      BROTLI_MAX_WINDOW_BITS: 24,
      BROTLI_LARGE_MAX_WINDOW_BITS: 30,
      BROTLI_DEFAULT_WINDOW: 22,
      BROTLI_MIN_INPUT_BLOCK_BITS: 16,
      BROTLI_MAX_INPUT_BLOCK_BITS: 24,
      BROTLI_PARAM_MODE: 0,
      BROTLI_PARAM_QUALITY: 1,
      BROTLI_PARAM_LGWIN: 2,
      BROTLI_PARAM_LGBLOCK: 3,
      BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
      BROTLI_PARAM_SIZE_HINT: 5,
      BROTLI_PARAM_LARGE_WINDOW: 6,
      BROTLI_PARAM_NPOSTFIX: 7,
      BROTLI_PARAM_NDIRECT: 8,
      BROTLI_DECODER_RESULT_ERROR: 0,
      BROTLI_DECODER_RESULT_SUCCESS: 1,
      BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
      BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
      BROTLI_DECODER_NO_ERROR: 0,
      BROTLI_DECODER_SUCCESS: 1,
      BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
      BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
      BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
      BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
      BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
      BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
      BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
      BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
      BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
      BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
      BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
      BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
      BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
      BROTLI_DECODER_ERROR_UNREACHABLE: -31
    }, realZlibConstants));
  }
});

// node_modules/minizlib/node_modules/minipass/index.js
var require_minipass2 = __commonJS({
  "node_modules/minizlib/node_modules/minipass/index.js"(exports, module2) {
    "use strict";
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var EE = require("events");
    var Stream = require("stream");
    var SD = require("string_decoder").StringDecoder;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var defer = (fn) => Promise.resolve().then(fn);
    var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
    var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
    var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    var Pipe = class {
      constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // istanbul ignore next - only here for the prototype
      proxyErrors() {
      }
      end() {
        this.unpipe();
        if (this.opts.end)
          this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src.on("error", this.proxyErrors);
      }
    };
    module2.exports = class Minipass extends Stream {
      constructor(options) {
        super();
        this[FLOWING] = false;
        this[PAUSED] = false;
        this.pipes = [];
        this.buffer = [];
        this[OBJECTMODE] = options && options.objectMode || false;
        if (this[OBJECTMODE])
          this[ENCODING] = null;
        else
          this[ENCODING] = options && options.encoding || null;
        if (this[ENCODING] === "buffer")
          this[ENCODING] = null;
        this[ASYNC] = options && !!options.async || false;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this[EMITTED_ERROR] = null;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
      }
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      get encoding() {
        return this[ENCODING];
      }
      set encoding(enc) {
        if (this[OBJECTMODE])
          throw new Error("cannot set encoding in objectMode");
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
          throw new Error("cannot change encoding");
        if (this[ENCODING] !== enc) {
          this[DECODER] = enc ? new SD(enc) : null;
          if (this.buffer.length)
            this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
      }
      setEncoding(enc) {
        this.encoding = enc;
      }
      get objectMode() {
        return this[OBJECTMODE];
      }
      set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
      }
      get ["async"]() {
        return this[ASYNC];
      }
      set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
      }
      write(chunk, encoding, cb) {
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(
            new Error("Cannot call write after a stream was destroyed"),
            { code: "ERR_STREAM_DESTROYED" }
          ));
          return true;
        }
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (!encoding)
          encoding = "utf8";
        const fn = this[ASYNC] ? defer : (f) => f();
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBuffer(chunk))
            chunk = Buffer.from(chunk);
          else if (typeof chunk !== "string")
            this.objectMode = true;
        }
        if (this[OBJECTMODE]) {
          if (this.flowing && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          if (this.flowing)
            this.emit("data", chunk);
          else
            this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING])
          chunk = this[DECODER].write(chunk);
        if (this.flowing && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this.flowing)
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      read(n) {
        if (this[DESTROYED])
          return null;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE])
          n = null;
        if (this.buffer.length > 1 && !this[OBJECTMODE]) {
          if (this.encoding)
            this.buffer = [this.buffer.join("")];
          else
            this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
        }
        const ret = this[READ](n || null, this.buffer[0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (n === chunk.length || n === null)
          this[BUFFERSHIFT]();
        else {
          this.buffer[0] = chunk.slice(n);
          chunk = chunk.slice(0, n);
          this[BUFFERLENGTH] -= n;
        }
        this.emit("data", chunk);
        if (!this.buffer.length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function")
          cb = chunk, chunk = null;
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (chunk)
          this.write(chunk, encoding);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this.flowing || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED])
          return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this.buffer.length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      resume() {
        return this[RESUME]();
      }
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
      }
      get destroyed() {
        return this[DESTROYED];
      }
      get flowing() {
        return this[FLOWING];
      }
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        this.buffer.push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this.buffer.length) {
          if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
          else
            this[BUFFERLENGTH] -= this.buffer[0].length;
        }
        return this.buffer.shift();
      }
      [FLUSH](noDrain) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
        if (!noDrain && !this.buffer.length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        return chunk ? (this.emit("data", chunk), this.flowing) : false;
      }
      pipe(dest, opts) {
        if (this[DESTROYED])
          return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end)
            dest.end();
        } else {
          this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
          if (this[ASYNC])
            defer(() => this[RESUME]());
          else
            this[RESUME]();
        }
        return dest;
      }
      unpipe(dest) {
        const p = this.pipes.find((p2) => p2.dest === dest);
        if (p) {
          this.pipes.splice(this.pipes.indexOf(p), 1);
          p.unpipe();
        }
      }
      addListener(ev, fn) {
        return this.on(ev, fn);
      }
      on(ev, fn) {
        const ret = super.on(ev, fn);
        if (ev === "data" && !this.pipes.length && !this.flowing)
          this[RESUME]();
        else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
          super.emit("readable");
        else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          if (this[ASYNC])
            defer(() => fn.call(this, this[EMITTED_ERROR]));
          else
            fn.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      emit(ev, data, ...extra) {
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
          return;
        else if (ev === "data") {
          return !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          const ret2 = super.emit("error", data);
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, data, ...extra);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p of this.pipes) {
          if (p.dest.write(data) === false)
            this.pause();
        }
        const ret = super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END])
          return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[ASYNC])
          defer(() => this[EMITEND2]());
        else
          this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p of this.pipes) {
              p.dest.write(data);
            }
            super.emit("data", data);
          }
        }
        for (const p of this.pipes) {
          p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      // const all = await stream.collect()
      collect() {
        const buf = [];
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        return p.then(() => buf);
      }
      // const data = await stream.concat()
      concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
      }
      // stream.promise().then(() => done, er => emitted error)
      promise() {
        return new Promise((resolve2, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve2());
        });
      }
      // for await (let chunk of stream)
      [ASYNCITERATOR]() {
        const next = () => {
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return Promise.resolve({ done: true });
          let resolve2 = null;
          let reject = null;
          const onerr = (er) => {
            this.removeListener("data", ondata);
            this.removeListener("end", onend);
            reject(er);
          };
          const ondata = (value) => {
            this.removeListener("error", onerr);
            this.removeListener("end", onend);
            this.pause();
            resolve2({ value, done: !!this[EOF] });
          };
          const onend = () => {
            this.removeListener("error", onerr);
            this.removeListener("data", ondata);
            resolve2({ done: true });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve2 = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return { next };
      }
      // for (let chunk of stream)
      [ITERATOR]() {
        const next = () => {
          const value = this.read();
          const done = value === null;
          return { value, done };
        };
        return { next };
      }
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this.buffer.length = 0;
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === "function" && !this[CLOSED])
          this.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      static isStream(s) {
        return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === "function" || // readable
        typeof s.write === "function" && typeof s.end === "function"));
      }
    };
  }
});

// node_modules/minizlib/index.js
var require_minizlib = __commonJS({
  "node_modules/minizlib/index.js"(exports) {
    "use strict";
    var assert = require("assert");
    var Buffer4 = require("buffer").Buffer;
    var realZlib = require("zlib");
    var constants3 = exports.constants = require_constants();
    var Minipass = require_minipass2();
    var OriginalBufferConcat = Buffer4.concat;
    var _superWrite = Symbol("_superWrite");
    var ZlibError = class extends Error {
      constructor(err) {
        super("zlib: " + err.message);
        this.code = err.code;
        this.errno = err.errno;
        if (!this.code)
          this.code = "ZLIB_ERROR";
        this.message = "zlib: " + err.message;
        Error.captureStackTrace(this, this.constructor);
      }
      get name() {
        return "ZlibError";
      }
    };
    var _opts = Symbol("opts");
    var _flushFlag = Symbol("flushFlag");
    var _finishFlushFlag = Symbol("finishFlushFlag");
    var _fullFlushFlag = Symbol("fullFlushFlag");
    var _handle = Symbol("handle");
    var _onError = Symbol("onError");
    var _sawError = Symbol("sawError");
    var _level = Symbol("level");
    var _strategy = Symbol("strategy");
    var _ended = Symbol("ended");
    var _defaultFullFlush = Symbol("_defaultFullFlush");
    var ZlibBase = class extends Minipass {
      constructor(opts, mode) {
        if (!opts || typeof opts !== "object")
          throw new TypeError("invalid options for ZlibBase constructor");
        super(opts);
        this[_sawError] = false;
        this[_ended] = false;
        this[_opts] = opts;
        this[_flushFlag] = opts.flush;
        this[_finishFlushFlag] = opts.finishFlush;
        try {
          this[_handle] = new realZlib[mode](opts);
        } catch (er) {
          throw new ZlibError(er);
        }
        this[_onError] = (err) => {
          if (this[_sawError])
            return;
          this[_sawError] = true;
          this.close();
          this.emit("error", err);
        };
        this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
        this.once("end", () => this.close);
      }
      close() {
        if (this[_handle]) {
          this[_handle].close();
          this[_handle] = null;
          this.emit("close");
        }
      }
      reset() {
        if (!this[_sawError]) {
          assert(this[_handle], "zlib binding closed");
          return this[_handle].reset();
        }
      }
      flush(flushFlag) {
        if (this.ended)
          return;
        if (typeof flushFlag !== "number")
          flushFlag = this[_fullFlushFlag];
        this.write(Object.assign(Buffer4.alloc(0), { [_flushFlag]: flushFlag }));
      }
      end(chunk, encoding, cb) {
        if (chunk)
          this.write(chunk, encoding);
        this.flush(this[_finishFlushFlag]);
        this[_ended] = true;
        return super.end(null, null, cb);
      }
      get ended() {
        return this[_ended];
      }
      write(chunk, encoding, cb) {
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (typeof chunk === "string")
          chunk = Buffer4.from(chunk, encoding);
        if (this[_sawError])
          return;
        assert(this[_handle], "zlib binding closed");
        const nativeHandle = this[_handle]._handle;
        const originalNativeClose = nativeHandle.close;
        nativeHandle.close = () => {
        };
        const originalClose = this[_handle].close;
        this[_handle].close = () => {
        };
        Buffer4.concat = (args) => args;
        let result;
        try {
          const flushFlag = typeof chunk[_flushFlag] === "number" ? chunk[_flushFlag] : this[_flushFlag];
          result = this[_handle]._processChunk(chunk, flushFlag);
          Buffer4.concat = OriginalBufferConcat;
        } catch (err) {
          Buffer4.concat = OriginalBufferConcat;
          this[_onError](new ZlibError(err));
        } finally {
          if (this[_handle]) {
            this[_handle]._handle = nativeHandle;
            nativeHandle.close = originalNativeClose;
            this[_handle].close = originalClose;
            this[_handle].removeAllListeners("error");
          }
        }
        if (this[_handle])
          this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
        let writeReturn;
        if (result) {
          if (Array.isArray(result) && result.length > 0) {
            writeReturn = this[_superWrite](Buffer4.from(result[0]));
            for (let i = 1; i < result.length; i++) {
              writeReturn = this[_superWrite](result[i]);
            }
          } else {
            writeReturn = this[_superWrite](Buffer4.from(result));
          }
        }
        if (cb)
          cb();
        return writeReturn;
      }
      [_superWrite](data) {
        return super.write(data);
      }
    };
    var Zlib = class extends ZlibBase {
      constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants3.Z_NO_FLUSH;
        opts.finishFlush = opts.finishFlush || constants3.Z_FINISH;
        super(opts, mode);
        this[_fullFlushFlag] = constants3.Z_FULL_FLUSH;
        this[_level] = opts.level;
        this[_strategy] = opts.strategy;
      }
      params(level, strategy) {
        if (this[_sawError])
          return;
        if (!this[_handle])
          throw new Error("cannot switch params when binding is closed");
        if (!this[_handle].params)
          throw new Error("not supported in this implementation");
        if (this[_level] !== level || this[_strategy] !== strategy) {
          this.flush(constants3.Z_SYNC_FLUSH);
          assert(this[_handle], "zlib binding closed");
          const origFlush = this[_handle].flush;
          this[_handle].flush = (flushFlag, cb) => {
            this.flush(flushFlag);
            cb();
          };
          try {
            this[_handle].params(level, strategy);
          } finally {
            this[_handle].flush = origFlush;
          }
          if (this[_handle]) {
            this[_level] = level;
            this[_strategy] = strategy;
          }
        }
      }
    };
    var Deflate = class extends Zlib {
      constructor(opts) {
        super(opts, "Deflate");
      }
    };
    var Inflate = class extends Zlib {
      constructor(opts) {
        super(opts, "Inflate");
      }
    };
    var _portable = Symbol("_portable");
    var Gzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Gzip");
        this[_portable] = opts && !!opts.portable;
      }
      [_superWrite](data) {
        if (!this[_portable])
          return super[_superWrite](data);
        this[_portable] = false;
        data[9] = 255;
        return super[_superWrite](data);
      }
    };
    var Gunzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Gunzip");
      }
    };
    var DeflateRaw = class extends Zlib {
      constructor(opts) {
        super(opts, "DeflateRaw");
      }
    };
    var InflateRaw = class extends Zlib {
      constructor(opts) {
        super(opts, "InflateRaw");
      }
    };
    var Unzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Unzip");
      }
    };
    var Brotli = class extends ZlibBase {
      constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants3.BROTLI_OPERATION_PROCESS;
        opts.finishFlush = opts.finishFlush || constants3.BROTLI_OPERATION_FINISH;
        super(opts, mode);
        this[_fullFlushFlag] = constants3.BROTLI_OPERATION_FLUSH;
      }
    };
    var BrotliCompress = class extends Brotli {
      constructor(opts) {
        super(opts, "BrotliCompress");
      }
    };
    var BrotliDecompress = class extends Brotli {
      constructor(opts) {
        super(opts, "BrotliDecompress");
      }
    };
    exports.Deflate = Deflate;
    exports.Inflate = Inflate;
    exports.Gzip = Gzip;
    exports.Gunzip = Gunzip;
    exports.DeflateRaw = DeflateRaw;
    exports.InflateRaw = InflateRaw;
    exports.Unzip = Unzip;
    if (typeof realZlib.BrotliCompress === "function") {
      exports.BrotliCompress = BrotliCompress;
      exports.BrotliDecompress = BrotliDecompress;
    } else {
      exports.BrotliCompress = exports.BrotliDecompress = class {
        constructor() {
          throw new Error("Brotli is not supported in this version of Node.js");
        }
      };
    }
  }
});

// node_modules/tar/lib/normalize-windows-path.js
var require_normalize_windows_path = __commonJS({
  "node_modules/tar/lib/normalize-windows-path.js"(exports, module2) {
    var platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    module2.exports = platform !== "win32" ? (p) => p : (p) => p && p.replace(/\\/g, "/");
  }
});

// node_modules/tar/lib/read-entry.js
var require_read_entry = __commonJS({
  "node_modules/tar/lib/read-entry.js"(exports, module2) {
    "use strict";
    var { Minipass } = require_minipass();
    var normPath = require_normalize_windows_path();
    var SLURP = Symbol("slurp");
    module2.exports = class ReadEntry extends Minipass {
      constructor(header, ex, gex) {
        super();
        this.pause();
        this.extended = ex;
        this.globalExtended = gex;
        this.header = header;
        this.startBlockSize = 512 * Math.ceil(header.size / 512);
        this.blockRemain = this.startBlockSize;
        this.remain = header.size;
        this.type = header.type;
        this.meta = false;
        this.ignore = false;
        switch (this.type) {
          case "File":
          case "OldFile":
          case "Link":
          case "SymbolicLink":
          case "CharacterDevice":
          case "BlockDevice":
          case "Directory":
          case "FIFO":
          case "ContiguousFile":
          case "GNUDumpDir":
            break;
          case "NextFileHasLongLinkpath":
          case "NextFileHasLongPath":
          case "OldGnuLongPath":
          case "GlobalExtendedHeader":
          case "ExtendedHeader":
          case "OldExtendedHeader":
            this.meta = true;
            break;
          default:
            this.ignore = true;
        }
        this.path = normPath(header.path);
        this.mode = header.mode;
        if (this.mode) {
          this.mode = this.mode & 4095;
        }
        this.uid = header.uid;
        this.gid = header.gid;
        this.uname = header.uname;
        this.gname = header.gname;
        this.size = header.size;
        this.mtime = header.mtime;
        this.atime = header.atime;
        this.ctime = header.ctime;
        this.linkpath = normPath(header.linkpath);
        this.uname = header.uname;
        this.gname = header.gname;
        if (ex) {
          this[SLURP](ex);
        }
        if (gex) {
          this[SLURP](gex, true);
        }
      }
      write(data) {
        const writeLen = data.length;
        if (writeLen > this.blockRemain) {
          throw new Error("writing more to entry than is appropriate");
        }
        const r = this.remain;
        const br = this.blockRemain;
        this.remain = Math.max(0, r - writeLen);
        this.blockRemain = Math.max(0, br - writeLen);
        if (this.ignore) {
          return true;
        }
        if (r >= writeLen) {
          return super.write(data);
        }
        return super.write(data.slice(0, r));
      }
      [SLURP](ex, global3) {
        for (const k in ex) {
          if (ex[k] !== null && ex[k] !== void 0 && !(global3 && k === "path")) {
            this[k] = k === "path" || k === "linkpath" ? normPath(ex[k]) : ex[k];
          }
        }
      }
    };
  }
});

// node_modules/tar/lib/types.js
var require_types = __commonJS({
  "node_modules/tar/lib/types.js"(exports) {
    "use strict";
    exports.name = /* @__PURE__ */ new Map([
      ["0", "File"],
      // same as File
      ["", "OldFile"],
      ["1", "Link"],
      ["2", "SymbolicLink"],
      // Devices and FIFOs aren't fully supported
      // they are parsed, but skipped when unpacking
      ["3", "CharacterDevice"],
      ["4", "BlockDevice"],
      ["5", "Directory"],
      ["6", "FIFO"],
      // same as File
      ["7", "ContiguousFile"],
      // pax headers
      ["g", "GlobalExtendedHeader"],
      ["x", "ExtendedHeader"],
      // vendor-specific stuff
      // skip
      ["A", "SolarisACL"],
      // like 5, but with data, which should be skipped
      ["D", "GNUDumpDir"],
      // metadata only, skip
      ["I", "Inode"],
      // data = link path of next file
      ["K", "NextFileHasLongLinkpath"],
      // data = path of next file
      ["L", "NextFileHasLongPath"],
      // skip
      ["M", "ContinuationFile"],
      // like L
      ["N", "OldGnuLongPath"],
      // skip
      ["S", "SparseFile"],
      // skip
      ["V", "TapeVolumeHeader"],
      // like x
      ["X", "OldExtendedHeader"]
    ]);
    exports.code = new Map(Array.from(exports.name).map((kv) => [kv[1], kv[0]]));
  }
});

// node_modules/tar/lib/large-numbers.js
var require_large_numbers = __commonJS({
  "node_modules/tar/lib/large-numbers.js"(exports, module2) {
    "use strict";
    var encode = (num, buf) => {
      if (!Number.isSafeInteger(num)) {
        throw Error("cannot encode number outside of javascript safe integer range");
      } else if (num < 0) {
        encodeNegative(num, buf);
      } else {
        encodePositive(num, buf);
      }
      return buf;
    };
    var encodePositive = (num, buf) => {
      buf[0] = 128;
      for (var i = buf.length; i > 1; i--) {
        buf[i - 1] = num & 255;
        num = Math.floor(num / 256);
      }
    };
    var encodeNegative = (num, buf) => {
      buf[0] = 255;
      var flipped = false;
      num = num * -1;
      for (var i = buf.length; i > 1; i--) {
        var byte = num & 255;
        num = Math.floor(num / 256);
        if (flipped) {
          buf[i - 1] = onesComp(byte);
        } else if (byte === 0) {
          buf[i - 1] = 0;
        } else {
          flipped = true;
          buf[i - 1] = twosComp(byte);
        }
      }
    };
    var parse2 = (buf) => {
      const pre = buf[0];
      const value = pre === 128 ? pos(buf.slice(1, buf.length)) : pre === 255 ? twos(buf) : null;
      if (value === null) {
        throw Error("invalid base256 encoding");
      }
      if (!Number.isSafeInteger(value)) {
        throw Error("parsed number outside of javascript safe integer range");
      }
      return value;
    };
    var twos = (buf) => {
      var len = buf.length;
      var sum = 0;
      var flipped = false;
      for (var i = len - 1; i > -1; i--) {
        var byte = buf[i];
        var f;
        if (flipped) {
          f = onesComp(byte);
        } else if (byte === 0) {
          f = byte;
        } else {
          flipped = true;
          f = twosComp(byte);
        }
        if (f !== 0) {
          sum -= f * Math.pow(256, len - i - 1);
        }
      }
      return sum;
    };
    var pos = (buf) => {
      var len = buf.length;
      var sum = 0;
      for (var i = len - 1; i > -1; i--) {
        var byte = buf[i];
        if (byte !== 0) {
          sum += byte * Math.pow(256, len - i - 1);
        }
      }
      return sum;
    };
    var onesComp = (byte) => (255 ^ byte) & 255;
    var twosComp = (byte) => (255 ^ byte) + 1 & 255;
    module2.exports = {
      encode,
      parse: parse2
    };
  }
});

// node_modules/tar/lib/header.js
var require_header = __commonJS({
  "node_modules/tar/lib/header.js"(exports, module2) {
    "use strict";
    var types = require_types();
    var pathModule = require("path").posix;
    var large = require_large_numbers();
    var SLURP = Symbol("slurp");
    var TYPE = Symbol("type");
    var Header = class {
      constructor(data, off, ex, gex) {
        this.cksumValid = false;
        this.needPax = false;
        this.nullBlock = false;
        this.block = null;
        this.path = null;
        this.mode = null;
        this.uid = null;
        this.gid = null;
        this.size = null;
        this.mtime = null;
        this.cksum = null;
        this[TYPE] = "0";
        this.linkpath = null;
        this.uname = null;
        this.gname = null;
        this.devmaj = 0;
        this.devmin = 0;
        this.atime = null;
        this.ctime = null;
        if (Buffer.isBuffer(data)) {
          this.decode(data, off || 0, ex, gex);
        } else if (data) {
          this.set(data);
        }
      }
      decode(buf, off, ex, gex) {
        if (!off) {
          off = 0;
        }
        if (!buf || !(buf.length >= off + 512)) {
          throw new Error("need 512 bytes for header");
        }
        this.path = decString(buf, off, 100);
        this.mode = decNumber(buf, off + 100, 8);
        this.uid = decNumber(buf, off + 108, 8);
        this.gid = decNumber(buf, off + 116, 8);
        this.size = decNumber(buf, off + 124, 12);
        this.mtime = decDate(buf, off + 136, 12);
        this.cksum = decNumber(buf, off + 148, 12);
        this[SLURP](ex);
        this[SLURP](gex, true);
        this[TYPE] = decString(buf, off + 156, 1);
        if (this[TYPE] === "") {
          this[TYPE] = "0";
        }
        if (this[TYPE] === "0" && this.path.slice(-1) === "/") {
          this[TYPE] = "5";
        }
        if (this[TYPE] === "5") {
          this.size = 0;
        }
        this.linkpath = decString(buf, off + 157, 100);
        if (buf.slice(off + 257, off + 265).toString() === "ustar\x0000") {
          this.uname = decString(buf, off + 265, 32);
          this.gname = decString(buf, off + 297, 32);
          this.devmaj = decNumber(buf, off + 329, 8);
          this.devmin = decNumber(buf, off + 337, 8);
          if (buf[off + 475] !== 0) {
            const prefix = decString(buf, off + 345, 155);
            this.path = prefix + "/" + this.path;
          } else {
            const prefix = decString(buf, off + 345, 130);
            if (prefix) {
              this.path = prefix + "/" + this.path;
            }
            this.atime = decDate(buf, off + 476, 12);
            this.ctime = decDate(buf, off + 488, 12);
          }
        }
        let sum = 8 * 32;
        for (let i = off; i < off + 148; i++) {
          sum += buf[i];
        }
        for (let i = off + 156; i < off + 512; i++) {
          sum += buf[i];
        }
        this.cksumValid = sum === this.cksum;
        if (this.cksum === null && sum === 8 * 32) {
          this.nullBlock = true;
        }
      }
      [SLURP](ex, global3) {
        for (const k in ex) {
          if (ex[k] !== null && ex[k] !== void 0 && !(global3 && k === "path")) {
            this[k] = ex[k];
          }
        }
      }
      encode(buf, off) {
        if (!buf) {
          buf = this.block = Buffer.alloc(512);
          off = 0;
        }
        if (!off) {
          off = 0;
        }
        if (!(buf.length >= off + 512)) {
          throw new Error("need 512 bytes for header");
        }
        const prefixSize = this.ctime || this.atime ? 130 : 155;
        const split2 = splitPrefix(this.path || "", prefixSize);
        const path6 = split2[0];
        const prefix = split2[1];
        this.needPax = split2[2];
        this.needPax = encString(buf, off, 100, path6) || this.needPax;
        this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax;
        this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax;
        this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax;
        this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax;
        this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax;
        buf[off + 156] = this[TYPE].charCodeAt(0);
        this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax;
        buf.write("ustar\x0000", off + 257, 8);
        this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax;
        this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax;
        this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;
        this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax;
        this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax;
        if (buf[off + 475] !== 0) {
          this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax;
        } else {
          this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax;
          this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax;
          this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax;
        }
        let sum = 8 * 32;
        for (let i = off; i < off + 148; i++) {
          sum += buf[i];
        }
        for (let i = off + 156; i < off + 512; i++) {
          sum += buf[i];
        }
        this.cksum = sum;
        encNumber(buf, off + 148, 8, this.cksum);
        this.cksumValid = true;
        return this.needPax;
      }
      set(data) {
        for (const i in data) {
          if (data[i] !== null && data[i] !== void 0) {
            this[i] = data[i];
          }
        }
      }
      get type() {
        return types.name.get(this[TYPE]) || this[TYPE];
      }
      get typeKey() {
        return this[TYPE];
      }
      set type(type) {
        if (types.code.has(type)) {
          this[TYPE] = types.code.get(type);
        } else {
          this[TYPE] = type;
        }
      }
    };
    var splitPrefix = (p, prefixSize) => {
      const pathSize = 100;
      let pp = p;
      let prefix = "";
      let ret;
      const root = pathModule.parse(p).root || ".";
      if (Buffer.byteLength(pp) < pathSize) {
        ret = [pp, prefix, false];
      } else {
        prefix = pathModule.dirname(pp);
        pp = pathModule.basename(pp);
        do {
          if (Buffer.byteLength(pp) <= pathSize && Buffer.byteLength(prefix) <= prefixSize) {
            ret = [pp, prefix, false];
          } else if (Buffer.byteLength(pp) > pathSize && Buffer.byteLength(prefix) <= prefixSize) {
            ret = [pp.slice(0, pathSize - 1), prefix, true];
          } else {
            pp = pathModule.join(pathModule.basename(prefix), pp);
            prefix = pathModule.dirname(prefix);
          }
        } while (prefix !== root && !ret);
        if (!ret) {
          ret = [p.slice(0, pathSize - 1), "", true];
        }
      }
      return ret;
    };
    var decString = (buf, off, size) => buf.slice(off, off + size).toString("utf8").replace(/\0.*/, "");
    var decDate = (buf, off, size) => numToDate(decNumber(buf, off, size));
    var numToDate = (num) => num === null ? null : new Date(num * 1e3);
    var decNumber = (buf, off, size) => buf[off] & 128 ? large.parse(buf.slice(off, off + size)) : decSmallNumber(buf, off, size);
    var nanNull = (value) => isNaN(value) ? null : value;
    var decSmallNumber = (buf, off, size) => nanNull(parseInt(
      buf.slice(off, off + size).toString("utf8").replace(/\0.*$/, "").trim(),
      8
    ));
    var MAXNUM = {
      12: 8589934591,
      8: 2097151
    };
    var encNumber = (buf, off, size, number) => number === null ? false : number > MAXNUM[size] || number < 0 ? (large.encode(number, buf.slice(off, off + size)), true) : (encSmallNumber(buf, off, size, number), false);
    var encSmallNumber = (buf, off, size, number) => buf.write(octalString(number, size), off, size, "ascii");
    var octalString = (number, size) => padOctal(Math.floor(number).toString(8), size);
    var padOctal = (string, size) => (string.length === size - 1 ? string : new Array(size - string.length - 1).join("0") + string + " ") + "\0";
    var encDate = (buf, off, size, date) => date === null ? false : encNumber(buf, off, size, date.getTime() / 1e3);
    var NULLS = new Array(156).join("\0");
    var encString = (buf, off, size, string) => string === null ? false : (buf.write(string + NULLS, off, size, "utf8"), string.length !== Buffer.byteLength(string) || string.length > size);
    module2.exports = Header;
  }
});

// node_modules/tar/lib/pax.js
var require_pax = __commonJS({
  "node_modules/tar/lib/pax.js"(exports, module2) {
    "use strict";
    var Header = require_header();
    var path6 = require("path");
    var Pax = class {
      constructor(obj, global3) {
        this.atime = obj.atime || null;
        this.charset = obj.charset || null;
        this.comment = obj.comment || null;
        this.ctime = obj.ctime || null;
        this.gid = obj.gid || null;
        this.gname = obj.gname || null;
        this.linkpath = obj.linkpath || null;
        this.mtime = obj.mtime || null;
        this.path = obj.path || null;
        this.size = obj.size || null;
        this.uid = obj.uid || null;
        this.uname = obj.uname || null;
        this.dev = obj.dev || null;
        this.ino = obj.ino || null;
        this.nlink = obj.nlink || null;
        this.global = global3 || false;
      }
      encode() {
        const body = this.encodeBody();
        if (body === "") {
          return null;
        }
        const bodyLen = Buffer.byteLength(body);
        const bufLen = 512 * Math.ceil(1 + bodyLen / 512);
        const buf = Buffer.allocUnsafe(bufLen);
        for (let i = 0; i < 512; i++) {
          buf[i] = 0;
        }
        new Header({
          // XXX split the path
          // then the path should be PaxHeader + basename, but less than 99,
          // prepend with the dirname
          path: ("PaxHeader/" + path6.basename(this.path)).slice(0, 99),
          mode: this.mode || 420,
          uid: this.uid || null,
          gid: this.gid || null,
          size: bodyLen,
          mtime: this.mtime || null,
          type: this.global ? "GlobalExtendedHeader" : "ExtendedHeader",
          linkpath: "",
          uname: this.uname || "",
          gname: this.gname || "",
          devmaj: 0,
          devmin: 0,
          atime: this.atime || null,
          ctime: this.ctime || null
        }).encode(buf);
        buf.write(body, 512, bodyLen, "utf8");
        for (let i = bodyLen + 512; i < buf.length; i++) {
          buf[i] = 0;
        }
        return buf;
      }
      encodeBody() {
        return this.encodeField("path") + this.encodeField("ctime") + this.encodeField("atime") + this.encodeField("dev") + this.encodeField("ino") + this.encodeField("nlink") + this.encodeField("charset") + this.encodeField("comment") + this.encodeField("gid") + this.encodeField("gname") + this.encodeField("linkpath") + this.encodeField("mtime") + this.encodeField("size") + this.encodeField("uid") + this.encodeField("uname");
      }
      encodeField(field) {
        if (this[field] === null || this[field] === void 0) {
          return "";
        }
        const v = this[field] instanceof Date ? this[field].getTime() / 1e3 : this[field];
        const s = " " + (field === "dev" || field === "ino" || field === "nlink" ? "SCHILY." : "") + field + "=" + v + "\n";
        const byteLen = Buffer.byteLength(s);
        let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;
        if (byteLen + digits >= Math.pow(10, digits)) {
          digits += 1;
        }
        const len = digits + byteLen;
        return len + s;
      }
    };
    Pax.parse = (string, ex, g) => new Pax(merge(parseKV(string), ex), g);
    var merge = (a, b) => b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a;
    var parseKV = (string) => string.replace(/\n$/, "").split("\n").reduce(parseKVLine, /* @__PURE__ */ Object.create(null));
    var parseKVLine = (set, line) => {
      const n = parseInt(line, 10);
      if (n !== Buffer.byteLength(line) + 1) {
        return set;
      }
      line = line.slice((n + " ").length);
      const kv = line.split("=");
      const k = kv.shift().replace(/^SCHILY\.(dev|ino|nlink)/, "$1");
      if (!k) {
        return set;
      }
      const v = kv.join("=");
      set[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k) ? new Date(v * 1e3) : /^[0-9]+$/.test(v) ? +v : v;
      return set;
    };
    module2.exports = Pax;
  }
});

// node_modules/tar/lib/strip-trailing-slashes.js
var require_strip_trailing_slashes = __commonJS({
  "node_modules/tar/lib/strip-trailing-slashes.js"(exports, module2) {
    module2.exports = (str) => {
      let i = str.length - 1;
      let slashesStart = -1;
      while (i > -1 && str.charAt(i) === "/") {
        slashesStart = i;
        i--;
      }
      return slashesStart === -1 ? str : str.slice(0, slashesStart);
    };
  }
});

// node_modules/tar/lib/warn-mixin.js
var require_warn_mixin = __commonJS({
  "node_modules/tar/lib/warn-mixin.js"(exports, module2) {
    "use strict";
    module2.exports = (Base) => class extends Base {
      warn(code, message, data = {}) {
        if (this.file) {
          data.file = this.file;
        }
        if (this.cwd) {
          data.cwd = this.cwd;
        }
        data.code = message instanceof Error && message.code || code;
        data.tarCode = code;
        if (!this.strict && data.recoverable !== false) {
          if (message instanceof Error) {
            data = Object.assign(message, data);
            message = message.message;
          }
          this.emit("warn", data.tarCode, message, data);
        } else if (message instanceof Error) {
          this.emit("error", Object.assign(message, data));
        } else {
          this.emit("error", Object.assign(new Error(`${code}: ${message}`), data));
        }
      }
    };
  }
});

// node_modules/tar/lib/winchars.js
var require_winchars = __commonJS({
  "node_modules/tar/lib/winchars.js"(exports, module2) {
    "use strict";
    var raw = [
      "|",
      "<",
      ">",
      "?",
      ":"
    ];
    var win = raw.map((char) => String.fromCharCode(61440 + char.charCodeAt(0)));
    var toWin = new Map(raw.map((char, i) => [char, win[i]]));
    var toRaw = new Map(win.map((char, i) => [char, raw[i]]));
    module2.exports = {
      encode: (s) => raw.reduce((s2, c) => s2.split(c).join(toWin.get(c)), s),
      decode: (s) => win.reduce((s2, c) => s2.split(c).join(toRaw.get(c)), s)
    };
  }
});

// node_modules/tar/lib/strip-absolute-path.js
var require_strip_absolute_path = __commonJS({
  "node_modules/tar/lib/strip-absolute-path.js"(exports, module2) {
    var { isAbsolute: isAbsolute2, parse: parse2 } = require("path").win32;
    module2.exports = (path6) => {
      let r = "";
      let parsed = parse2(path6);
      while (isAbsolute2(path6) || parsed.root) {
        const root = path6.charAt(0) === "/" && path6.slice(0, 4) !== "//?/" ? "/" : parsed.root;
        path6 = path6.slice(root.length);
        r += root;
        parsed = parse2(path6);
      }
      return [r, path6];
    };
  }
});

// node_modules/tar/lib/mode-fix.js
var require_mode_fix = __commonJS({
  "node_modules/tar/lib/mode-fix.js"(exports, module2) {
    "use strict";
    module2.exports = (mode, isDir, portable) => {
      mode &= 4095;
      if (portable) {
        mode = (mode | 384) & ~18;
      }
      if (isDir) {
        if (mode & 256) {
          mode |= 64;
        }
        if (mode & 32) {
          mode |= 8;
        }
        if (mode & 4) {
          mode |= 1;
        }
      }
      return mode;
    };
  }
});

// node_modules/tar/lib/write-entry.js
var require_write_entry = __commonJS({
  "node_modules/tar/lib/write-entry.js"(exports, module2) {
    "use strict";
    var { Minipass } = require_minipass();
    var Pax = require_pax();
    var Header = require_header();
    var fs2 = require("fs");
    var path6 = require("path");
    var normPath = require_normalize_windows_path();
    var stripSlash = require_strip_trailing_slashes();
    var prefixPath = (path7, prefix) => {
      if (!prefix) {
        return normPath(path7);
      }
      path7 = normPath(path7).replace(/^\.(\/|$)/, "");
      return stripSlash(prefix) + "/" + path7;
    };
    var maxReadSize = 16 * 1024 * 1024;
    var PROCESS = Symbol("process");
    var FILE = Symbol("file");
    var DIRECTORY = Symbol("directory");
    var SYMLINK = Symbol("symlink");
    var HARDLINK = Symbol("hardlink");
    var HEADER = Symbol("header");
    var READ = Symbol("read");
    var LSTAT = Symbol("lstat");
    var ONLSTAT = Symbol("onlstat");
    var ONREAD = Symbol("onread");
    var ONREADLINK = Symbol("onreadlink");
    var OPENFILE = Symbol("openfile");
    var ONOPENFILE = Symbol("onopenfile");
    var CLOSE = Symbol("close");
    var MODE = Symbol("mode");
    var AWAITDRAIN = Symbol("awaitDrain");
    var ONDRAIN = Symbol("ondrain");
    var PREFIX = Symbol("prefix");
    var HAD_ERROR = Symbol("hadError");
    var warner = require_warn_mixin();
    var winchars = require_winchars();
    var stripAbsolutePath = require_strip_absolute_path();
    var modeFix = require_mode_fix();
    var WriteEntry = warner(class WriteEntry extends Minipass {
      constructor(p, opt) {
        opt = opt || {};
        super(opt);
        if (typeof p !== "string") {
          throw new TypeError("path is required");
        }
        this.path = normPath(p);
        this.portable = !!opt.portable;
        this.myuid = process.getuid && process.getuid() || 0;
        this.myuser = process.env.USER || "";
        this.maxReadSize = opt.maxReadSize || maxReadSize;
        this.linkCache = opt.linkCache || /* @__PURE__ */ new Map();
        this.statCache = opt.statCache || /* @__PURE__ */ new Map();
        this.preservePaths = !!opt.preservePaths;
        this.cwd = normPath(opt.cwd || process.cwd());
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.noMtime = !!opt.noMtime;
        this.mtime = opt.mtime || null;
        this.prefix = opt.prefix ? normPath(opt.prefix) : null;
        this.fd = null;
        this.blockLen = null;
        this.blockRemain = null;
        this.buf = null;
        this.offset = null;
        this.length = null;
        this.pos = null;
        this.remain = null;
        if (typeof opt.onwarn === "function") {
          this.on("warn", opt.onwarn);
        }
        let pathWarn = false;
        if (!this.preservePaths) {
          const [root, stripped] = stripAbsolutePath(this.path);
          if (root) {
            this.path = stripped;
            pathWarn = root;
          }
        }
        this.win32 = !!opt.win32 || process.platform === "win32";
        if (this.win32) {
          this.path = winchars.decode(this.path.replace(/\\/g, "/"));
          p = p.replace(/\\/g, "/");
        }
        this.absolute = normPath(opt.absolute || path6.resolve(this.cwd, p));
        if (this.path === "") {
          this.path = "./";
        }
        if (pathWarn) {
          this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
            entry: this,
            path: pathWarn + this.path
          });
        }
        if (this.statCache.has(this.absolute)) {
          this[ONLSTAT](this.statCache.get(this.absolute));
        } else {
          this[LSTAT]();
        }
      }
      emit(ev, ...data) {
        if (ev === "error") {
          this[HAD_ERROR] = true;
        }
        return super.emit(ev, ...data);
      }
      [LSTAT]() {
        fs2.lstat(this.absolute, (er, stat) => {
          if (er) {
            return this.emit("error", er);
          }
          this[ONLSTAT](stat);
        });
      }
      [ONLSTAT](stat) {
        this.statCache.set(this.absolute, stat);
        this.stat = stat;
        if (!stat.isFile()) {
          stat.size = 0;
        }
        this.type = getType(stat);
        this.emit("stat", stat);
        this[PROCESS]();
      }
      [PROCESS]() {
        switch (this.type) {
          case "File":
            return this[FILE]();
          case "Directory":
            return this[DIRECTORY]();
          case "SymbolicLink":
            return this[SYMLINK]();
          default:
            return this.end();
        }
      }
      [MODE](mode) {
        return modeFix(mode, this.type === "Directory", this.portable);
      }
      [PREFIX](path7) {
        return prefixPath(path7, this.prefix);
      }
      [HEADER]() {
        if (this.type === "Directory" && this.portable) {
          this.noMtime = true;
        }
        this.header = new Header({
          path: this[PREFIX](this.path),
          // only apply the prefix to hard links.
          linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
          // only the permissions and setuid/setgid/sticky bitflags
          // not the higher-order bits that specify file type
          mode: this[MODE](this.stat.mode),
          uid: this.portable ? null : this.stat.uid,
          gid: this.portable ? null : this.stat.gid,
          size: this.stat.size,
          mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
          type: this.type,
          uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : "",
          atime: this.portable ? null : this.stat.atime,
          ctime: this.portable ? null : this.stat.ctime
        });
        if (this.header.encode() && !this.noPax) {
          super.write(new Pax({
            atime: this.portable ? null : this.header.atime,
            ctime: this.portable ? null : this.header.ctime,
            gid: this.portable ? null : this.header.gid,
            mtime: this.noMtime ? null : this.mtime || this.header.mtime,
            path: this[PREFIX](this.path),
            linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
            size: this.header.size,
            uid: this.portable ? null : this.header.uid,
            uname: this.portable ? null : this.header.uname,
            dev: this.portable ? null : this.stat.dev,
            ino: this.portable ? null : this.stat.ino,
            nlink: this.portable ? null : this.stat.nlink
          }).encode());
        }
        super.write(this.header.block);
      }
      [DIRECTORY]() {
        if (this.path.slice(-1) !== "/") {
          this.path += "/";
        }
        this.stat.size = 0;
        this[HEADER]();
        this.end();
      }
      [SYMLINK]() {
        fs2.readlink(this.absolute, (er, linkpath) => {
          if (er) {
            return this.emit("error", er);
          }
          this[ONREADLINK](linkpath);
        });
      }
      [ONREADLINK](linkpath) {
        this.linkpath = normPath(linkpath);
        this[HEADER]();
        this.end();
      }
      [HARDLINK](linkpath) {
        this.type = "Link";
        this.linkpath = normPath(path6.relative(this.cwd, linkpath));
        this.stat.size = 0;
        this[HEADER]();
        this.end();
      }
      [FILE]() {
        if (this.stat.nlink > 1) {
          const linkKey = this.stat.dev + ":" + this.stat.ino;
          if (this.linkCache.has(linkKey)) {
            const linkpath = this.linkCache.get(linkKey);
            if (linkpath.indexOf(this.cwd) === 0) {
              return this[HARDLINK](linkpath);
            }
          }
          this.linkCache.set(linkKey, this.absolute);
        }
        this[HEADER]();
        if (this.stat.size === 0) {
          return this.end();
        }
        this[OPENFILE]();
      }
      [OPENFILE]() {
        fs2.open(this.absolute, "r", (er, fd) => {
          if (er) {
            return this.emit("error", er);
          }
          this[ONOPENFILE](fd);
        });
      }
      [ONOPENFILE](fd) {
        this.fd = fd;
        if (this[HAD_ERROR]) {
          return this[CLOSE]();
        }
        this.blockLen = 512 * Math.ceil(this.stat.size / 512);
        this.blockRemain = this.blockLen;
        const bufLen = Math.min(this.blockLen, this.maxReadSize);
        this.buf = Buffer.allocUnsafe(bufLen);
        this.offset = 0;
        this.pos = 0;
        this.remain = this.stat.size;
        this.length = this.buf.length;
        this[READ]();
      }
      [READ]() {
        const { fd, buf, offset, length, pos } = this;
        fs2.read(fd, buf, offset, length, pos, (er, bytesRead) => {
          if (er) {
            return this[CLOSE](() => this.emit("error", er));
          }
          this[ONREAD](bytesRead);
        });
      }
      [CLOSE](cb) {
        fs2.close(this.fd, cb);
      }
      [ONREAD](bytesRead) {
        if (bytesRead <= 0 && this.remain > 0) {
          const er = new Error("encountered unexpected EOF");
          er.path = this.absolute;
          er.syscall = "read";
          er.code = "EOF";
          return this[CLOSE](() => this.emit("error", er));
        }
        if (bytesRead > this.remain) {
          const er = new Error("did not encounter expected EOF");
          er.path = this.absolute;
          er.syscall = "read";
          er.code = "EOF";
          return this[CLOSE](() => this.emit("error", er));
        }
        if (bytesRead === this.remain) {
          for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {
            this.buf[i + this.offset] = 0;
            bytesRead++;
            this.remain++;
          }
        }
        const writeBuf = this.offset === 0 && bytesRead === this.buf.length ? this.buf : this.buf.slice(this.offset, this.offset + bytesRead);
        const flushed = this.write(writeBuf);
        if (!flushed) {
          this[AWAITDRAIN](() => this[ONDRAIN]());
        } else {
          this[ONDRAIN]();
        }
      }
      [AWAITDRAIN](cb) {
        this.once("drain", cb);
      }
      write(writeBuf) {
        if (this.blockRemain < writeBuf.length) {
          const er = new Error("writing more data than expected");
          er.path = this.absolute;
          return this.emit("error", er);
        }
        this.remain -= writeBuf.length;
        this.blockRemain -= writeBuf.length;
        this.pos += writeBuf.length;
        this.offset += writeBuf.length;
        return super.write(writeBuf);
      }
      [ONDRAIN]() {
        if (!this.remain) {
          if (this.blockRemain) {
            super.write(Buffer.alloc(this.blockRemain));
          }
          return this[CLOSE]((er) => er ? this.emit("error", er) : this.end());
        }
        if (this.offset >= this.length) {
          this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length));
          this.offset = 0;
        }
        this.length = this.buf.length - this.offset;
        this[READ]();
      }
    });
    var WriteEntrySync = class extends WriteEntry {
      [LSTAT]() {
        this[ONLSTAT](fs2.lstatSync(this.absolute));
      }
      [SYMLINK]() {
        this[ONREADLINK](fs2.readlinkSync(this.absolute));
      }
      [OPENFILE]() {
        this[ONOPENFILE](fs2.openSync(this.absolute, "r"));
      }
      [READ]() {
        let threw = true;
        try {
          const { fd, buf, offset, length, pos } = this;
          const bytesRead = fs2.readSync(fd, buf, offset, length, pos);
          this[ONREAD](bytesRead);
          threw = false;
        } finally {
          if (threw) {
            try {
              this[CLOSE](() => {
              });
            } catch (er) {
            }
          }
        }
      }
      [AWAITDRAIN](cb) {
        cb();
      }
      [CLOSE](cb) {
        fs2.closeSync(this.fd);
        cb();
      }
    };
    var WriteEntryTar = warner(class WriteEntryTar extends Minipass {
      constructor(readEntry, opt) {
        opt = opt || {};
        super(opt);
        this.preservePaths = !!opt.preservePaths;
        this.portable = !!opt.portable;
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.noMtime = !!opt.noMtime;
        this.readEntry = readEntry;
        this.type = readEntry.type;
        if (this.type === "Directory" && this.portable) {
          this.noMtime = true;
        }
        this.prefix = opt.prefix || null;
        this.path = normPath(readEntry.path);
        this.mode = this[MODE](readEntry.mode);
        this.uid = this.portable ? null : readEntry.uid;
        this.gid = this.portable ? null : readEntry.gid;
        this.uname = this.portable ? null : readEntry.uname;
        this.gname = this.portable ? null : readEntry.gname;
        this.size = readEntry.size;
        this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime;
        this.atime = this.portable ? null : readEntry.atime;
        this.ctime = this.portable ? null : readEntry.ctime;
        this.linkpath = normPath(readEntry.linkpath);
        if (typeof opt.onwarn === "function") {
          this.on("warn", opt.onwarn);
        }
        let pathWarn = false;
        if (!this.preservePaths) {
          const [root, stripped] = stripAbsolutePath(this.path);
          if (root) {
            this.path = stripped;
            pathWarn = root;
          }
        }
        this.remain = readEntry.size;
        this.blockRemain = readEntry.startBlockSize;
        this.header = new Header({
          path: this[PREFIX](this.path),
          linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
          // only the permissions and setuid/setgid/sticky bitflags
          // not the higher-order bits that specify file type
          mode: this.mode,
          uid: this.portable ? null : this.uid,
          gid: this.portable ? null : this.gid,
          size: this.size,
          mtime: this.noMtime ? null : this.mtime,
          type: this.type,
          uname: this.portable ? null : this.uname,
          atime: this.portable ? null : this.atime,
          ctime: this.portable ? null : this.ctime
        });
        if (pathWarn) {
          this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
            entry: this,
            path: pathWarn + this.path
          });
        }
        if (this.header.encode() && !this.noPax) {
          super.write(new Pax({
            atime: this.portable ? null : this.atime,
            ctime: this.portable ? null : this.ctime,
            gid: this.portable ? null : this.gid,
            mtime: this.noMtime ? null : this.mtime,
            path: this[PREFIX](this.path),
            linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
            size: this.size,
            uid: this.portable ? null : this.uid,
            uname: this.portable ? null : this.uname,
            dev: this.portable ? null : this.readEntry.dev,
            ino: this.portable ? null : this.readEntry.ino,
            nlink: this.portable ? null : this.readEntry.nlink
          }).encode());
        }
        super.write(this.header.block);
        readEntry.pipe(this);
      }
      [PREFIX](path7) {
        return prefixPath(path7, this.prefix);
      }
      [MODE](mode) {
        return modeFix(mode, this.type === "Directory", this.portable);
      }
      write(data) {
        const writeLen = data.length;
        if (writeLen > this.blockRemain) {
          throw new Error("writing more to entry than is appropriate");
        }
        this.blockRemain -= writeLen;
        return super.write(data);
      }
      end() {
        if (this.blockRemain) {
          super.write(Buffer.alloc(this.blockRemain));
        }
        return super.end();
      }
    });
    WriteEntry.Sync = WriteEntrySync;
    WriteEntry.Tar = WriteEntryTar;
    var getType = (stat) => stat.isFile() ? "File" : stat.isDirectory() ? "Directory" : stat.isSymbolicLink() ? "SymbolicLink" : "Unsupported";
    module2.exports = WriteEntry;
  }
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/yallist/iterator.js"(exports, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/yallist/yallist.js"(exports, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/tar/lib/pack.js
var require_pack = __commonJS({
  "node_modules/tar/lib/pack.js"(exports, module2) {
    "use strict";
    var PackJob = class {
      constructor(path7, absolute) {
        this.path = path7 || "./";
        this.absolute = absolute;
        this.entry = null;
        this.stat = null;
        this.readdir = null;
        this.pending = false;
        this.ignore = false;
        this.piped = false;
      }
    };
    var { Minipass } = require_minipass();
    var zlib = require_minizlib();
    var ReadEntry = require_read_entry();
    var WriteEntry = require_write_entry();
    var WriteEntrySync = WriteEntry.Sync;
    var WriteEntryTar = WriteEntry.Tar;
    var Yallist = require_yallist();
    var EOF = Buffer.alloc(1024);
    var ONSTAT = Symbol("onStat");
    var ENDED = Symbol("ended");
    var QUEUE = Symbol("queue");
    var CURRENT = Symbol("current");
    var PROCESS = Symbol("process");
    var PROCESSING = Symbol("processing");
    var PROCESSJOB = Symbol("processJob");
    var JOBS = Symbol("jobs");
    var JOBDONE = Symbol("jobDone");
    var ADDFSENTRY = Symbol("addFSEntry");
    var ADDTARENTRY = Symbol("addTarEntry");
    var STAT = Symbol("stat");
    var READDIR = Symbol("readdir");
    var ONREADDIR = Symbol("onreaddir");
    var PIPE = Symbol("pipe");
    var ENTRY = Symbol("entry");
    var ENTRYOPT = Symbol("entryOpt");
    var WRITEENTRYCLASS = Symbol("writeEntryClass");
    var WRITE = Symbol("write");
    var ONDRAIN = Symbol("ondrain");
    var fs2 = require("fs");
    var path6 = require("path");
    var warner = require_warn_mixin();
    var normPath = require_normalize_windows_path();
    var Pack = warner(class Pack extends Minipass {
      constructor(opt) {
        super(opt);
        opt = opt || /* @__PURE__ */ Object.create(null);
        this.opt = opt;
        this.file = opt.file || "";
        this.cwd = opt.cwd || process.cwd();
        this.maxReadSize = opt.maxReadSize;
        this.preservePaths = !!opt.preservePaths;
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.prefix = normPath(opt.prefix || "");
        this.linkCache = opt.linkCache || /* @__PURE__ */ new Map();
        this.statCache = opt.statCache || /* @__PURE__ */ new Map();
        this.readdirCache = opt.readdirCache || /* @__PURE__ */ new Map();
        this[WRITEENTRYCLASS] = WriteEntry;
        if (typeof opt.onwarn === "function") {
          this.on("warn", opt.onwarn);
        }
        this.portable = !!opt.portable;
        this.zip = null;
        if (opt.gzip || opt.brotli) {
          if (opt.gzip && opt.brotli) {
            throw new TypeError("gzip and brotli are mutually exclusive");
          }
          if (opt.gzip) {
            if (typeof opt.gzip !== "object") {
              opt.gzip = {};
            }
            if (this.portable) {
              opt.gzip.portable = true;
            }
            this.zip = new zlib.Gzip(opt.gzip);
          }
          if (opt.brotli) {
            if (typeof opt.brotli !== "object") {
              opt.brotli = {};
            }
            this.zip = new zlib.BrotliCompress(opt.brotli);
          }
          this.zip.on("data", (chunk) => super.write(chunk));
          this.zip.on("end", (_) => super.end());
          this.zip.on("drain", (_) => this[ONDRAIN]());
          this.on("resume", (_) => this.zip.resume());
        } else {
          this.on("drain", this[ONDRAIN]);
        }
        this.noDirRecurse = !!opt.noDirRecurse;
        this.follow = !!opt.follow;
        this.noMtime = !!opt.noMtime;
        this.mtime = opt.mtime || null;
        this.filter = typeof opt.filter === "function" ? opt.filter : (_) => true;
        this[QUEUE] = new Yallist();
        this[JOBS] = 0;
        this.jobs = +opt.jobs || 4;
        this[PROCESSING] = false;
        this[ENDED] = false;
      }
      [WRITE](chunk) {
        return super.write(chunk);
      }
      add(path7) {
        this.write(path7);
        return this;
      }
      end(path7) {
        if (path7) {
          this.write(path7);
        }
        this[ENDED] = true;
        this[PROCESS]();
        return this;
      }
      write(path7) {
        if (this[ENDED]) {
          throw new Error("write after end");
        }
        if (path7 instanceof ReadEntry) {
          this[ADDTARENTRY](path7);
        } else {
          this[ADDFSENTRY](path7);
        }
        return this.flowing;
      }
      [ADDTARENTRY](p) {
        const absolute = normPath(path6.resolve(this.cwd, p.path));
        if (!this.filter(p.path, p)) {
          p.resume();
        } else {
          const job = new PackJob(p.path, absolute, false);
          job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));
          job.entry.on("end", (_) => this[JOBDONE](job));
          this[JOBS] += 1;
          this[QUEUE].push(job);
        }
        this[PROCESS]();
      }
      [ADDFSENTRY](p) {
        const absolute = normPath(path6.resolve(this.cwd, p));
        this[QUEUE].push(new PackJob(p, absolute));
        this[PROCESS]();
      }
      [STAT](job) {
        job.pending = true;
        this[JOBS] += 1;
        const stat = this.follow ? "stat" : "lstat";
        fs2[stat](job.absolute, (er, stat2) => {
          job.pending = false;
          this[JOBS] -= 1;
          if (er) {
            this.emit("error", er);
          } else {
            this[ONSTAT](job, stat2);
          }
        });
      }
      [ONSTAT](job, stat) {
        this.statCache.set(job.absolute, stat);
        job.stat = stat;
        if (!this.filter(job.path, stat)) {
          job.ignore = true;
        }
        this[PROCESS]();
      }
      [READDIR](job) {
        job.pending = true;
        this[JOBS] += 1;
        fs2.readdir(job.absolute, (er, entries) => {
          job.pending = false;
          this[JOBS] -= 1;
          if (er) {
            return this.emit("error", er);
          }
          this[ONREADDIR](job, entries);
        });
      }
      [ONREADDIR](job, entries) {
        this.readdirCache.set(job.absolute, entries);
        job.readdir = entries;
        this[PROCESS]();
      }
      [PROCESS]() {
        if (this[PROCESSING]) {
          return;
        }
        this[PROCESSING] = true;
        for (let w = this[QUEUE].head; w !== null && this[JOBS] < this.jobs; w = w.next) {
          this[PROCESSJOB](w.value);
          if (w.value.ignore) {
            const p = w.next;
            this[QUEUE].removeNode(w);
            w.next = p;
          }
        }
        this[PROCESSING] = false;
        if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {
          if (this.zip) {
            this.zip.end(EOF);
          } else {
            super.write(EOF);
            super.end();
          }
        }
      }
      get [CURRENT]() {
        return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;
      }
      [JOBDONE](job) {
        this[QUEUE].shift();
        this[JOBS] -= 1;
        this[PROCESS]();
      }
      [PROCESSJOB](job) {
        if (job.pending) {
          return;
        }
        if (job.entry) {
          if (job === this[CURRENT] && !job.piped) {
            this[PIPE](job);
          }
          return;
        }
        if (!job.stat) {
          if (this.statCache.has(job.absolute)) {
            this[ONSTAT](job, this.statCache.get(job.absolute));
          } else {
            this[STAT](job);
          }
        }
        if (!job.stat) {
          return;
        }
        if (job.ignore) {
          return;
        }
        if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
          if (this.readdirCache.has(job.absolute)) {
            this[ONREADDIR](job, this.readdirCache.get(job.absolute));
          } else {
            this[READDIR](job);
          }
          if (!job.readdir) {
            return;
          }
        }
        job.entry = this[ENTRY](job);
        if (!job.entry) {
          job.ignore = true;
          return;
        }
        if (job === this[CURRENT] && !job.piped) {
          this[PIPE](job);
        }
      }
      [ENTRYOPT](job) {
        return {
          onwarn: (code, msg, data) => this.warn(code, msg, data),
          noPax: this.noPax,
          cwd: this.cwd,
          absolute: job.absolute,
          preservePaths: this.preservePaths,
          maxReadSize: this.maxReadSize,
          strict: this.strict,
          portable: this.portable,
          linkCache: this.linkCache,
          statCache: this.statCache,
          noMtime: this.noMtime,
          mtime: this.mtime,
          prefix: this.prefix
        };
      }
      [ENTRY](job) {
        this[JOBS] += 1;
        try {
          return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on("end", () => this[JOBDONE](job)).on("error", (er) => this.emit("error", er));
        } catch (er) {
          this.emit("error", er);
        }
      }
      [ONDRAIN]() {
        if (this[CURRENT] && this[CURRENT].entry) {
          this[CURRENT].entry.resume();
        }
      }
      // like .pipe() but using super, because our write() is special
      [PIPE](job) {
        job.piped = true;
        if (job.readdir) {
          job.readdir.forEach((entry) => {
            const p = job.path;
            const base = p === "./" ? "" : p.replace(/\/*$/, "/");
            this[ADDFSENTRY](base + entry);
          });
        }
        const source = job.entry;
        const zip = this.zip;
        if (zip) {
          source.on("data", (chunk) => {
            if (!zip.write(chunk)) {
              source.pause();
            }
          });
        } else {
          source.on("data", (chunk) => {
            if (!super.write(chunk)) {
              source.pause();
            }
          });
        }
      }
      pause() {
        if (this.zip) {
          this.zip.pause();
        }
        return super.pause();
      }
    });
    var PackSync = class extends Pack {
      constructor(opt) {
        super(opt);
        this[WRITEENTRYCLASS] = WriteEntrySync;
      }
      // pause/resume are no-ops in sync streams.
      pause() {
      }
      resume() {
      }
      [STAT](job) {
        const stat = this.follow ? "statSync" : "lstatSync";
        this[ONSTAT](job, fs2[stat](job.absolute));
      }
      [READDIR](job, stat) {
        this[ONREADDIR](job, fs2.readdirSync(job.absolute));
      }
      // gotta get it all in this tick
      [PIPE](job) {
        const source = job.entry;
        const zip = this.zip;
        if (job.readdir) {
          job.readdir.forEach((entry) => {
            const p = job.path;
            const base = p === "./" ? "" : p.replace(/\/*$/, "/");
            this[ADDFSENTRY](base + entry);
          });
        }
        if (zip) {
          source.on("data", (chunk) => {
            zip.write(chunk);
          });
        } else {
          source.on("data", (chunk) => {
            super[WRITE](chunk);
          });
        }
      }
    };
    Pack.Sync = PackSync;
    module2.exports = Pack;
  }
});

// node_modules/fs-minipass/node_modules/minipass/index.js
var require_minipass3 = __commonJS({
  "node_modules/fs-minipass/node_modules/minipass/index.js"(exports, module2) {
    "use strict";
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var EE = require("events");
    var Stream = require("stream");
    var SD = require("string_decoder").StringDecoder;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var defer = (fn) => Promise.resolve().then(fn);
    var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
    var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
    var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    var Pipe = class {
      constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // istanbul ignore next - only here for the prototype
      proxyErrors() {
      }
      end() {
        this.unpipe();
        if (this.opts.end)
          this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src.on("error", this.proxyErrors);
      }
    };
    module2.exports = class Minipass extends Stream {
      constructor(options) {
        super();
        this[FLOWING] = false;
        this[PAUSED] = false;
        this.pipes = [];
        this.buffer = [];
        this[OBJECTMODE] = options && options.objectMode || false;
        if (this[OBJECTMODE])
          this[ENCODING] = null;
        else
          this[ENCODING] = options && options.encoding || null;
        if (this[ENCODING] === "buffer")
          this[ENCODING] = null;
        this[ASYNC] = options && !!options.async || false;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this[EMITTED_ERROR] = null;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
      }
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      get encoding() {
        return this[ENCODING];
      }
      set encoding(enc) {
        if (this[OBJECTMODE])
          throw new Error("cannot set encoding in objectMode");
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
          throw new Error("cannot change encoding");
        if (this[ENCODING] !== enc) {
          this[DECODER] = enc ? new SD(enc) : null;
          if (this.buffer.length)
            this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
      }
      setEncoding(enc) {
        this.encoding = enc;
      }
      get objectMode() {
        return this[OBJECTMODE];
      }
      set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
      }
      get ["async"]() {
        return this[ASYNC];
      }
      set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
      }
      write(chunk, encoding, cb) {
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(
            new Error("Cannot call write after a stream was destroyed"),
            { code: "ERR_STREAM_DESTROYED" }
          ));
          return true;
        }
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (!encoding)
          encoding = "utf8";
        const fn = this[ASYNC] ? defer : (f) => f();
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBuffer(chunk))
            chunk = Buffer.from(chunk);
          else if (typeof chunk !== "string")
            this.objectMode = true;
        }
        if (this[OBJECTMODE]) {
          if (this.flowing && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          if (this.flowing)
            this.emit("data", chunk);
          else
            this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING])
          chunk = this[DECODER].write(chunk);
        if (this.flowing && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this.flowing)
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      read(n) {
        if (this[DESTROYED])
          return null;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE])
          n = null;
        if (this.buffer.length > 1 && !this[OBJECTMODE]) {
          if (this.encoding)
            this.buffer = [this.buffer.join("")];
          else
            this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
        }
        const ret = this[READ](n || null, this.buffer[0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (n === chunk.length || n === null)
          this[BUFFERSHIFT]();
        else {
          this.buffer[0] = chunk.slice(n);
          chunk = chunk.slice(0, n);
          this[BUFFERLENGTH] -= n;
        }
        this.emit("data", chunk);
        if (!this.buffer.length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function")
          cb = chunk, chunk = null;
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (chunk)
          this.write(chunk, encoding);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this.flowing || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED])
          return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this.buffer.length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      resume() {
        return this[RESUME]();
      }
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
      }
      get destroyed() {
        return this[DESTROYED];
      }
      get flowing() {
        return this[FLOWING];
      }
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        this.buffer.push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this.buffer.length) {
          if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
          else
            this[BUFFERLENGTH] -= this.buffer[0].length;
        }
        return this.buffer.shift();
      }
      [FLUSH](noDrain) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
        if (!noDrain && !this.buffer.length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        return chunk ? (this.emit("data", chunk), this.flowing) : false;
      }
      pipe(dest, opts) {
        if (this[DESTROYED])
          return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end)
            dest.end();
        } else {
          this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
          if (this[ASYNC])
            defer(() => this[RESUME]());
          else
            this[RESUME]();
        }
        return dest;
      }
      unpipe(dest) {
        const p = this.pipes.find((p2) => p2.dest === dest);
        if (p) {
          this.pipes.splice(this.pipes.indexOf(p), 1);
          p.unpipe();
        }
      }
      addListener(ev, fn) {
        return this.on(ev, fn);
      }
      on(ev, fn) {
        const ret = super.on(ev, fn);
        if (ev === "data" && !this.pipes.length && !this.flowing)
          this[RESUME]();
        else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
          super.emit("readable");
        else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          if (this[ASYNC])
            defer(() => fn.call(this, this[EMITTED_ERROR]));
          else
            fn.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      emit(ev, data, ...extra) {
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
          return;
        else if (ev === "data") {
          return !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          const ret2 = super.emit("error", data);
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, data, ...extra);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p of this.pipes) {
          if (p.dest.write(data) === false)
            this.pause();
        }
        const ret = super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END])
          return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[ASYNC])
          defer(() => this[EMITEND2]());
        else
          this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p of this.pipes) {
              p.dest.write(data);
            }
            super.emit("data", data);
          }
        }
        for (const p of this.pipes) {
          p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      // const all = await stream.collect()
      collect() {
        const buf = [];
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        return p.then(() => buf);
      }
      // const data = await stream.concat()
      concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
      }
      // stream.promise().then(() => done, er => emitted error)
      promise() {
        return new Promise((resolve2, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve2());
        });
      }
      // for await (let chunk of stream)
      [ASYNCITERATOR]() {
        const next = () => {
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return Promise.resolve({ done: true });
          let resolve2 = null;
          let reject = null;
          const onerr = (er) => {
            this.removeListener("data", ondata);
            this.removeListener("end", onend);
            reject(er);
          };
          const ondata = (value) => {
            this.removeListener("error", onerr);
            this.removeListener("end", onend);
            this.pause();
            resolve2({ value, done: !!this[EOF] });
          };
          const onend = () => {
            this.removeListener("error", onerr);
            this.removeListener("data", ondata);
            resolve2({ done: true });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve2 = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return { next };
      }
      // for (let chunk of stream)
      [ITERATOR]() {
        const next = () => {
          const value = this.read();
          const done = value === null;
          return { value, done };
        };
        return { next };
      }
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this.buffer.length = 0;
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === "function" && !this[CLOSED])
          this.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      static isStream(s) {
        return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === "function" || // readable
        typeof s.write === "function" && typeof s.end === "function"));
      }
    };
  }
});

// node_modules/fs-minipass/index.js
var require_fs_minipass = __commonJS({
  "node_modules/fs-minipass/index.js"(exports) {
    "use strict";
    var MiniPass = require_minipass3();
    var EE = require("events").EventEmitter;
    var fs2 = require("fs");
    var writev = fs2.writev;
    if (!writev) {
      const binding = process.binding("fs");
      const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;
      writev = (fd, iovec, pos, cb) => {
        const done = (er, bw) => cb(er, bw, iovec);
        const req = new FSReqWrap();
        req.oncomplete = done;
        binding.writeBuffers(fd, iovec, pos, req);
      };
    }
    var _autoClose = Symbol("_autoClose");
    var _close = Symbol("_close");
    var _ended = Symbol("_ended");
    var _fd = Symbol("_fd");
    var _finished = Symbol("_finished");
    var _flags = Symbol("_flags");
    var _flush = Symbol("_flush");
    var _handleChunk = Symbol("_handleChunk");
    var _makeBuf = Symbol("_makeBuf");
    var _mode = Symbol("_mode");
    var _needDrain = Symbol("_needDrain");
    var _onerror = Symbol("_onerror");
    var _onopen = Symbol("_onopen");
    var _onread = Symbol("_onread");
    var _onwrite = Symbol("_onwrite");
    var _open = Symbol("_open");
    var _path = Symbol("_path");
    var _pos = Symbol("_pos");
    var _queue = Symbol("_queue");
    var _read = Symbol("_read");
    var _readSize = Symbol("_readSize");
    var _reading = Symbol("_reading");
    var _remain = Symbol("_remain");
    var _size = Symbol("_size");
    var _write = Symbol("_write");
    var _writing = Symbol("_writing");
    var _defaultFlag = Symbol("_defaultFlag");
    var _errored = Symbol("_errored");
    var ReadStream = class extends MiniPass {
      constructor(path6, opt) {
        opt = opt || {};
        super(opt);
        this.readable = true;
        this.writable = false;
        if (typeof path6 !== "string")
          throw new TypeError("path must be a string");
        this[_errored] = false;
        this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
        this[_path] = path6;
        this[_readSize] = opt.readSize || 16 * 1024 * 1024;
        this[_reading] = false;
        this[_size] = typeof opt.size === "number" ? opt.size : Infinity;
        this[_remain] = this[_size];
        this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
        if (typeof this[_fd] === "number")
          this[_read]();
        else
          this[_open]();
      }
      get fd() {
        return this[_fd];
      }
      get path() {
        return this[_path];
      }
      write() {
        throw new TypeError("this is a readable stream");
      }
      end() {
        throw new TypeError("this is a readable stream");
      }
      [_open]() {
        fs2.open(this[_path], "r", (er, fd) => this[_onopen](er, fd));
      }
      [_onopen](er, fd) {
        if (er)
          this[_onerror](er);
        else {
          this[_fd] = fd;
          this.emit("open", fd);
          this[_read]();
        }
      }
      [_makeBuf]() {
        return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
      }
      [_read]() {
        if (!this[_reading]) {
          this[_reading] = true;
          const buf = this[_makeBuf]();
          if (buf.length === 0)
            return process.nextTick(() => this[_onread](null, 0, buf));
          fs2.read(this[_fd], buf, 0, buf.length, null, (er, br, buf2) => this[_onread](er, br, buf2));
        }
      }
      [_onread](er, br, buf) {
        this[_reading] = false;
        if (er)
          this[_onerror](er);
        else if (this[_handleChunk](br, buf))
          this[_read]();
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs2.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
        }
      }
      [_onerror](er) {
        this[_reading] = true;
        this[_close]();
        this.emit("error", er);
      }
      [_handleChunk](br, buf) {
        let ret = false;
        this[_remain] -= br;
        if (br > 0)
          ret = super.write(br < buf.length ? buf.slice(0, br) : buf);
        if (br === 0 || this[_remain] <= 0) {
          ret = false;
          this[_close]();
          super.end();
        }
        return ret;
      }
      emit(ev, data) {
        switch (ev) {
          case "prefinish":
          case "finish":
            break;
          case "drain":
            if (typeof this[_fd] === "number")
              this[_read]();
            break;
          case "error":
            if (this[_errored])
              return;
            this[_errored] = true;
            return super.emit(ev, data);
          default:
            return super.emit(ev, data);
        }
      }
    };
    var ReadStreamSync = class extends ReadStream {
      [_open]() {
        let threw = true;
        try {
          this[_onopen](null, fs2.openSync(this[_path], "r"));
          threw = false;
        } finally {
          if (threw)
            this[_close]();
        }
      }
      [_read]() {
        let threw = true;
        try {
          if (!this[_reading]) {
            this[_reading] = true;
            do {
              const buf = this[_makeBuf]();
              const br = buf.length === 0 ? 0 : fs2.readSync(this[_fd], buf, 0, buf.length, null);
              if (!this[_handleChunk](br, buf))
                break;
            } while (true);
            this[_reading] = false;
          }
          threw = false;
        } finally {
          if (threw)
            this[_close]();
        }
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs2.closeSync(fd);
          this.emit("close");
        }
      }
    };
    var WriteStream = class extends EE {
      constructor(path6, opt) {
        opt = opt || {};
        super(opt);
        this.readable = false;
        this.writable = true;
        this[_errored] = false;
        this[_writing] = false;
        this[_ended] = false;
        this[_needDrain] = false;
        this[_queue] = [];
        this[_path] = path6;
        this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
        this[_mode] = opt.mode === void 0 ? 438 : opt.mode;
        this[_pos] = typeof opt.start === "number" ? opt.start : null;
        this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
        const defaultFlag = this[_pos] !== null ? "r+" : "w";
        this[_defaultFlag] = opt.flags === void 0;
        this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags;
        if (this[_fd] === null)
          this[_open]();
      }
      emit(ev, data) {
        if (ev === "error") {
          if (this[_errored])
            return;
          this[_errored] = true;
        }
        return super.emit(ev, data);
      }
      get fd() {
        return this[_fd];
      }
      get path() {
        return this[_path];
      }
      [_onerror](er) {
        this[_close]();
        this[_writing] = true;
        this.emit("error", er);
      }
      [_open]() {
        fs2.open(
          this[_path],
          this[_flags],
          this[_mode],
          (er, fd) => this[_onopen](er, fd)
        );
      }
      [_onopen](er, fd) {
        if (this[_defaultFlag] && this[_flags] === "r+" && er && er.code === "ENOENT") {
          this[_flags] = "w";
          this[_open]();
        } else if (er)
          this[_onerror](er);
        else {
          this[_fd] = fd;
          this.emit("open", fd);
          this[_flush]();
        }
      }
      end(buf, enc) {
        if (buf)
          this.write(buf, enc);
        this[_ended] = true;
        if (!this[_writing] && !this[_queue].length && typeof this[_fd] === "number")
          this[_onwrite](null, 0);
        return this;
      }
      write(buf, enc) {
        if (typeof buf === "string")
          buf = Buffer.from(buf, enc);
        if (this[_ended]) {
          this.emit("error", new Error("write() after end()"));
          return false;
        }
        if (this[_fd] === null || this[_writing] || this[_queue].length) {
          this[_queue].push(buf);
          this[_needDrain] = true;
          return false;
        }
        this[_writing] = true;
        this[_write](buf);
        return true;
      }
      [_write](buf) {
        fs2.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));
      }
      [_onwrite](er, bw) {
        if (er)
          this[_onerror](er);
        else {
          if (this[_pos] !== null)
            this[_pos] += bw;
          if (this[_queue].length)
            this[_flush]();
          else {
            this[_writing] = false;
            if (this[_ended] && !this[_finished]) {
              this[_finished] = true;
              this[_close]();
              this.emit("finish");
            } else if (this[_needDrain]) {
              this[_needDrain] = false;
              this.emit("drain");
            }
          }
        }
      }
      [_flush]() {
        if (this[_queue].length === 0) {
          if (this[_ended])
            this[_onwrite](null, 0);
        } else if (this[_queue].length === 1)
          this[_write](this[_queue].pop());
        else {
          const iovec = this[_queue];
          this[_queue] = [];
          writev(
            this[_fd],
            iovec,
            this[_pos],
            (er, bw) => this[_onwrite](er, bw)
          );
        }
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs2.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
        }
      }
    };
    var WriteStreamSync = class extends WriteStream {
      [_open]() {
        let fd;
        if (this[_defaultFlag] && this[_flags] === "r+") {
          try {
            fd = fs2.openSync(this[_path], this[_flags], this[_mode]);
          } catch (er) {
            if (er.code === "ENOENT") {
              this[_flags] = "w";
              return this[_open]();
            } else
              throw er;
          }
        } else
          fd = fs2.openSync(this[_path], this[_flags], this[_mode]);
        this[_onopen](null, fd);
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs2.closeSync(fd);
          this.emit("close");
        }
      }
      [_write](buf) {
        let threw = true;
        try {
          this[_onwrite](
            null,
            fs2.writeSync(this[_fd], buf, 0, buf.length, this[_pos])
          );
          threw = false;
        } finally {
          if (threw)
            try {
              this[_close]();
            } catch (_) {
            }
        }
      }
    };
    exports.ReadStream = ReadStream;
    exports.ReadStreamSync = ReadStreamSync;
    exports.WriteStream = WriteStream;
    exports.WriteStreamSync = WriteStreamSync;
  }
});

// node_modules/tar/lib/parse.js
var require_parse = __commonJS({
  "node_modules/tar/lib/parse.js"(exports, module2) {
    "use strict";
    var warner = require_warn_mixin();
    var Header = require_header();
    var EE = require("events");
    var Yallist = require_yallist();
    var maxMetaEntrySize = 1024 * 1024;
    var Entry = require_read_entry();
    var Pax = require_pax();
    var zlib = require_minizlib();
    var { nextTick } = require("process");
    var gzipHeader = Buffer.from([31, 139]);
    var STATE = Symbol("state");
    var WRITEENTRY = Symbol("writeEntry");
    var READENTRY = Symbol("readEntry");
    var NEXTENTRY = Symbol("nextEntry");
    var PROCESSENTRY = Symbol("processEntry");
    var EX = Symbol("extendedHeader");
    var GEX = Symbol("globalExtendedHeader");
    var META = Symbol("meta");
    var EMITMETA = Symbol("emitMeta");
    var BUFFER = Symbol("buffer");
    var QUEUE = Symbol("queue");
    var ENDED = Symbol("ended");
    var EMITTEDEND = Symbol("emittedEnd");
    var EMIT = Symbol("emit");
    var UNZIP = Symbol("unzip");
    var CONSUMECHUNK = Symbol("consumeChunk");
    var CONSUMECHUNKSUB = Symbol("consumeChunkSub");
    var CONSUMEBODY = Symbol("consumeBody");
    var CONSUMEMETA = Symbol("consumeMeta");
    var CONSUMEHEADER = Symbol("consumeHeader");
    var CONSUMING = Symbol("consuming");
    var BUFFERCONCAT = Symbol("bufferConcat");
    var MAYBEEND = Symbol("maybeEnd");
    var WRITING = Symbol("writing");
    var ABORTED = Symbol("aborted");
    var DONE = Symbol("onDone");
    var SAW_VALID_ENTRY = Symbol("sawValidEntry");
    var SAW_NULL_BLOCK = Symbol("sawNullBlock");
    var SAW_EOF = Symbol("sawEOF");
    var CLOSESTREAM = Symbol("closeStream");
    var noop2 = (_) => true;
    module2.exports = warner(class Parser extends EE {
      constructor(opt) {
        opt = opt || {};
        super(opt);
        this.file = opt.file || "";
        this[SAW_VALID_ENTRY] = null;
        this.on(DONE, (_) => {
          if (this[STATE] === "begin" || this[SAW_VALID_ENTRY] === false) {
            this.warn("TAR_BAD_ARCHIVE", "Unrecognized archive format");
          }
        });
        if (opt.ondone) {
          this.on(DONE, opt.ondone);
        } else {
          this.on(DONE, (_) => {
            this.emit("prefinish");
            this.emit("finish");
            this.emit("end");
          });
        }
        this.strict = !!opt.strict;
        this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;
        this.filter = typeof opt.filter === "function" ? opt.filter : noop2;
        const isTBR = opt.file && (opt.file.endsWith(".tar.br") || opt.file.endsWith(".tbr"));
        this.brotli = !opt.gzip && opt.brotli !== void 0 ? opt.brotli : isTBR ? void 0 : false;
        this.writable = true;
        this.readable = false;
        this[QUEUE] = new Yallist();
        this[BUFFER] = null;
        this[READENTRY] = null;
        this[WRITEENTRY] = null;
        this[STATE] = "begin";
        this[META] = "";
        this[EX] = null;
        this[GEX] = null;
        this[ENDED] = false;
        this[UNZIP] = null;
        this[ABORTED] = false;
        this[SAW_NULL_BLOCK] = false;
        this[SAW_EOF] = false;
        this.on("end", () => this[CLOSESTREAM]());
        if (typeof opt.onwarn === "function") {
          this.on("warn", opt.onwarn);
        }
        if (typeof opt.onentry === "function") {
          this.on("entry", opt.onentry);
        }
      }
      [CONSUMEHEADER](chunk, position) {
        if (this[SAW_VALID_ENTRY] === null) {
          this[SAW_VALID_ENTRY] = false;
        }
        let header;
        try {
          header = new Header(chunk, position, this[EX], this[GEX]);
        } catch (er) {
          return this.warn("TAR_ENTRY_INVALID", er);
        }
        if (header.nullBlock) {
          if (this[SAW_NULL_BLOCK]) {
            this[SAW_EOF] = true;
            if (this[STATE] === "begin") {
              this[STATE] = "header";
            }
            this[EMIT]("eof");
          } else {
            this[SAW_NULL_BLOCK] = true;
            this[EMIT]("nullBlock");
          }
        } else {
          this[SAW_NULL_BLOCK] = false;
          if (!header.cksumValid) {
            this.warn("TAR_ENTRY_INVALID", "checksum failure", { header });
          } else if (!header.path) {
            this.warn("TAR_ENTRY_INVALID", "path is required", { header });
          } else {
            const type = header.type;
            if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) {
              this.warn("TAR_ENTRY_INVALID", "linkpath required", { header });
            } else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath) {
              this.warn("TAR_ENTRY_INVALID", "linkpath forbidden", { header });
            } else {
              const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX]);
              if (!this[SAW_VALID_ENTRY]) {
                if (entry.remain) {
                  const onend = () => {
                    if (!entry.invalid) {
                      this[SAW_VALID_ENTRY] = true;
                    }
                  };
                  entry.on("end", onend);
                } else {
                  this[SAW_VALID_ENTRY] = true;
                }
              }
              if (entry.meta) {
                if (entry.size > this.maxMetaEntrySize) {
                  entry.ignore = true;
                  this[EMIT]("ignoredEntry", entry);
                  this[STATE] = "ignore";
                  entry.resume();
                } else if (entry.size > 0) {
                  this[META] = "";
                  entry.on("data", (c) => this[META] += c);
                  this[STATE] = "meta";
                }
              } else {
                this[EX] = null;
                entry.ignore = entry.ignore || !this.filter(entry.path, entry);
                if (entry.ignore) {
                  this[EMIT]("ignoredEntry", entry);
                  this[STATE] = entry.remain ? "ignore" : "header";
                  entry.resume();
                } else {
                  if (entry.remain) {
                    this[STATE] = "body";
                  } else {
                    this[STATE] = "header";
                    entry.end();
                  }
                  if (!this[READENTRY]) {
                    this[QUEUE].push(entry);
                    this[NEXTENTRY]();
                  } else {
                    this[QUEUE].push(entry);
                  }
                }
              }
            }
          }
        }
      }
      [CLOSESTREAM]() {
        nextTick(() => this.emit("close"));
      }
      [PROCESSENTRY](entry) {
        let go = true;
        if (!entry) {
          this[READENTRY] = null;
          go = false;
        } else if (Array.isArray(entry)) {
          this.emit.apply(this, entry);
        } else {
          this[READENTRY] = entry;
          this.emit("entry", entry);
          if (!entry.emittedEnd) {
            entry.on("end", (_) => this[NEXTENTRY]());
            go = false;
          }
        }
        return go;
      }
      [NEXTENTRY]() {
        do {
        } while (this[PROCESSENTRY](this[QUEUE].shift()));
        if (!this[QUEUE].length) {
          const re = this[READENTRY];
          const drainNow = !re || re.flowing || re.size === re.remain;
          if (drainNow) {
            if (!this[WRITING]) {
              this.emit("drain");
            }
          } else {
            re.once("drain", (_) => this.emit("drain"));
          }
        }
      }
      [CONSUMEBODY](chunk, position) {
        const entry = this[WRITEENTRY];
        const br = entry.blockRemain;
        const c = br >= chunk.length && position === 0 ? chunk : chunk.slice(position, position + br);
        entry.write(c);
        if (!entry.blockRemain) {
          this[STATE] = "header";
          this[WRITEENTRY] = null;
          entry.end();
        }
        return c.length;
      }
      [CONSUMEMETA](chunk, position) {
        const entry = this[WRITEENTRY];
        const ret = this[CONSUMEBODY](chunk, position);
        if (!this[WRITEENTRY]) {
          this[EMITMETA](entry);
        }
        return ret;
      }
      [EMIT](ev, data, extra) {
        if (!this[QUEUE].length && !this[READENTRY]) {
          this.emit(ev, data, extra);
        } else {
          this[QUEUE].push([ev, data, extra]);
        }
      }
      [EMITMETA](entry) {
        this[EMIT]("meta", this[META]);
        switch (entry.type) {
          case "ExtendedHeader":
          case "OldExtendedHeader":
            this[EX] = Pax.parse(this[META], this[EX], false);
            break;
          case "GlobalExtendedHeader":
            this[GEX] = Pax.parse(this[META], this[GEX], true);
            break;
          case "NextFileHasLongPath":
          case "OldGnuLongPath":
            this[EX] = this[EX] || /* @__PURE__ */ Object.create(null);
            this[EX].path = this[META].replace(/\0.*/, "");
            break;
          case "NextFileHasLongLinkpath":
            this[EX] = this[EX] || /* @__PURE__ */ Object.create(null);
            this[EX].linkpath = this[META].replace(/\0.*/, "");
            break;
          default:
            throw new Error("unknown meta: " + entry.type);
        }
      }
      abort(error) {
        this[ABORTED] = true;
        this.emit("abort", error);
        this.warn("TAR_ABORT", error, { recoverable: false });
      }
      write(chunk) {
        if (this[ABORTED]) {
          return;
        }
        const needSniff = this[UNZIP] === null || this.brotli === void 0 && this[UNZIP] === false;
        if (needSniff && chunk) {
          if (this[BUFFER]) {
            chunk = Buffer.concat([this[BUFFER], chunk]);
            this[BUFFER] = null;
          }
          if (chunk.length < gzipHeader.length) {
            this[BUFFER] = chunk;
            return true;
          }
          for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {
            if (chunk[i] !== gzipHeader[i]) {
              this[UNZIP] = false;
            }
          }
          const maybeBrotli = this.brotli === void 0;
          if (this[UNZIP] === false && maybeBrotli) {
            if (chunk.length < 512) {
              if (this[ENDED]) {
                this.brotli = true;
              } else {
                this[BUFFER] = chunk;
                return true;
              }
            } else {
              try {
                new Header(chunk.slice(0, 512));
                this.brotli = false;
              } catch (_) {
                this.brotli = true;
              }
            }
          }
          if (this[UNZIP] === null || this[UNZIP] === false && this.brotli) {
            const ended = this[ENDED];
            this[ENDED] = false;
            this[UNZIP] = this[UNZIP] === null ? new zlib.Unzip() : new zlib.BrotliDecompress();
            this[UNZIP].on("data", (chunk2) => this[CONSUMECHUNK](chunk2));
            this[UNZIP].on("error", (er) => this.abort(er));
            this[UNZIP].on("end", (_) => {
              this[ENDED] = true;
              this[CONSUMECHUNK]();
            });
            this[WRITING] = true;
            const ret2 = this[UNZIP][ended ? "end" : "write"](chunk);
            this[WRITING] = false;
            return ret2;
          }
        }
        this[WRITING] = true;
        if (this[UNZIP]) {
          this[UNZIP].write(chunk);
        } else {
          this[CONSUMECHUNK](chunk);
        }
        this[WRITING] = false;
        const ret = this[QUEUE].length ? false : this[READENTRY] ? this[READENTRY].flowing : true;
        if (!ret && !this[QUEUE].length) {
          this[READENTRY].once("drain", (_) => this.emit("drain"));
        }
        return ret;
      }
      [BUFFERCONCAT](c) {
        if (c && !this[ABORTED]) {
          this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;
        }
      }
      [MAYBEEND]() {
        if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED] && !this[CONSUMING]) {
          this[EMITTEDEND] = true;
          const entry = this[WRITEENTRY];
          if (entry && entry.blockRemain) {
            const have = this[BUFFER] ? this[BUFFER].length : 0;
            this.warn("TAR_BAD_ARCHIVE", `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, { entry });
            if (this[BUFFER]) {
              entry.write(this[BUFFER]);
            }
            entry.end();
          }
          this[EMIT](DONE);
        }
      }
      [CONSUMECHUNK](chunk) {
        if (this[CONSUMING]) {
          this[BUFFERCONCAT](chunk);
        } else if (!chunk && !this[BUFFER]) {
          this[MAYBEEND]();
        } else {
          this[CONSUMING] = true;
          if (this[BUFFER]) {
            this[BUFFERCONCAT](chunk);
            const c = this[BUFFER];
            this[BUFFER] = null;
            this[CONSUMECHUNKSUB](c);
          } else {
            this[CONSUMECHUNKSUB](chunk);
          }
          while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED] && !this[SAW_EOF]) {
            const c = this[BUFFER];
            this[BUFFER] = null;
            this[CONSUMECHUNKSUB](c);
          }
          this[CONSUMING] = false;
        }
        if (!this[BUFFER] || this[ENDED]) {
          this[MAYBEEND]();
        }
      }
      [CONSUMECHUNKSUB](chunk) {
        let position = 0;
        const length = chunk.length;
        while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {
          switch (this[STATE]) {
            case "begin":
            case "header":
              this[CONSUMEHEADER](chunk, position);
              position += 512;
              break;
            case "ignore":
            case "body":
              position += this[CONSUMEBODY](chunk, position);
              break;
            case "meta":
              position += this[CONSUMEMETA](chunk, position);
              break;
            default:
              throw new Error("invalid state: " + this[STATE]);
          }
        }
        if (position < length) {
          if (this[BUFFER]) {
            this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]]);
          } else {
            this[BUFFER] = chunk.slice(position);
          }
        }
      }
      end(chunk) {
        if (!this[ABORTED]) {
          if (this[UNZIP]) {
            this[UNZIP].end(chunk);
          } else {
            this[ENDED] = true;
            if (this.brotli === void 0)
              chunk = chunk || Buffer.alloc(0);
            this.write(chunk);
          }
        }
      }
    });
  }
});

// node_modules/tar/lib/list.js
var require_list = __commonJS({
  "node_modules/tar/lib/list.js"(exports, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Parser = require_parse();
    var fs2 = require("fs");
    var fsm = require_fs_minipass();
    var path6 = require("path");
    var stripSlash = require_strip_trailing_slashes();
    module2.exports = (opt_, files, cb) => {
      if (typeof opt_ === "function") {
        cb = opt_, files = null, opt_ = {};
      } else if (Array.isArray(opt_)) {
        files = opt_, opt_ = {};
      }
      if (typeof files === "function") {
        cb = files, files = null;
      }
      if (!files) {
        files = [];
      } else {
        files = Array.from(files);
      }
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function") {
        throw new TypeError("callback not supported for sync tar functions");
      }
      if (!opt.file && typeof cb === "function") {
        throw new TypeError("callback only supported with file option");
      }
      if (files.length) {
        filesFilter(opt, files);
      }
      if (!opt.noResume) {
        onentryFunction(opt);
      }
      return opt.file && opt.sync ? listFileSync(opt) : opt.file ? listFile(opt, cb) : list(opt);
    };
    var onentryFunction = (opt) => {
      const onentry = opt.onentry;
      opt.onentry = onentry ? (e) => {
        onentry(e);
        e.resume();
      } : (e) => e.resume();
    };
    var filesFilter = (opt, files) => {
      const map = new Map(files.map((f) => [stripSlash(f), true]));
      const filter = opt.filter;
      const mapHas = (file, r) => {
        const root = r || path6.parse(file).root || ".";
        const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path6.dirname(file), root);
        map.set(file, ret);
        return ret;
      };
      opt.filter = filter ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
    };
    var listFileSync = (opt) => {
      const p = list(opt);
      const file = opt.file;
      let threw = true;
      let fd;
      try {
        const stat = fs2.statSync(file);
        const readSize = opt.maxReadSize || 16 * 1024 * 1024;
        if (stat.size < readSize) {
          p.end(fs2.readFileSync(file));
        } else {
          let pos = 0;
          const buf = Buffer.allocUnsafe(readSize);
          fd = fs2.openSync(file, "r");
          while (pos < stat.size) {
            const bytesRead = fs2.readSync(fd, buf, 0, readSize, pos);
            pos += bytesRead;
            p.write(buf.slice(0, bytesRead));
          }
          p.end();
        }
        threw = false;
      } finally {
        if (threw && fd) {
          try {
            fs2.closeSync(fd);
          } catch (er) {
          }
        }
      }
    };
    var listFile = (opt, cb) => {
      const parse2 = new Parser(opt);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const file = opt.file;
      const p = new Promise((resolve2, reject) => {
        parse2.on("error", reject);
        parse2.on("end", resolve2);
        fs2.stat(file, (er, stat) => {
          if (er) {
            reject(er);
          } else {
            const stream = new fsm.ReadStream(file, {
              readSize,
              size: stat.size
            });
            stream.on("error", reject);
            stream.pipe(parse2);
          }
        });
      });
      return cb ? p.then(cb, cb) : p;
    };
    var list = (opt) => new Parser(opt);
  }
});

// node_modules/tar/lib/create.js
var require_create = __commonJS({
  "node_modules/tar/lib/create.js"(exports, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Pack = require_pack();
    var fsm = require_fs_minipass();
    var t = require_list();
    var path6 = require("path");
    module2.exports = (opt_, files, cb) => {
      if (typeof files === "function") {
        cb = files;
      }
      if (Array.isArray(opt_)) {
        files = opt_, opt_ = {};
      }
      if (!files || !Array.isArray(files) || !files.length) {
        throw new TypeError("no files or directories specified");
      }
      files = Array.from(files);
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function") {
        throw new TypeError("callback not supported for sync tar functions");
      }
      if (!opt.file && typeof cb === "function") {
        throw new TypeError("callback only supported with file option");
      }
      return opt.file && opt.sync ? createFileSync(opt, files) : opt.file ? createFile(opt, files, cb) : opt.sync ? createSync(opt, files) : create(opt, files);
    };
    var createFileSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      const stream = new fsm.WriteStreamSync(opt.file, {
        mode: opt.mode || 438
      });
      p.pipe(stream);
      addFilesSync(p, files);
    };
    var createFile = (opt, files, cb) => {
      const p = new Pack(opt);
      const stream = new fsm.WriteStream(opt.file, {
        mode: opt.mode || 438
      });
      p.pipe(stream);
      const promise = new Promise((res, rej) => {
        stream.on("error", rej);
        stream.on("close", res);
        p.on("error", rej);
      });
      addFilesAsync(p, files);
      return cb ? promise.then(cb, cb) : promise;
    };
    var addFilesSync = (p, files) => {
      files.forEach((file) => {
        if (file.charAt(0) === "@") {
          t({
            file: path6.resolve(p.cwd, file.slice(1)),
            sync: true,
            noResume: true,
            onentry: (entry) => p.add(entry)
          });
        } else {
          p.add(file);
        }
      });
      p.end();
    };
    var addFilesAsync = (p, files) => {
      while (files.length) {
        const file = files.shift();
        if (file.charAt(0) === "@") {
          return t({
            file: path6.resolve(p.cwd, file.slice(1)),
            noResume: true,
            onentry: (entry) => p.add(entry)
          }).then((_) => addFilesAsync(p, files));
        } else {
          p.add(file);
        }
      }
      p.end();
    };
    var createSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      addFilesSync(p, files);
      return p;
    };
    var create = (opt, files) => {
      const p = new Pack(opt);
      addFilesAsync(p, files);
      return p;
    };
  }
});

// node_modules/tar/lib/replace.js
var require_replace = __commonJS({
  "node_modules/tar/lib/replace.js"(exports, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Pack = require_pack();
    var fs2 = require("fs");
    var fsm = require_fs_minipass();
    var t = require_list();
    var path6 = require("path");
    var Header = require_header();
    module2.exports = (opt_, files, cb) => {
      const opt = hlo(opt_);
      if (!opt.file) {
        throw new TypeError("file is required");
      }
      if (opt.gzip || opt.brotli || opt.file.endsWith(".br") || opt.file.endsWith(".tbr")) {
        throw new TypeError("cannot append to compressed archives");
      }
      if (!files || !Array.isArray(files) || !files.length) {
        throw new TypeError("no files or directories specified");
      }
      files = Array.from(files);
      return opt.sync ? replaceSync(opt, files) : replace(opt, files, cb);
    };
    var replaceSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      let threw = true;
      let fd;
      let position;
      try {
        try {
          fd = fs2.openSync(opt.file, "r+");
        } catch (er) {
          if (er.code === "ENOENT") {
            fd = fs2.openSync(opt.file, "w+");
          } else {
            throw er;
          }
        }
        const st = fs2.fstatSync(fd);
        const headBuf = Buffer.alloc(512);
        POSITION:
          for (position = 0; position < st.size; position += 512) {
            for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {
              bytes = fs2.readSync(
                fd,
                headBuf,
                bufPos,
                headBuf.length - bufPos,
                position + bufPos
              );
              if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139) {
                throw new Error("cannot append to compressed archives");
              }
              if (!bytes) {
                break POSITION;
              }
            }
            const h = new Header(headBuf);
            if (!h.cksumValid) {
              break;
            }
            const entryBlockSize = 512 * Math.ceil(h.size / 512);
            if (position + entryBlockSize + 512 > st.size) {
              break;
            }
            position += entryBlockSize;
            if (opt.mtimeCache) {
              opt.mtimeCache.set(h.path, h.mtime);
            }
          }
        threw = false;
        streamSync(opt, p, position, fd, files);
      } finally {
        if (threw) {
          try {
            fs2.closeSync(fd);
          } catch (er) {
          }
        }
      }
    };
    var streamSync = (opt, p, position, fd, files) => {
      const stream = new fsm.WriteStreamSync(opt.file, {
        fd,
        start: position
      });
      p.pipe(stream);
      addFilesSync(p, files);
    };
    var replace = (opt, files, cb) => {
      files = Array.from(files);
      const p = new Pack(opt);
      const getPos = (fd, size, cb_) => {
        const cb2 = (er, pos) => {
          if (er) {
            fs2.close(fd, (_) => cb_(er));
          } else {
            cb_(null, pos);
          }
        };
        let position = 0;
        if (size === 0) {
          return cb2(null, 0);
        }
        let bufPos = 0;
        const headBuf = Buffer.alloc(512);
        const onread = (er, bytes) => {
          if (er) {
            return cb2(er);
          }
          bufPos += bytes;
          if (bufPos < 512 && bytes) {
            return fs2.read(
              fd,
              headBuf,
              bufPos,
              headBuf.length - bufPos,
              position + bufPos,
              onread
            );
          }
          if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139) {
            return cb2(new Error("cannot append to compressed archives"));
          }
          if (bufPos < 512) {
            return cb2(null, position);
          }
          const h = new Header(headBuf);
          if (!h.cksumValid) {
            return cb2(null, position);
          }
          const entryBlockSize = 512 * Math.ceil(h.size / 512);
          if (position + entryBlockSize + 512 > size) {
            return cb2(null, position);
          }
          position += entryBlockSize + 512;
          if (position >= size) {
            return cb2(null, position);
          }
          if (opt.mtimeCache) {
            opt.mtimeCache.set(h.path, h.mtime);
          }
          bufPos = 0;
          fs2.read(fd, headBuf, 0, 512, position, onread);
        };
        fs2.read(fd, headBuf, 0, 512, position, onread);
      };
      const promise = new Promise((resolve2, reject) => {
        p.on("error", reject);
        let flag = "r+";
        const onopen = (er, fd) => {
          if (er && er.code === "ENOENT" && flag === "r+") {
            flag = "w+";
            return fs2.open(opt.file, flag, onopen);
          }
          if (er) {
            return reject(er);
          }
          fs2.fstat(fd, (er2, st) => {
            if (er2) {
              return fs2.close(fd, () => reject(er2));
            }
            getPos(fd, st.size, (er3, position) => {
              if (er3) {
                return reject(er3);
              }
              const stream = new fsm.WriteStream(opt.file, {
                fd,
                start: position
              });
              p.pipe(stream);
              stream.on("error", reject);
              stream.on("close", resolve2);
              addFilesAsync(p, files);
            });
          });
        };
        fs2.open(opt.file, flag, onopen);
      });
      return cb ? promise.then(cb, cb) : promise;
    };
    var addFilesSync = (p, files) => {
      files.forEach((file) => {
        if (file.charAt(0) === "@") {
          t({
            file: path6.resolve(p.cwd, file.slice(1)),
            sync: true,
            noResume: true,
            onentry: (entry) => p.add(entry)
          });
        } else {
          p.add(file);
        }
      });
      p.end();
    };
    var addFilesAsync = (p, files) => {
      while (files.length) {
        const file = files.shift();
        if (file.charAt(0) === "@") {
          return t({
            file: path6.resolve(p.cwd, file.slice(1)),
            noResume: true,
            onentry: (entry) => p.add(entry)
          }).then((_) => addFilesAsync(p, files));
        } else {
          p.add(file);
        }
      }
      p.end();
    };
  }
});

// node_modules/tar/lib/update.js
var require_update = __commonJS({
  "node_modules/tar/lib/update.js"(exports, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var r = require_replace();
    module2.exports = (opt_, files, cb) => {
      const opt = hlo(opt_);
      if (!opt.file) {
        throw new TypeError("file is required");
      }
      if (opt.gzip || opt.brotli || opt.file.endsWith(".br") || opt.file.endsWith(".tbr")) {
        throw new TypeError("cannot append to compressed archives");
      }
      if (!files || !Array.isArray(files) || !files.length) {
        throw new TypeError("no files or directories specified");
      }
      files = Array.from(files);
      mtimeFilter(opt);
      return r(opt, files, cb);
    };
    var mtimeFilter = (opt) => {
      const filter = opt.filter;
      if (!opt.mtimeCache) {
        opt.mtimeCache = /* @__PURE__ */ new Map();
      }
      opt.filter = filter ? (path6, stat) => filter(path6, stat) && !(opt.mtimeCache.get(path6) > stat.mtime) : (path6, stat) => !(opt.mtimeCache.get(path6) > stat.mtime);
    };
  }
});

// node_modules/mkdirp/lib/opts-arg.js
var require_opts_arg = __commonJS({
  "node_modules/mkdirp/lib/opts-arg.js"(exports, module2) {
    var { promisify: promisify2 } = require("util");
    var fs2 = require("fs");
    var optsArg = (opts) => {
      if (!opts)
        opts = { mode: 511, fs: fs2 };
      else if (typeof opts === "object")
        opts = { mode: 511, fs: fs2, ...opts };
      else if (typeof opts === "number")
        opts = { mode: opts, fs: fs2 };
      else if (typeof opts === "string")
        opts = { mode: parseInt(opts, 8), fs: fs2 };
      else
        throw new TypeError("invalid options argument");
      opts.mkdir = opts.mkdir || opts.fs.mkdir || fs2.mkdir;
      opts.mkdirAsync = promisify2(opts.mkdir);
      opts.stat = opts.stat || opts.fs.stat || fs2.stat;
      opts.statAsync = promisify2(opts.stat);
      opts.statSync = opts.statSync || opts.fs.statSync || fs2.statSync;
      opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs2.mkdirSync;
      return opts;
    };
    module2.exports = optsArg;
  }
});

// node_modules/mkdirp/lib/path-arg.js
var require_path_arg = __commonJS({
  "node_modules/mkdirp/lib/path-arg.js"(exports, module2) {
    var platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
    var { resolve: resolve2, parse: parse2 } = require("path");
    var pathArg = (path6) => {
      if (/\0/.test(path6)) {
        throw Object.assign(
          new TypeError("path must be a string without null bytes"),
          {
            path: path6,
            code: "ERR_INVALID_ARG_VALUE"
          }
        );
      }
      path6 = resolve2(path6);
      if (platform === "win32") {
        const badWinChars = /[*|"<>?:]/;
        const { root } = parse2(path6);
        if (badWinChars.test(path6.substr(root.length))) {
          throw Object.assign(new Error("Illegal characters in path."), {
            path: path6,
            code: "EINVAL"
          });
        }
      }
      return path6;
    };
    module2.exports = pathArg;
  }
});

// node_modules/mkdirp/lib/find-made.js
var require_find_made = __commonJS({
  "node_modules/mkdirp/lib/find-made.js"(exports, module2) {
    var { dirname: dirname2 } = require("path");
    var findMade = (opts, parent, path6 = void 0) => {
      if (path6 === parent)
        return Promise.resolve();
      return opts.statAsync(parent).then(
        (st) => st.isDirectory() ? path6 : void 0,
        // will fail later
        (er) => er.code === "ENOENT" ? findMade(opts, dirname2(parent), parent) : void 0
      );
    };
    var findMadeSync = (opts, parent, path6 = void 0) => {
      if (path6 === parent)
        return void 0;
      try {
        return opts.statSync(parent).isDirectory() ? path6 : void 0;
      } catch (er) {
        return er.code === "ENOENT" ? findMadeSync(opts, dirname2(parent), parent) : void 0;
      }
    };
    module2.exports = { findMade, findMadeSync };
  }
});

// node_modules/mkdirp/lib/mkdirp-manual.js
var require_mkdirp_manual = __commonJS({
  "node_modules/mkdirp/lib/mkdirp-manual.js"(exports, module2) {
    var { dirname: dirname2 } = require("path");
    var mkdirpManual = (path6, opts, made) => {
      opts.recursive = false;
      const parent = dirname2(path6);
      if (parent === path6) {
        return opts.mkdirAsync(path6, opts).catch((er) => {
          if (er.code !== "EISDIR")
            throw er;
        });
      }
      return opts.mkdirAsync(path6, opts).then(() => made || path6, (er) => {
        if (er.code === "ENOENT")
          return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path6, opts, made2));
        if (er.code !== "EEXIST" && er.code !== "EROFS")
          throw er;
        return opts.statAsync(path6).then((st) => {
          if (st.isDirectory())
            return made;
          else
            throw er;
        }, () => {
          throw er;
        });
      });
    };
    var mkdirpManualSync = (path6, opts, made) => {
      const parent = dirname2(path6);
      opts.recursive = false;
      if (parent === path6) {
        try {
          return opts.mkdirSync(path6, opts);
        } catch (er) {
          if (er.code !== "EISDIR")
            throw er;
          else
            return;
        }
      }
      try {
        opts.mkdirSync(path6, opts);
        return made || path6;
      } catch (er) {
        if (er.code === "ENOENT")
          return mkdirpManualSync(path6, opts, mkdirpManualSync(parent, opts, made));
        if (er.code !== "EEXIST" && er.code !== "EROFS")
          throw er;
        try {
          if (!opts.statSync(path6).isDirectory())
            throw er;
        } catch (_) {
          throw er;
        }
      }
    };
    module2.exports = { mkdirpManual, mkdirpManualSync };
  }
});

// node_modules/mkdirp/lib/mkdirp-native.js
var require_mkdirp_native = __commonJS({
  "node_modules/mkdirp/lib/mkdirp-native.js"(exports, module2) {
    var { dirname: dirname2 } = require("path");
    var { findMade, findMadeSync } = require_find_made();
    var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
    var mkdirpNative = (path6, opts) => {
      opts.recursive = true;
      const parent = dirname2(path6);
      if (parent === path6)
        return opts.mkdirAsync(path6, opts);
      return findMade(opts, path6).then((made) => opts.mkdirAsync(path6, opts).then(() => made).catch((er) => {
        if (er.code === "ENOENT")
          return mkdirpManual(path6, opts);
        else
          throw er;
      }));
    };
    var mkdirpNativeSync = (path6, opts) => {
      opts.recursive = true;
      const parent = dirname2(path6);
      if (parent === path6)
        return opts.mkdirSync(path6, opts);
      const made = findMadeSync(opts, path6);
      try {
        opts.mkdirSync(path6, opts);
        return made;
      } catch (er) {
        if (er.code === "ENOENT")
          return mkdirpManualSync(path6, opts);
        else
          throw er;
      }
    };
    module2.exports = { mkdirpNative, mkdirpNativeSync };
  }
});

// node_modules/mkdirp/lib/use-native.js
var require_use_native = __commonJS({
  "node_modules/mkdirp/lib/use-native.js"(exports, module2) {
    var fs2 = require("fs");
    var version2 = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
    var versArr = version2.replace(/^v/, "").split(".");
    var hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
    var useNative = !hasNative ? () => false : (opts) => opts.mkdir === fs2.mkdir;
    var useNativeSync = !hasNative ? () => false : (opts) => opts.mkdirSync === fs2.mkdirSync;
    module2.exports = { useNative, useNativeSync };
  }
});

// node_modules/mkdirp/index.js
var require_mkdirp = __commonJS({
  "node_modules/mkdirp/index.js"(exports, module2) {
    var optsArg = require_opts_arg();
    var pathArg = require_path_arg();
    var { mkdirpNative, mkdirpNativeSync } = require_mkdirp_native();
    var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
    var { useNative, useNativeSync } = require_use_native();
    var mkdirp2 = (path6, opts) => {
      path6 = pathArg(path6);
      opts = optsArg(opts);
      return useNative(opts) ? mkdirpNative(path6, opts) : mkdirpManual(path6, opts);
    };
    var mkdirpSync = (path6, opts) => {
      path6 = pathArg(path6);
      opts = optsArg(opts);
      return useNativeSync(opts) ? mkdirpNativeSync(path6, opts) : mkdirpManualSync(path6, opts);
    };
    mkdirp2.sync = mkdirpSync;
    mkdirp2.native = (path6, opts) => mkdirpNative(pathArg(path6), optsArg(opts));
    mkdirp2.manual = (path6, opts) => mkdirpManual(pathArg(path6), optsArg(opts));
    mkdirp2.nativeSync = (path6, opts) => mkdirpNativeSync(pathArg(path6), optsArg(opts));
    mkdirp2.manualSync = (path6, opts) => mkdirpManualSync(pathArg(path6), optsArg(opts));
    module2.exports = mkdirp2;
  }
});

// node_modules/chownr/chownr.js
var require_chownr = __commonJS({
  "node_modules/chownr/chownr.js"(exports, module2) {
    "use strict";
    var fs2 = require("fs");
    var path6 = require("path");
    var LCHOWN = fs2.lchown ? "lchown" : "chown";
    var LCHOWNSYNC = fs2.lchownSync ? "lchownSync" : "chownSync";
    var needEISDIRHandled = fs2.lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/);
    var lchownSync = (path7, uid, gid) => {
      try {
        return fs2[LCHOWNSYNC](path7, uid, gid);
      } catch (er) {
        if (er.code !== "ENOENT")
          throw er;
      }
    };
    var chownSync = (path7, uid, gid) => {
      try {
        return fs2.chownSync(path7, uid, gid);
      } catch (er) {
        if (er.code !== "ENOENT")
          throw er;
      }
    };
    var handleEISDIR = needEISDIRHandled ? (path7, uid, gid, cb) => (er) => {
      if (!er || er.code !== "EISDIR")
        cb(er);
      else
        fs2.chown(path7, uid, gid, cb);
    } : (_, __, ___, cb) => cb;
    var handleEISDirSync = needEISDIRHandled ? (path7, uid, gid) => {
      try {
        return lchownSync(path7, uid, gid);
      } catch (er) {
        if (er.code !== "EISDIR")
          throw er;
        chownSync(path7, uid, gid);
      }
    } : (path7, uid, gid) => lchownSync(path7, uid, gid);
    var nodeVersion = process.version;
    var readdir = (path7, options, cb) => fs2.readdir(path7, options, cb);
    var readdirSync2 = (path7, options) => fs2.readdirSync(path7, options);
    if (/^v4\./.test(nodeVersion))
      readdir = (path7, options, cb) => fs2.readdir(path7, cb);
    var chown = (cpath, uid, gid, cb) => {
      fs2[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, (er) => {
        cb(er && er.code !== "ENOENT" ? er : null);
      }));
    };
    var chownrKid = (p, child, uid, gid, cb) => {
      if (typeof child === "string")
        return fs2.lstat(path6.resolve(p, child), (er, stats) => {
          if (er)
            return cb(er.code !== "ENOENT" ? er : null);
          stats.name = child;
          chownrKid(p, stats, uid, gid, cb);
        });
      if (child.isDirectory()) {
        chownr(path6.resolve(p, child.name), uid, gid, (er) => {
          if (er)
            return cb(er);
          const cpath = path6.resolve(p, child.name);
          chown(cpath, uid, gid, cb);
        });
      } else {
        const cpath = path6.resolve(p, child.name);
        chown(cpath, uid, gid, cb);
      }
    };
    var chownr = (p, uid, gid, cb) => {
      readdir(p, { withFileTypes: true }, (er, children) => {
        if (er) {
          if (er.code === "ENOENT")
            return cb();
          else if (er.code !== "ENOTDIR" && er.code !== "ENOTSUP")
            return cb(er);
        }
        if (er || !children.length)
          return chown(p, uid, gid, cb);
        let len = children.length;
        let errState = null;
        const then = (er2) => {
          if (errState)
            return;
          if (er2)
            return cb(errState = er2);
          if (--len === 0)
            return chown(p, uid, gid, cb);
        };
        children.forEach((child) => chownrKid(p, child, uid, gid, then));
      });
    };
    var chownrKidSync = (p, child, uid, gid) => {
      if (typeof child === "string") {
        try {
          const stats = fs2.lstatSync(path6.resolve(p, child));
          stats.name = child;
          child = stats;
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          else
            throw er;
        }
      }
      if (child.isDirectory())
        chownrSync(path6.resolve(p, child.name), uid, gid);
      handleEISDirSync(path6.resolve(p, child.name), uid, gid);
    };
    var chownrSync = (p, uid, gid) => {
      let children;
      try {
        children = readdirSync2(p, { withFileTypes: true });
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        else if (er.code === "ENOTDIR" || er.code === "ENOTSUP")
          return handleEISDirSync(p, uid, gid);
        else
          throw er;
      }
      if (children && children.length)
        children.forEach((child) => chownrKidSync(p, child, uid, gid));
      return handleEISDirSync(p, uid, gid);
    };
    module2.exports = chownr;
    chownr.sync = chownrSync;
  }
});

// node_modules/tar/lib/mkdir.js
var require_mkdir = __commonJS({
  "node_modules/tar/lib/mkdir.js"(exports, module2) {
    "use strict";
    var mkdirp2 = require_mkdirp();
    var fs2 = require("fs");
    var path6 = require("path");
    var chownr = require_chownr();
    var normPath = require_normalize_windows_path();
    var SymlinkError = class extends Error {
      constructor(symlink, path7) {
        super("Cannot extract through symbolic link");
        this.path = path7;
        this.symlink = symlink;
      }
      get name() {
        return "SylinkError";
      }
    };
    var CwdError = class extends Error {
      constructor(path7, code) {
        super(code + ": Cannot cd into '" + path7 + "'");
        this.path = path7;
        this.code = code;
      }
      get name() {
        return "CwdError";
      }
    };
    var cGet = (cache, key) => cache.get(normPath(key));
    var cSet = (cache, key, val) => cache.set(normPath(key), val);
    var checkCwd = (dir, cb) => {
      fs2.stat(dir, (er, st) => {
        if (er || !st.isDirectory()) {
          er = new CwdError(dir, er && er.code || "ENOTDIR");
        }
        cb(er);
      });
    };
    module2.exports = (dir, opt, cb) => {
      dir = normPath(dir);
      const umask = opt.umask;
      const mode = opt.mode | 448;
      const needChmod = (mode & umask) !== 0;
      const uid = opt.uid;
      const gid = opt.gid;
      const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
      const preserve = opt.preserve;
      const unlink = opt.unlink;
      const cache = opt.cache;
      const cwd2 = normPath(opt.cwd);
      const done = (er, created) => {
        if (er) {
          cb(er);
        } else {
          cSet(cache, dir, true);
          if (created && doChown) {
            chownr(created, uid, gid, (er2) => done(er2));
          } else if (needChmod) {
            fs2.chmod(dir, mode, cb);
          } else {
            cb();
          }
        }
      };
      if (cache && cGet(cache, dir) === true) {
        return done();
      }
      if (dir === cwd2) {
        return checkCwd(dir, done);
      }
      if (preserve) {
        return mkdirp2(dir, { mode }).then((made) => done(null, made), done);
      }
      const sub = normPath(path6.relative(cwd2, dir));
      const parts = sub.split("/");
      mkdir_(cwd2, parts, mode, cache, unlink, cwd2, null, done);
    };
    var mkdir_ = (base, parts, mode, cache, unlink, cwd2, created, cb) => {
      if (!parts.length) {
        return cb(null, created);
      }
      const p = parts.shift();
      const part = normPath(path6.resolve(base + "/" + p));
      if (cGet(cache, part)) {
        return mkdir_(part, parts, mode, cache, unlink, cwd2, created, cb);
      }
      fs2.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd2, created, cb));
    };
    var onmkdir = (part, parts, mode, cache, unlink, cwd2, created, cb) => (er) => {
      if (er) {
        fs2.lstat(part, (statEr, st) => {
          if (statEr) {
            statEr.path = statEr.path && normPath(statEr.path);
            cb(statEr);
          } else if (st.isDirectory()) {
            mkdir_(part, parts, mode, cache, unlink, cwd2, created, cb);
          } else if (unlink) {
            fs2.unlink(part, (er2) => {
              if (er2) {
                return cb(er2);
              }
              fs2.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd2, created, cb));
            });
          } else if (st.isSymbolicLink()) {
            return cb(new SymlinkError(part, part + "/" + parts.join("/")));
          } else {
            cb(er);
          }
        });
      } else {
        created = created || part;
        mkdir_(part, parts, mode, cache, unlink, cwd2, created, cb);
      }
    };
    var checkCwdSync = (dir) => {
      let ok = false;
      let code = "ENOTDIR";
      try {
        ok = fs2.statSync(dir).isDirectory();
      } catch (er) {
        code = er.code;
      } finally {
        if (!ok) {
          throw new CwdError(dir, code);
        }
      }
    };
    module2.exports.sync = (dir, opt) => {
      dir = normPath(dir);
      const umask = opt.umask;
      const mode = opt.mode | 448;
      const needChmod = (mode & umask) !== 0;
      const uid = opt.uid;
      const gid = opt.gid;
      const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
      const preserve = opt.preserve;
      const unlink = opt.unlink;
      const cache = opt.cache;
      const cwd2 = normPath(opt.cwd);
      const done = (created2) => {
        cSet(cache, dir, true);
        if (created2 && doChown) {
          chownr.sync(created2, uid, gid);
        }
        if (needChmod) {
          fs2.chmodSync(dir, mode);
        }
      };
      if (cache && cGet(cache, dir) === true) {
        return done();
      }
      if (dir === cwd2) {
        checkCwdSync(cwd2);
        return done();
      }
      if (preserve) {
        return done(mkdirp2.sync(dir, mode));
      }
      const sub = normPath(path6.relative(cwd2, dir));
      const parts = sub.split("/");
      let created = null;
      for (let p = parts.shift(), part = cwd2; p && (part += "/" + p); p = parts.shift()) {
        part = normPath(path6.resolve(part));
        if (cGet(cache, part)) {
          continue;
        }
        try {
          fs2.mkdirSync(part, mode);
          created = created || part;
          cSet(cache, part, true);
        } catch (er) {
          const st = fs2.lstatSync(part);
          if (st.isDirectory()) {
            cSet(cache, part, true);
            continue;
          } else if (unlink) {
            fs2.unlinkSync(part);
            fs2.mkdirSync(part, mode);
            created = created || part;
            cSet(cache, part, true);
            continue;
          } else if (st.isSymbolicLink()) {
            return new SymlinkError(part, part + "/" + parts.join("/"));
          }
        }
      }
      return done(created);
    };
  }
});

// node_modules/tar/lib/normalize-unicode.js
var require_normalize_unicode = __commonJS({
  "node_modules/tar/lib/normalize-unicode.js"(exports, module2) {
    var normalizeCache = /* @__PURE__ */ Object.create(null);
    var { hasOwnProperty } = Object.prototype;
    module2.exports = (s) => {
      if (!hasOwnProperty.call(normalizeCache, s)) {
        normalizeCache[s] = s.normalize("NFD");
      }
      return normalizeCache[s];
    };
  }
});

// node_modules/tar/lib/path-reservations.js
var require_path_reservations = __commonJS({
  "node_modules/tar/lib/path-reservations.js"(exports, module2) {
    var assert = require("assert");
    var normalize2 = require_normalize_unicode();
    var stripSlashes = require_strip_trailing_slashes();
    var { join: join3 } = require("path");
    var platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    var isWindows = platform === "win32";
    module2.exports = () => {
      const queues = /* @__PURE__ */ new Map();
      const reservations = /* @__PURE__ */ new Map();
      const getDirs = (path6) => {
        const dirs = path6.split("/").slice(0, -1).reduce((set, path7) => {
          if (set.length) {
            path7 = join3(set[set.length - 1], path7);
          }
          set.push(path7 || "/");
          return set;
        }, []);
        return dirs;
      };
      const running = /* @__PURE__ */ new Set();
      const getQueues = (fn) => {
        const res = reservations.get(fn);
        if (!res) {
          throw new Error("function does not have any path reservations");
        }
        return {
          paths: res.paths.map((path6) => queues.get(path6)),
          dirs: [...res.dirs].map((path6) => queues.get(path6))
        };
      };
      const check = (fn) => {
        const { paths, dirs } = getQueues(fn);
        return paths.every((q) => q[0] === fn) && dirs.every((q) => q[0] instanceof Set && q[0].has(fn));
      };
      const run = (fn) => {
        if (running.has(fn) || !check(fn)) {
          return false;
        }
        running.add(fn);
        fn(() => clear(fn));
        return true;
      };
      const clear = (fn) => {
        if (!running.has(fn)) {
          return false;
        }
        const { paths, dirs } = reservations.get(fn);
        const next = /* @__PURE__ */ new Set();
        paths.forEach((path6) => {
          const q = queues.get(path6);
          assert.equal(q[0], fn);
          if (q.length === 1) {
            queues.delete(path6);
          } else {
            q.shift();
            if (typeof q[0] === "function") {
              next.add(q[0]);
            } else {
              q[0].forEach((fn2) => next.add(fn2));
            }
          }
        });
        dirs.forEach((dir) => {
          const q = queues.get(dir);
          assert(q[0] instanceof Set);
          if (q[0].size === 1 && q.length === 1) {
            queues.delete(dir);
          } else if (q[0].size === 1) {
            q.shift();
            next.add(q[0]);
          } else {
            q[0].delete(fn);
          }
        });
        running.delete(fn);
        next.forEach((fn2) => run(fn2));
        return true;
      };
      const reserve = (paths, fn) => {
        paths = isWindows ? ["win32 parallelization disabled"] : paths.map((p) => {
          return stripSlashes(join3(normalize2(p))).toLowerCase();
        });
        const dirs = new Set(
          paths.map((path6) => getDirs(path6)).reduce((a, b) => a.concat(b))
        );
        reservations.set(fn, { dirs, paths });
        paths.forEach((path6) => {
          const q = queues.get(path6);
          if (!q) {
            queues.set(path6, [fn]);
          } else {
            q.push(fn);
          }
        });
        dirs.forEach((dir) => {
          const q = queues.get(dir);
          if (!q) {
            queues.set(dir, [/* @__PURE__ */ new Set([fn])]);
          } else if (q[q.length - 1] instanceof Set) {
            q[q.length - 1].add(fn);
          } else {
            q.push(/* @__PURE__ */ new Set([fn]));
          }
        });
        return run(fn);
      };
      return { check, reserve };
    };
  }
});

// node_modules/tar/lib/get-write-flag.js
var require_get_write_flag = __commonJS({
  "node_modules/tar/lib/get-write-flag.js"(exports, module2) {
    var platform = process.env.__FAKE_PLATFORM__ || process.platform;
    var isWindows = platform === "win32";
    var fs2 = global.__FAKE_TESTING_FS__ || require("fs");
    var { O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0 } = fs2.constants;
    var fMapEnabled = isWindows && !!UV_FS_O_FILEMAP;
    var fMapLimit = 512 * 1024;
    var fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;
    module2.exports = !fMapEnabled ? () => "w" : (size) => size < fMapLimit ? fMapFlag : "w";
  }
});

// node_modules/tar/lib/unpack.js
var require_unpack = __commonJS({
  "node_modules/tar/lib/unpack.js"(exports, module2) {
    "use strict";
    var assert = require("assert");
    var Parser = require_parse();
    var fs2 = require("fs");
    var fsm = require_fs_minipass();
    var path6 = require("path");
    var mkdir2 = require_mkdir();
    var wc = require_winchars();
    var pathReservations = require_path_reservations();
    var stripAbsolutePath = require_strip_absolute_path();
    var normPath = require_normalize_windows_path();
    var stripSlash = require_strip_trailing_slashes();
    var normalize2 = require_normalize_unicode();
    var ONENTRY = Symbol("onEntry");
    var CHECKFS = Symbol("checkFs");
    var CHECKFS2 = Symbol("checkFs2");
    var PRUNECACHE = Symbol("pruneCache");
    var ISREUSABLE = Symbol("isReusable");
    var MAKEFS = Symbol("makeFs");
    var FILE = Symbol("file");
    var DIRECTORY = Symbol("directory");
    var LINK = Symbol("link");
    var SYMLINK = Symbol("symlink");
    var HARDLINK = Symbol("hardlink");
    var UNSUPPORTED = Symbol("unsupported");
    var CHECKPATH = Symbol("checkPath");
    var MKDIR = Symbol("mkdir");
    var ONERROR = Symbol("onError");
    var PENDING = Symbol("pending");
    var PEND = Symbol("pend");
    var UNPEND = Symbol("unpend");
    var ENDED = Symbol("ended");
    var MAYBECLOSE = Symbol("maybeClose");
    var SKIP = Symbol("skip");
    var DOCHOWN = Symbol("doChown");
    var UID = Symbol("uid");
    var GID = Symbol("gid");
    var CHECKED_CWD = Symbol("checkedCwd");
    var crypto = require("crypto");
    var getFlag = require_get_write_flag();
    var platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    var isWindows = platform === "win32";
    var DEFAULT_MAX_DEPTH = 1024;
    var unlinkFile = (path7, cb) => {
      if (!isWindows) {
        return fs2.unlink(path7, cb);
      }
      const name = path7 + ".DELETE." + crypto.randomBytes(16).toString("hex");
      fs2.rename(path7, name, (er) => {
        if (er) {
          return cb(er);
        }
        fs2.unlink(name, cb);
      });
    };
    var unlinkFileSync = (path7) => {
      if (!isWindows) {
        return fs2.unlinkSync(path7);
      }
      const name = path7 + ".DELETE." + crypto.randomBytes(16).toString("hex");
      fs2.renameSync(path7, name);
      fs2.unlinkSync(name);
    };
    var uint32 = (a, b, c) => a === a >>> 0 ? a : b === b >>> 0 ? b : c;
    var cacheKeyNormalize = (path7) => stripSlash(normPath(normalize2(path7))).toLowerCase();
    var pruneCache = (cache, abs) => {
      abs = cacheKeyNormalize(abs);
      for (const path7 of cache.keys()) {
        const pnorm = cacheKeyNormalize(path7);
        if (pnorm === abs || pnorm.indexOf(abs + "/") === 0) {
          cache.delete(path7);
        }
      }
    };
    var dropCache = (cache) => {
      for (const key of cache.keys()) {
        cache.delete(key);
      }
    };
    var Unpack = class extends Parser {
      constructor(opt) {
        if (!opt) {
          opt = {};
        }
        opt.ondone = (_) => {
          this[ENDED] = true;
          this[MAYBECLOSE]();
        };
        super(opt);
        this[CHECKED_CWD] = false;
        this.reservations = pathReservations();
        this.transform = typeof opt.transform === "function" ? opt.transform : null;
        this.writable = true;
        this.readable = false;
        this[PENDING] = 0;
        this[ENDED] = false;
        this.dirCache = opt.dirCache || /* @__PURE__ */ new Map();
        if (typeof opt.uid === "number" || typeof opt.gid === "number") {
          if (typeof opt.uid !== "number" || typeof opt.gid !== "number") {
            throw new TypeError("cannot set owner without number uid and gid");
          }
          if (opt.preserveOwner) {
            throw new TypeError(
              "cannot preserve owner in archive and also set owner explicitly"
            );
          }
          this.uid = opt.uid;
          this.gid = opt.gid;
          this.setOwner = true;
        } else {
          this.uid = null;
          this.gid = null;
          this.setOwner = false;
        }
        if (opt.preserveOwner === void 0 && typeof opt.uid !== "number") {
          this.preserveOwner = process.getuid && process.getuid() === 0;
        } else {
          this.preserveOwner = !!opt.preserveOwner;
        }
        this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : null;
        this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : null;
        this.maxDepth = typeof opt.maxDepth === "number" ? opt.maxDepth : DEFAULT_MAX_DEPTH;
        this.forceChown = opt.forceChown === true;
        this.win32 = !!opt.win32 || isWindows;
        this.newer = !!opt.newer;
        this.keep = !!opt.keep;
        this.noMtime = !!opt.noMtime;
        this.preservePaths = !!opt.preservePaths;
        this.unlink = !!opt.unlink;
        this.cwd = normPath(path6.resolve(opt.cwd || process.cwd()));
        this.strip = +opt.strip || 0;
        this.processUmask = opt.noChmod ? 0 : process.umask();
        this.umask = typeof opt.umask === "number" ? opt.umask : this.processUmask;
        this.dmode = opt.dmode || 511 & ~this.umask;
        this.fmode = opt.fmode || 438 & ~this.umask;
        this.on("entry", (entry) => this[ONENTRY](entry));
      }
      // a bad or damaged archive is a warning for Parser, but an error
      // when extracting.  Mark those errors as unrecoverable, because
      // the Unpack contract cannot be met.
      warn(code, msg, data = {}) {
        if (code === "TAR_BAD_ARCHIVE" || code === "TAR_ABORT") {
          data.recoverable = false;
        }
        return super.warn(code, msg, data);
      }
      [MAYBECLOSE]() {
        if (this[ENDED] && this[PENDING] === 0) {
          this.emit("prefinish");
          this.emit("finish");
          this.emit("end");
        }
      }
      [CHECKPATH](entry) {
        const p = normPath(entry.path);
        const parts = p.split("/");
        if (this.strip) {
          if (parts.length < this.strip) {
            return false;
          }
          if (entry.type === "Link") {
            const linkparts = normPath(entry.linkpath).split("/");
            if (linkparts.length >= this.strip) {
              entry.linkpath = linkparts.slice(this.strip).join("/");
            } else {
              return false;
            }
          }
          parts.splice(0, this.strip);
          entry.path = parts.join("/");
        }
        if (isFinite(this.maxDepth) && parts.length > this.maxDepth) {
          this.warn("TAR_ENTRY_ERROR", "path excessively deep", {
            entry,
            path: p,
            depth: parts.length,
            maxDepth: this.maxDepth
          });
          return false;
        }
        if (!this.preservePaths) {
          if (parts.includes("..") || isWindows && /^[a-z]:\.\.$/i.test(parts[0])) {
            this.warn("TAR_ENTRY_ERROR", `path contains '..'`, {
              entry,
              path: p
            });
            return false;
          }
          const [root, stripped] = stripAbsolutePath(p);
          if (root) {
            entry.path = stripped;
            this.warn("TAR_ENTRY_INFO", `stripping ${root} from absolute path`, {
              entry,
              path: p
            });
          }
        }
        if (path6.isAbsolute(entry.path)) {
          entry.absolute = normPath(path6.resolve(entry.path));
        } else {
          entry.absolute = normPath(path6.resolve(this.cwd, entry.path));
        }
        if (!this.preservePaths && entry.absolute.indexOf(this.cwd + "/") !== 0 && entry.absolute !== this.cwd) {
          this.warn("TAR_ENTRY_ERROR", "path escaped extraction target", {
            entry,
            path: normPath(entry.path),
            resolvedPath: entry.absolute,
            cwd: this.cwd
          });
          return false;
        }
        if (entry.absolute === this.cwd && entry.type !== "Directory" && entry.type !== "GNUDumpDir") {
          return false;
        }
        if (this.win32) {
          const { root: aRoot } = path6.win32.parse(entry.absolute);
          entry.absolute = aRoot + wc.encode(entry.absolute.slice(aRoot.length));
          const { root: pRoot } = path6.win32.parse(entry.path);
          entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length));
        }
        return true;
      }
      [ONENTRY](entry) {
        if (!this[CHECKPATH](entry)) {
          return entry.resume();
        }
        assert.equal(typeof entry.absolute, "string");
        switch (entry.type) {
          case "Directory":
          case "GNUDumpDir":
            if (entry.mode) {
              entry.mode = entry.mode | 448;
            }
          case "File":
          case "OldFile":
          case "ContiguousFile":
          case "Link":
          case "SymbolicLink":
            return this[CHECKFS](entry);
          case "CharacterDevice":
          case "BlockDevice":
          case "FIFO":
          default:
            return this[UNSUPPORTED](entry);
        }
      }
      [ONERROR](er, entry) {
        if (er.name === "CwdError") {
          this.emit("error", er);
        } else {
          this.warn("TAR_ENTRY_ERROR", er, { entry });
          this[UNPEND]();
          entry.resume();
        }
      }
      [MKDIR](dir, mode, cb) {
        mkdir2(normPath(dir), {
          uid: this.uid,
          gid: this.gid,
          processUid: this.processUid,
          processGid: this.processGid,
          umask: this.processUmask,
          preserve: this.preservePaths,
          unlink: this.unlink,
          cache: this.dirCache,
          cwd: this.cwd,
          mode,
          noChmod: this.noChmod
        }, cb);
      }
      [DOCHOWN](entry) {
        return this.forceChown || this.preserveOwner && (typeof entry.uid === "number" && entry.uid !== this.processUid || typeof entry.gid === "number" && entry.gid !== this.processGid) || (typeof this.uid === "number" && this.uid !== this.processUid || typeof this.gid === "number" && this.gid !== this.processGid);
      }
      [UID](entry) {
        return uint32(this.uid, entry.uid, this.processUid);
      }
      [GID](entry) {
        return uint32(this.gid, entry.gid, this.processGid);
      }
      [FILE](entry, fullyDone) {
        const mode = entry.mode & 4095 || this.fmode;
        const stream = new fsm.WriteStream(entry.absolute, {
          flags: getFlag(entry.size),
          mode,
          autoClose: false
        });
        stream.on("error", (er) => {
          if (stream.fd) {
            fs2.close(stream.fd, () => {
            });
          }
          stream.write = () => true;
          this[ONERROR](er, entry);
          fullyDone();
        });
        let actions = 1;
        const done = (er) => {
          if (er) {
            if (stream.fd) {
              fs2.close(stream.fd, () => {
              });
            }
            this[ONERROR](er, entry);
            fullyDone();
            return;
          }
          if (--actions === 0) {
            fs2.close(stream.fd, (er2) => {
              if (er2) {
                this[ONERROR](er2, entry);
              } else {
                this[UNPEND]();
              }
              fullyDone();
            });
          }
        };
        stream.on("finish", (_) => {
          const abs = entry.absolute;
          const fd = stream.fd;
          if (entry.mtime && !this.noMtime) {
            actions++;
            const atime = entry.atime || new Date();
            const mtime = entry.mtime;
            fs2.futimes(fd, atime, mtime, (er) => er ? fs2.utimes(abs, atime, mtime, (er2) => done(er2 && er)) : done());
          }
          if (this[DOCHOWN](entry)) {
            actions++;
            const uid = this[UID](entry);
            const gid = this[GID](entry);
            fs2.fchown(fd, uid, gid, (er) => er ? fs2.chown(abs, uid, gid, (er2) => done(er2 && er)) : done());
          }
          done();
        });
        const tx = this.transform ? this.transform(entry) || entry : entry;
        if (tx !== entry) {
          tx.on("error", (er) => {
            this[ONERROR](er, entry);
            fullyDone();
          });
          entry.pipe(tx);
        }
        tx.pipe(stream);
      }
      [DIRECTORY](entry, fullyDone) {
        const mode = entry.mode & 4095 || this.dmode;
        this[MKDIR](entry.absolute, mode, (er) => {
          if (er) {
            this[ONERROR](er, entry);
            fullyDone();
            return;
          }
          let actions = 1;
          const done = (_) => {
            if (--actions === 0) {
              fullyDone();
              this[UNPEND]();
              entry.resume();
            }
          };
          if (entry.mtime && !this.noMtime) {
            actions++;
            fs2.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done);
          }
          if (this[DOCHOWN](entry)) {
            actions++;
            fs2.chown(entry.absolute, this[UID](entry), this[GID](entry), done);
          }
          done();
        });
      }
      [UNSUPPORTED](entry) {
        entry.unsupported = true;
        this.warn(
          "TAR_ENTRY_UNSUPPORTED",
          `unsupported entry type: ${entry.type}`,
          { entry }
        );
        entry.resume();
      }
      [SYMLINK](entry, done) {
        this[LINK](entry, entry.linkpath, "symlink", done);
      }
      [HARDLINK](entry, done) {
        const linkpath = normPath(path6.resolve(this.cwd, entry.linkpath));
        this[LINK](entry, linkpath, "link", done);
      }
      [PEND]() {
        this[PENDING]++;
      }
      [UNPEND]() {
        this[PENDING]--;
        this[MAYBECLOSE]();
      }
      [SKIP](entry) {
        this[UNPEND]();
        entry.resume();
      }
      // Check if we can reuse an existing filesystem entry safely and
      // overwrite it, rather than unlinking and recreating
      // Windows doesn't report a useful nlink, so we just never reuse entries
      [ISREUSABLE](entry, st) {
        return entry.type === "File" && !this.unlink && st.isFile() && st.nlink <= 1 && !isWindows;
      }
      // check if a thing is there, and if so, try to clobber it
      [CHECKFS](entry) {
        this[PEND]();
        const paths = [entry.path];
        if (entry.linkpath) {
          paths.push(entry.linkpath);
        }
        this.reservations.reserve(paths, (done) => this[CHECKFS2](entry, done));
      }
      [PRUNECACHE](entry) {
        if (entry.type === "SymbolicLink") {
          dropCache(this.dirCache);
        } else if (entry.type !== "Directory") {
          pruneCache(this.dirCache, entry.absolute);
        }
      }
      [CHECKFS2](entry, fullyDone) {
        this[PRUNECACHE](entry);
        const done = (er) => {
          this[PRUNECACHE](entry);
          fullyDone(er);
        };
        const checkCwd = () => {
          this[MKDIR](this.cwd, this.dmode, (er) => {
            if (er) {
              this[ONERROR](er, entry);
              done();
              return;
            }
            this[CHECKED_CWD] = true;
            start();
          });
        };
        const start = () => {
          if (entry.absolute !== this.cwd) {
            const parent = normPath(path6.dirname(entry.absolute));
            if (parent !== this.cwd) {
              return this[MKDIR](parent, this.dmode, (er) => {
                if (er) {
                  this[ONERROR](er, entry);
                  done();
                  return;
                }
                afterMakeParent();
              });
            }
          }
          afterMakeParent();
        };
        const afterMakeParent = () => {
          fs2.lstat(entry.absolute, (lstatEr, st) => {
            if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
              this[SKIP](entry);
              done();
              return;
            }
            if (lstatEr || this[ISREUSABLE](entry, st)) {
              return this[MAKEFS](null, entry, done);
            }
            if (st.isDirectory()) {
              if (entry.type === "Directory") {
                const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;
                const afterChmod = (er) => this[MAKEFS](er, entry, done);
                if (!needChmod) {
                  return afterChmod();
                }
                return fs2.chmod(entry.absolute, entry.mode, afterChmod);
              }
              if (entry.absolute !== this.cwd) {
                return fs2.rmdir(entry.absolute, (er) => this[MAKEFS](er, entry, done));
              }
            }
            if (entry.absolute === this.cwd) {
              return this[MAKEFS](null, entry, done);
            }
            unlinkFile(entry.absolute, (er) => this[MAKEFS](er, entry, done));
          });
        };
        if (this[CHECKED_CWD]) {
          start();
        } else {
          checkCwd();
        }
      }
      [MAKEFS](er, entry, done) {
        if (er) {
          this[ONERROR](er, entry);
          done();
          return;
        }
        switch (entry.type) {
          case "File":
          case "OldFile":
          case "ContiguousFile":
            return this[FILE](entry, done);
          case "Link":
            return this[HARDLINK](entry, done);
          case "SymbolicLink":
            return this[SYMLINK](entry, done);
          case "Directory":
          case "GNUDumpDir":
            return this[DIRECTORY](entry, done);
        }
      }
      [LINK](entry, linkpath, link, done) {
        fs2[link](linkpath, entry.absolute, (er) => {
          if (er) {
            this[ONERROR](er, entry);
          } else {
            this[UNPEND]();
            entry.resume();
          }
          done();
        });
      }
    };
    var callSync = (fn) => {
      try {
        return [null, fn()];
      } catch (er) {
        return [er, null];
      }
    };
    var UnpackSync = class extends Unpack {
      [MAKEFS](er, entry) {
        return super[MAKEFS](er, entry, () => {
        });
      }
      [CHECKFS](entry) {
        this[PRUNECACHE](entry);
        if (!this[CHECKED_CWD]) {
          const er2 = this[MKDIR](this.cwd, this.dmode);
          if (er2) {
            return this[ONERROR](er2, entry);
          }
          this[CHECKED_CWD] = true;
        }
        if (entry.absolute !== this.cwd) {
          const parent = normPath(path6.dirname(entry.absolute));
          if (parent !== this.cwd) {
            const mkParent = this[MKDIR](parent, this.dmode);
            if (mkParent) {
              return this[ONERROR](mkParent, entry);
            }
          }
        }
        const [lstatEr, st] = callSync(() => fs2.lstatSync(entry.absolute));
        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
          return this[SKIP](entry);
        }
        if (lstatEr || this[ISREUSABLE](entry, st)) {
          return this[MAKEFS](null, entry);
        }
        if (st.isDirectory()) {
          if (entry.type === "Directory") {
            const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;
            const [er3] = needChmod ? callSync(() => {
              fs2.chmodSync(entry.absolute, entry.mode);
            }) : [];
            return this[MAKEFS](er3, entry);
          }
          const [er2] = callSync(() => fs2.rmdirSync(entry.absolute));
          this[MAKEFS](er2, entry);
        }
        const [er] = entry.absolute === this.cwd ? [] : callSync(() => unlinkFileSync(entry.absolute));
        this[MAKEFS](er, entry);
      }
      [FILE](entry, done) {
        const mode = entry.mode & 4095 || this.fmode;
        const oner = (er) => {
          let closeError;
          try {
            fs2.closeSync(fd);
          } catch (e) {
            closeError = e;
          }
          if (er || closeError) {
            this[ONERROR](er || closeError, entry);
          }
          done();
        };
        let fd;
        try {
          fd = fs2.openSync(entry.absolute, getFlag(entry.size), mode);
        } catch (er) {
          return oner(er);
        }
        const tx = this.transform ? this.transform(entry) || entry : entry;
        if (tx !== entry) {
          tx.on("error", (er) => this[ONERROR](er, entry));
          entry.pipe(tx);
        }
        tx.on("data", (chunk) => {
          try {
            fs2.writeSync(fd, chunk, 0, chunk.length);
          } catch (er) {
            oner(er);
          }
        });
        tx.on("end", (_) => {
          let er = null;
          if (entry.mtime && !this.noMtime) {
            const atime = entry.atime || new Date();
            const mtime = entry.mtime;
            try {
              fs2.futimesSync(fd, atime, mtime);
            } catch (futimeser) {
              try {
                fs2.utimesSync(entry.absolute, atime, mtime);
              } catch (utimeser) {
                er = futimeser;
              }
            }
          }
          if (this[DOCHOWN](entry)) {
            const uid = this[UID](entry);
            const gid = this[GID](entry);
            try {
              fs2.fchownSync(fd, uid, gid);
            } catch (fchowner) {
              try {
                fs2.chownSync(entry.absolute, uid, gid);
              } catch (chowner) {
                er = er || fchowner;
              }
            }
          }
          oner(er);
        });
      }
      [DIRECTORY](entry, done) {
        const mode = entry.mode & 4095 || this.dmode;
        const er = this[MKDIR](entry.absolute, mode);
        if (er) {
          this[ONERROR](er, entry);
          done();
          return;
        }
        if (entry.mtime && !this.noMtime) {
          try {
            fs2.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime);
          } catch (er2) {
          }
        }
        if (this[DOCHOWN](entry)) {
          try {
            fs2.chownSync(entry.absolute, this[UID](entry), this[GID](entry));
          } catch (er2) {
          }
        }
        done();
        entry.resume();
      }
      [MKDIR](dir, mode) {
        try {
          return mkdir2.sync(normPath(dir), {
            uid: this.uid,
            gid: this.gid,
            processUid: this.processUid,
            processGid: this.processGid,
            umask: this.processUmask,
            preserve: this.preservePaths,
            unlink: this.unlink,
            cache: this.dirCache,
            cwd: this.cwd,
            mode
          });
        } catch (er) {
          return er;
        }
      }
      [LINK](entry, linkpath, link, done) {
        try {
          fs2[link + "Sync"](linkpath, entry.absolute);
          done();
          entry.resume();
        } catch (er) {
          return this[ONERROR](er, entry);
        }
      }
    };
    Unpack.Sync = UnpackSync;
    module2.exports = Unpack;
  }
});

// node_modules/tar/lib/extract.js
var require_extract = __commonJS({
  "node_modules/tar/lib/extract.js"(exports, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Unpack = require_unpack();
    var fs2 = require("fs");
    var fsm = require_fs_minipass();
    var path6 = require("path");
    var stripSlash = require_strip_trailing_slashes();
    module2.exports = (opt_, files, cb) => {
      if (typeof opt_ === "function") {
        cb = opt_, files = null, opt_ = {};
      } else if (Array.isArray(opt_)) {
        files = opt_, opt_ = {};
      }
      if (typeof files === "function") {
        cb = files, files = null;
      }
      if (!files) {
        files = [];
      } else {
        files = Array.from(files);
      }
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function") {
        throw new TypeError("callback not supported for sync tar functions");
      }
      if (!opt.file && typeof cb === "function") {
        throw new TypeError("callback only supported with file option");
      }
      if (files.length) {
        filesFilter(opt, files);
      }
      return opt.file && opt.sync ? extractFileSync(opt) : opt.file ? extractFile(opt, cb) : opt.sync ? extractSync(opt) : extract2(opt);
    };
    var filesFilter = (opt, files) => {
      const map = new Map(files.map((f) => [stripSlash(f), true]));
      const filter = opt.filter;
      const mapHas = (file, r) => {
        const root = r || path6.parse(file).root || ".";
        const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path6.dirname(file), root);
        map.set(file, ret);
        return ret;
      };
      opt.filter = filter ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
    };
    var extractFileSync = (opt) => {
      const u = new Unpack.Sync(opt);
      const file = opt.file;
      const stat = fs2.statSync(file);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const stream = new fsm.ReadStreamSync(file, {
        readSize,
        size: stat.size
      });
      stream.pipe(u);
    };
    var extractFile = (opt, cb) => {
      const u = new Unpack(opt);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const file = opt.file;
      const p = new Promise((resolve2, reject) => {
        u.on("error", reject);
        u.on("close", resolve2);
        fs2.stat(file, (er, stat) => {
          if (er) {
            reject(er);
          } else {
            const stream = new fsm.ReadStream(file, {
              readSize,
              size: stat.size
            });
            stream.on("error", reject);
            stream.pipe(u);
          }
        });
      });
      return cb ? p.then(cb, cb) : p;
    };
    var extractSync = (opt) => new Unpack.Sync(opt);
    var extract2 = (opt) => new Unpack(opt);
  }
});

// node_modules/tar/index.js
var require_tar = __commonJS({
  "node_modules/tar/index.js"(exports) {
    "use strict";
    exports.c = exports.create = require_create();
    exports.r = exports.replace = require_replace();
    exports.t = exports.list = require_list();
    exports.u = exports.update = require_update();
    exports.x = exports.extract = require_extract();
    exports.Pack = require_pack();
    exports.Unpack = require_unpack();
    exports.Parse = require_parse();
    exports.ReadEntry = require_read_entry();
    exports.WriteEntry = require_write_entry();
    exports.Header = require_header();
    exports.Pax = require_pax();
    exports.types = require_types();
  }
});

// node_modules/isexe/windows.js
var require_windows = __commonJS({
  "node_modules/isexe/windows.js"(exports, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs2 = require("fs");
    function checkPathExt(path6, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path6.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat, path6, options) {
      if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
      }
      return checkPathExt(path6, options);
    }
    function isexe(path6, options, cb) {
      fs2.stat(path6, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path6, options));
      });
    }
    function sync(path6, options) {
      return checkStat(fs2.statSync(path6), path6, options);
    }
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS({
  "node_modules/isexe/mode.js"(exports, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs2 = require("fs");
    function isexe(path6, options, cb) {
      fs2.stat(path6, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options));
      });
    }
    function sync(path6, options) {
      return checkStat(fs2.statSync(path6), options);
    }
    function checkStat(stat, options) {
      return stat.isFile() && checkMode(stat, options);
    }
    function checkMode(stat, options) {
      var mod = stat.mode;
      var uid = stat.uid;
      var gid = stat.gid;
      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
      var u = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u | g;
      var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS({
  "node_modules/isexe/index.js"(exports, module2) {
    var fs2 = require("fs");
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows();
    } else {
      core = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync;
    function isexe(path6, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve2, reject) {
          isexe(path6, options || {}, function(er, is) {
            if (er) {
              reject(er);
            } else {
              resolve2(is);
            }
          });
        });
      }
      core(path6, options || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options && options.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync(path6, options) {
      try {
        return core.sync(path6, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  }
});

// node_modules/which/which.js
var require_which = __commonJS({
  "node_modules/which/which.js"(exports, module2) {
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path6 = require("path");
    var COLON = isWindows ? ";" : ":";
    var isexe = require_isexe();
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    var getPathInfo = (cmd, opt) => {
      const colon = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
        // windows always checks the cwd first
        ...isWindows ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */
        "").split(colon)
      ];
      const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows ? pathExtExe.split(colon) : [""];
      if (isWindows) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
    var which = (cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      const step = (i) => new Promise((resolve2, reject) => {
        if (i === pathEnv.length)
          return opt.all && found.length ? resolve2(found) : reject(getNotFoundError(cmd));
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path6.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve2(subStep(p, i, 0));
      });
      const subStep = (p, i, ii) => new Promise((resolve2, reject) => {
        if (ii === pathExt.length)
          return resolve2(step(i + 1));
        const ext = pathExt[ii];
        isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
          if (!er && is) {
            if (opt.all)
              found.push(p + ext);
            else
              return resolve2(p + ext);
          }
          return resolve2(subStep(p, i, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    };
    var whichSync = (cmd, opt) => {
      opt = opt || {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (let i = 0; i < pathEnv.length; i++) {
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path6.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j = 0; j < pathExt.length; j++) {
          const cur = p + pathExt[j];
          try {
            const is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module2.exports = which;
    which.sync = whichSync;
  }
});

// node_modules/path-key/index.js
var require_path_key = __commonJS({
  "node_modules/path-key/index.js"(exports, module2) {
    "use strict";
    var pathKey2 = (options = {}) => {
      const environment = options.env || process.env;
      const platform = options.platform || process.platform;
      if (platform !== "win32") {
        return "PATH";
      }
      return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
    };
    module2.exports = pathKey2;
    module2.exports.default = pathKey2;
  }
});

// node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS({
  "node_modules/cross-spawn/lib/util/resolveCommand.js"(exports, module2) {
    "use strict";
    var path6 = require("path");
    var which = require_which();
    var getPathKey = require_path_key();
    function resolveCommandAttempt(parsed, withoutPathExt) {
      const env2 = parsed.options.env || process.env;
      const cwd2 = process.cwd();
      const hasCustomCwd = parsed.options.cwd != null;
      const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
      if (shouldSwitchCwd) {
        try {
          process.chdir(parsed.options.cwd);
        } catch (err) {
        }
      }
      let resolved;
      try {
        resolved = which.sync(parsed.command, {
          path: env2[getPathKey({ env: env2 })],
          pathExt: withoutPathExt ? path6.delimiter : void 0
        });
      } catch (e) {
      } finally {
        if (shouldSwitchCwd) {
          process.chdir(cwd2);
        }
      }
      if (resolved) {
        resolved = path6.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
      }
      return resolved;
    }
    function resolveCommand(parsed) {
      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
    }
    module2.exports = resolveCommand;
  }
});

// node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS({
  "node_modules/cross-spawn/lib/util/escape.js"(exports, module2) {
    "use strict";
    var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    function escapeCommand(arg) {
      arg = arg.replace(metaCharsRegExp, "^$1");
      return arg;
    }
    function escapeArgument(arg, doubleEscapeMetaChars) {
      arg = `${arg}`;
      arg = arg.replace(/(?=(\\+?)?)\1"/g, '$1$1\\"');
      arg = arg.replace(/(?=(\\+?)?)\1$/, "$1$1");
      arg = `"${arg}"`;
      arg = arg.replace(metaCharsRegExp, "^$1");
      if (doubleEscapeMetaChars) {
        arg = arg.replace(metaCharsRegExp, "^$1");
      }
      return arg;
    }
    module2.exports.command = escapeCommand;
    module2.exports.argument = escapeArgument;
  }
});

// node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS({
  "node_modules/shebang-regex/index.js"(exports, module2) {
    "use strict";
    module2.exports = /^#!(.*)/;
  }
});

// node_modules/shebang-command/index.js
var require_shebang_command = __commonJS({
  "node_modules/shebang-command/index.js"(exports, module2) {
    "use strict";
    var shebangRegex = require_shebang_regex();
    module2.exports = (string = "") => {
      const match = string.match(shebangRegex);
      if (!match) {
        return null;
      }
      const [path6, argument] = match[0].replace(/#! ?/, "").split(" ");
      const binary = path6.split("/").pop();
      if (binary === "env") {
        return argument;
      }
      return argument ? `${binary} ${argument}` : binary;
    };
  }
});

// node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS({
  "node_modules/cross-spawn/lib/util/readShebang.js"(exports, module2) {
    "use strict";
    var fs2 = require("fs");
    var shebangCommand = require_shebang_command();
    function readShebang(command) {
      const size = 150;
      const buffer = Buffer.alloc(size);
      let fd;
      try {
        fd = fs2.openSync(command, "r");
        fs2.readSync(fd, buffer, 0, size, 0);
        fs2.closeSync(fd);
      } catch (e) {
      }
      return shebangCommand(buffer.toString());
    }
    module2.exports = readShebang;
  }
});

// node_modules/cross-spawn/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/cross-spawn/lib/parse.js"(exports, module2) {
    "use strict";
    var path6 = require("path");
    var resolveCommand = require_resolveCommand();
    var escape = require_escape();
    var readShebang = require_readShebang();
    var isWin = process.platform === "win32";
    var isExecutableRegExp = /\.(?:com|exe)$/i;
    var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    function detectShebang(parsed) {
      parsed.file = resolveCommand(parsed);
      const shebang = parsed.file && readShebang(parsed.file);
      if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;
        return resolveCommand(parsed);
      }
      return parsed.file;
    }
    function parseNonShell(parsed) {
      if (!isWin) {
        return parsed;
      }
      const commandFile = detectShebang(parsed);
      const needsShell = !isExecutableRegExp.test(commandFile);
      if (parsed.options.forceShell || needsShell) {
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
        parsed.command = path6.normalize(parsed.command);
        parsed.command = escape.command(parsed.command);
        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
        const shellCommand = [parsed.command].concat(parsed.args).join(" ");
        parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
        parsed.command = process.env.comspec || "cmd.exe";
        parsed.options.windowsVerbatimArguments = true;
      }
      return parsed;
    }
    function parse2(command, args, options) {
      if (args && !Array.isArray(args)) {
        options = args;
        args = null;
      }
      args = args ? args.slice(0) : [];
      options = Object.assign({}, options);
      const parsed = {
        command,
        args,
        options,
        file: void 0,
        original: {
          command,
          args
        }
      };
      return options.shell ? parsed : parseNonShell(parsed);
    }
    module2.exports = parse2;
  }
});

// node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS({
  "node_modules/cross-spawn/lib/enoent.js"(exports, module2) {
    "use strict";
    var isWin = process.platform === "win32";
    function notFoundError(original, syscall) {
      return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
      });
    }
    function hookChildProcess(cp, parsed) {
      if (!isWin) {
        return;
      }
      const originalEmit = cp.emit;
      cp.emit = function(name, arg1) {
        if (name === "exit") {
          const err = verifyENOENT(arg1, parsed);
          if (err) {
            return originalEmit.call(cp, "error", err);
          }
        }
        return originalEmit.apply(cp, arguments);
      };
    }
    function verifyENOENT(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawn");
      }
      return null;
    }
    function verifyENOENTSync(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawnSync");
      }
      return null;
    }
    module2.exports = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
  }
});

// node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS({
  "node_modules/cross-spawn/index.js"(exports, module2) {
    "use strict";
    var cp = require("child_process");
    var parse2 = require_parse2();
    var enoent = require_enoent();
    function spawn(command, args, options) {
      const parsed = parse2(command, args, options);
      const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
      enoent.hookChildProcess(spawned, parsed);
      return spawned;
    }
    function spawnSync(command, args, options) {
      const parsed = parse2(command, args, options);
      const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
      result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
      return result;
    }
    module2.exports = spawn;
    module2.exports.spawn = spawn;
    module2.exports.sync = spawnSync;
    module2.exports._parse = parse2;
    module2.exports._enoent = enoent;
  }
});

// node_modules/strip-final-newline/index.js
function stripFinalNewline(input) {
  const LF = typeof input === "string" ? "\n" : "\n".charCodeAt();
  const CR = typeof input === "string" ? "\r" : "\r".charCodeAt();
  if (input[input.length - 1] === LF) {
    input = input.slice(0, -1);
  }
  if (input[input.length - 1] === CR) {
    input = input.slice(0, -1);
  }
  return input;
}
var init_strip_final_newline = __esm({
  "node_modules/strip-final-newline/index.js"() {
  }
});

// node_modules/npm-run-path/node_modules/path-key/index.js
function pathKey(options = {}) {
  const {
    env: env2 = process.env,
    platform = process.platform
  } = options;
  if (platform !== "win32") {
    return "PATH";
  }
  return Object.keys(env2).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
}
var init_path_key = __esm({
  "node_modules/npm-run-path/node_modules/path-key/index.js"() {
  }
});

// node_modules/npm-run-path/index.js
var import_node_process3, import_node_path, import_node_url, npmRunPath, applyPreferLocal, applyExecPath, npmRunPathEnv;
var init_npm_run_path = __esm({
  "node_modules/npm-run-path/index.js"() {
    import_node_process3 = __toESM(require("node:process"), 1);
    import_node_path = __toESM(require("node:path"), 1);
    import_node_url = require("node:url");
    init_path_key();
    npmRunPath = ({
      cwd: cwd2 = import_node_process3.default.cwd(),
      path: pathOption = import_node_process3.default.env[pathKey()],
      preferLocal = true,
      execPath = import_node_process3.default.execPath,
      addExecPath = true
    } = {}) => {
      const cwdString = cwd2 instanceof URL ? (0, import_node_url.fileURLToPath)(cwd2) : cwd2;
      const cwdPath = import_node_path.default.resolve(cwdString);
      const result = [];
      if (preferLocal) {
        applyPreferLocal(result, cwdPath);
      }
      if (addExecPath) {
        applyExecPath(result, execPath, cwdPath);
      }
      return [...result, pathOption].join(import_node_path.default.delimiter);
    };
    applyPreferLocal = (result, cwdPath) => {
      let previous;
      while (previous !== cwdPath) {
        result.push(import_node_path.default.join(cwdPath, "node_modules/.bin"));
        previous = cwdPath;
        cwdPath = import_node_path.default.resolve(cwdPath, "..");
      }
    };
    applyExecPath = (result, execPath, cwdPath) => {
      const execPathString = execPath instanceof URL ? (0, import_node_url.fileURLToPath)(execPath) : execPath;
      result.push(import_node_path.default.resolve(cwdPath, execPathString, ".."));
    };
    npmRunPathEnv = ({ env: env2 = import_node_process3.default.env, ...options } = {}) => {
      env2 = { ...env2 };
      const pathName = pathKey({ env: env2 });
      options.path = env2[pathName];
      env2[pathName] = npmRunPath(options);
      return env2;
    };
  }
});

// node_modules/mimic-fn/index.js
function mimicFunction(to, from, { ignoreNonConfigurable = false } = {}) {
  const { name } = to;
  for (const property of Reflect.ownKeys(from)) {
    copyProperty(to, from, property, ignoreNonConfigurable);
  }
  changePrototype(to, from);
  changeToString(to, from, name);
  return to;
}
var copyProperty, canCopyProperty, changePrototype, wrappedToString, toStringDescriptor, toStringName, changeToString;
var init_mimic_fn = __esm({
  "node_modules/mimic-fn/index.js"() {
    copyProperty = (to, from, property, ignoreNonConfigurable) => {
      if (property === "length" || property === "prototype") {
        return;
      }
      if (property === "arguments" || property === "caller") {
        return;
      }
      const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
      const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
      if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
        return;
      }
      Object.defineProperty(to, property, fromDescriptor);
    };
    canCopyProperty = function(toDescriptor, fromDescriptor) {
      return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
    };
    changePrototype = (to, from) => {
      const fromPrototype = Object.getPrototypeOf(from);
      if (fromPrototype === Object.getPrototypeOf(to)) {
        return;
      }
      Object.setPrototypeOf(to, fromPrototype);
    };
    wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
    toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
    toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
    changeToString = (to, from, name) => {
      const withName = name === "" ? "" : `with ${name.trim()}() `;
      const newToString = wrappedToString.bind(null, withName, from.toString());
      Object.defineProperty(newToString, "name", toStringName);
      Object.defineProperty(to, "toString", { ...toStringDescriptor, value: newToString });
    };
  }
});

// node_modules/onetime/index.js
var calledFunctions, onetime, onetime_default;
var init_onetime = __esm({
  "node_modules/onetime/index.js"() {
    init_mimic_fn();
    calledFunctions = /* @__PURE__ */ new WeakMap();
    onetime = (function_, options = {}) => {
      if (typeof function_ !== "function") {
        throw new TypeError("Expected a function");
      }
      let returnValue;
      let callCount = 0;
      const functionName = function_.displayName || function_.name || "<anonymous>";
      const onetime2 = function(...arguments_) {
        calledFunctions.set(onetime2, ++callCount);
        if (callCount === 1) {
          returnValue = function_.apply(this, arguments_);
          function_ = null;
        } else if (options.throw === true) {
          throw new Error(`Function \`${functionName}\` can only be called once`);
        }
        return returnValue;
      };
      mimicFunction(onetime2, function_);
      calledFunctions.set(onetime2, callCount);
      return onetime2;
    };
    onetime.callCount = (function_) => {
      if (!calledFunctions.has(function_)) {
        throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
      }
      return calledFunctions.get(function_);
    };
    onetime_default = onetime;
  }
});

// node_modules/human-signals/build/src/realtime.js
var getRealtimeSignals, getRealtimeSignal, SIGRTMIN, SIGRTMAX;
var init_realtime = __esm({
  "node_modules/human-signals/build/src/realtime.js"() {
    getRealtimeSignals = () => {
      const length = SIGRTMAX - SIGRTMIN + 1;
      return Array.from({ length }, getRealtimeSignal);
    };
    getRealtimeSignal = (value, index) => ({
      name: `SIGRT${index + 1}`,
      number: SIGRTMIN + index,
      action: "terminate",
      description: "Application-specific signal (realtime)",
      standard: "posix"
    });
    SIGRTMIN = 34;
    SIGRTMAX = 64;
  }
});

// node_modules/human-signals/build/src/core.js
var SIGNALS;
var init_core = __esm({
  "node_modules/human-signals/build/src/core.js"() {
    SIGNALS = [
      {
        name: "SIGHUP",
        number: 1,
        action: "terminate",
        description: "Terminal closed",
        standard: "posix"
      },
      {
        name: "SIGINT",
        number: 2,
        action: "terminate",
        description: "User interruption with CTRL-C",
        standard: "ansi"
      },
      {
        name: "SIGQUIT",
        number: 3,
        action: "core",
        description: "User interruption with CTRL-\\",
        standard: "posix"
      },
      {
        name: "SIGILL",
        number: 4,
        action: "core",
        description: "Invalid machine instruction",
        standard: "ansi"
      },
      {
        name: "SIGTRAP",
        number: 5,
        action: "core",
        description: "Debugger breakpoint",
        standard: "posix"
      },
      {
        name: "SIGABRT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "ansi"
      },
      {
        name: "SIGIOT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "bsd"
      },
      {
        name: "SIGBUS",
        number: 7,
        action: "core",
        description: "Bus error due to misaligned, non-existing address or paging error",
        standard: "bsd"
      },
      {
        name: "SIGEMT",
        number: 7,
        action: "terminate",
        description: "Command should be emulated but is not implemented",
        standard: "other"
      },
      {
        name: "SIGFPE",
        number: 8,
        action: "core",
        description: "Floating point arithmetic error",
        standard: "ansi"
      },
      {
        name: "SIGKILL",
        number: 9,
        action: "terminate",
        description: "Forced termination",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGUSR1",
        number: 10,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
      },
      {
        name: "SIGSEGV",
        number: 11,
        action: "core",
        description: "Segmentation fault",
        standard: "ansi"
      },
      {
        name: "SIGUSR2",
        number: 12,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
      },
      {
        name: "SIGPIPE",
        number: 13,
        action: "terminate",
        description: "Broken pipe or socket",
        standard: "posix"
      },
      {
        name: "SIGALRM",
        number: 14,
        action: "terminate",
        description: "Timeout or timer",
        standard: "posix"
      },
      {
        name: "SIGTERM",
        number: 15,
        action: "terminate",
        description: "Termination",
        standard: "ansi"
      },
      {
        name: "SIGSTKFLT",
        number: 16,
        action: "terminate",
        description: "Stack is empty or overflowed",
        standard: "other"
      },
      {
        name: "SIGCHLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "posix"
      },
      {
        name: "SIGCLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "other"
      },
      {
        name: "SIGCONT",
        number: 18,
        action: "unpause",
        description: "Unpaused",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGSTOP",
        number: 19,
        action: "pause",
        description: "Paused",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGTSTP",
        number: 20,
        action: "pause",
        description: 'Paused using CTRL-Z or "suspend"',
        standard: "posix"
      },
      {
        name: "SIGTTIN",
        number: 21,
        action: "pause",
        description: "Background process cannot read terminal input",
        standard: "posix"
      },
      {
        name: "SIGBREAK",
        number: 21,
        action: "terminate",
        description: "User interruption with CTRL-BREAK",
        standard: "other"
      },
      {
        name: "SIGTTOU",
        number: 22,
        action: "pause",
        description: "Background process cannot write to terminal output",
        standard: "posix"
      },
      {
        name: "SIGURG",
        number: 23,
        action: "ignore",
        description: "Socket received out-of-band data",
        standard: "bsd"
      },
      {
        name: "SIGXCPU",
        number: 24,
        action: "core",
        description: "Process timed out",
        standard: "bsd"
      },
      {
        name: "SIGXFSZ",
        number: 25,
        action: "core",
        description: "File too big",
        standard: "bsd"
      },
      {
        name: "SIGVTALRM",
        number: 26,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
      },
      {
        name: "SIGPROF",
        number: 27,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
      },
      {
        name: "SIGWINCH",
        number: 28,
        action: "ignore",
        description: "Terminal window size changed",
        standard: "bsd"
      },
      {
        name: "SIGIO",
        number: 29,
        action: "terminate",
        description: "I/O is available",
        standard: "other"
      },
      {
        name: "SIGPOLL",
        number: 29,
        action: "terminate",
        description: "Watched event",
        standard: "other"
      },
      {
        name: "SIGINFO",
        number: 29,
        action: "ignore",
        description: "Request for process information",
        standard: "other"
      },
      {
        name: "SIGPWR",
        number: 30,
        action: "terminate",
        description: "Device running out of power",
        standard: "systemv"
      },
      {
        name: "SIGSYS",
        number: 31,
        action: "core",
        description: "Invalid system call",
        standard: "other"
      },
      {
        name: "SIGUNUSED",
        number: 31,
        action: "terminate",
        description: "Invalid system call",
        standard: "other"
      }
    ];
  }
});

// node_modules/human-signals/build/src/signals.js
var import_node_os2, getSignals, normalizeSignal;
var init_signals2 = __esm({
  "node_modules/human-signals/build/src/signals.js"() {
    import_node_os2 = require("node:os");
    init_core();
    init_realtime();
    getSignals = () => {
      const realtimeSignals = getRealtimeSignals();
      const signals2 = [...SIGNALS, ...realtimeSignals].map(normalizeSignal);
      return signals2;
    };
    normalizeSignal = ({
      name,
      number: defaultNumber,
      description,
      action,
      forced = false,
      standard
    }) => {
      const {
        signals: { [name]: constantSignal }
      } = import_node_os2.constants;
      const supported = constantSignal !== void 0;
      const number = supported ? constantSignal : defaultNumber;
      return { name, number, description, supported, action, forced, standard };
    };
  }
});

// node_modules/human-signals/build/src/main.js
var import_node_os3, getSignalsByName, getSignalByName, signalsByName, getSignalsByNumber, getSignalByNumber, findSignalByNumber, signalsByNumber;
var init_main = __esm({
  "node_modules/human-signals/build/src/main.js"() {
    import_node_os3 = require("node:os");
    init_realtime();
    init_signals2();
    getSignalsByName = () => {
      const signals2 = getSignals();
      return Object.fromEntries(signals2.map(getSignalByName));
    };
    getSignalByName = ({
      name,
      number,
      description,
      supported,
      action,
      forced,
      standard
    }) => [name, { name, number, description, supported, action, forced, standard }];
    signalsByName = getSignalsByName();
    getSignalsByNumber = () => {
      const signals2 = getSignals();
      const length = SIGRTMAX + 1;
      const signalsA = Array.from(
        { length },
        (value, number) => getSignalByNumber(number, signals2)
      );
      return Object.assign({}, ...signalsA);
    };
    getSignalByNumber = (number, signals2) => {
      const signal = findSignalByNumber(number, signals2);
      if (signal === void 0) {
        return {};
      }
      const { name, description, supported, action, forced, standard } = signal;
      return {
        [number]: {
          name,
          number,
          description,
          supported,
          action,
          forced,
          standard
        }
      };
    };
    findSignalByNumber = (number, signals2) => {
      const signal = signals2.find(({ name }) => import_node_os3.constants.signals[name] === number);
      if (signal !== void 0) {
        return signal;
      }
      return signals2.find((signalA) => signalA.number === number);
    };
    signalsByNumber = getSignalsByNumber();
  }
});

// node_modules/execa/lib/error.js
var import_node_process4, getErrorPrefix, makeError;
var init_error = __esm({
  "node_modules/execa/lib/error.js"() {
    import_node_process4 = __toESM(require("node:process"), 1);
    init_main();
    getErrorPrefix = ({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled }) => {
      if (timedOut) {
        return `timed out after ${timeout} milliseconds`;
      }
      if (isCanceled) {
        return "was canceled";
      }
      if (errorCode !== void 0) {
        return `failed with ${errorCode}`;
      }
      if (signal !== void 0) {
        return `was killed with ${signal} (${signalDescription})`;
      }
      if (exitCode !== void 0) {
        return `failed with exit code ${exitCode}`;
      }
      return "failed";
    };
    makeError = ({
      stdout,
      stderr,
      all,
      error,
      signal,
      exitCode,
      command,
      escapedCommand,
      timedOut,
      isCanceled,
      killed,
      parsed: { options: { timeout, cwd: cwd2 = import_node_process4.default.cwd() } }
    }) => {
      exitCode = exitCode === null ? void 0 : exitCode;
      signal = signal === null ? void 0 : signal;
      const signalDescription = signal === void 0 ? void 0 : signalsByName[signal].description;
      const errorCode = error && error.code;
      const prefix = getErrorPrefix({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled });
      const execaMessage = `Command ${prefix}: ${command}`;
      const isError = Object.prototype.toString.call(error) === "[object Error]";
      const shortMessage = isError ? `${execaMessage}
${error.message}` : execaMessage;
      const message = [shortMessage, stderr, stdout].filter(Boolean).join("\n");
      if (isError) {
        error.originalMessage = error.message;
        error.message = message;
      } else {
        error = new Error(message);
      }
      error.shortMessage = shortMessage;
      error.command = command;
      error.escapedCommand = escapedCommand;
      error.exitCode = exitCode;
      error.signal = signal;
      error.signalDescription = signalDescription;
      error.stdout = stdout;
      error.stderr = stderr;
      error.cwd = cwd2;
      if (all !== void 0) {
        error.all = all;
      }
      if ("bufferedData" in error) {
        delete error.bufferedData;
      }
      error.failed = true;
      error.timedOut = Boolean(timedOut);
      error.isCanceled = isCanceled;
      error.killed = killed && !timedOut;
      return error;
    };
  }
});

// node_modules/execa/lib/stdio.js
var aliases, hasAlias, normalizeStdio, normalizeStdioNode;
var init_stdio = __esm({
  "node_modules/execa/lib/stdio.js"() {
    aliases = ["stdin", "stdout", "stderr"];
    hasAlias = (options) => aliases.some((alias) => options[alias] !== void 0);
    normalizeStdio = (options) => {
      if (!options) {
        return;
      }
      const { stdio } = options;
      if (stdio === void 0) {
        return aliases.map((alias) => options[alias]);
      }
      if (hasAlias(options)) {
        throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias) => `\`${alias}\``).join(", ")}`);
      }
      if (typeof stdio === "string") {
        return stdio;
      }
      if (!Array.isArray(stdio)) {
        throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
      }
      const length = Math.max(stdio.length, aliases.length);
      return Array.from({ length }, (value, index) => stdio[index]);
    };
    normalizeStdioNode = (options) => {
      const stdio = normalizeStdio(options);
      if (stdio === "ipc") {
        return "ipc";
      }
      if (stdio === void 0 || typeof stdio === "string") {
        return [stdio, stdio, stdio, "ipc"];
      }
      if (stdio.includes("ipc")) {
        return stdio;
      }
      return [...stdio, "ipc"];
    };
  }
});

// node_modules/execa/lib/kill.js
var import_node_os4, DEFAULT_FORCE_KILL_TIMEOUT, spawnedKill, setKillTimeout, shouldForceKill, isSigterm, getForceKillAfterTimeout, spawnedCancel, timeoutKill, setupTimeout, validateTimeout, setExitHandler;
var init_kill = __esm({
  "node_modules/execa/lib/kill.js"() {
    import_node_os4 = __toESM(require("node:os"), 1);
    init_mjs();
    DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5;
    spawnedKill = (kill, signal = "SIGTERM", options = {}) => {
      const killResult = kill(signal);
      setKillTimeout(kill, signal, options, killResult);
      return killResult;
    };
    setKillTimeout = (kill, signal, options, killResult) => {
      if (!shouldForceKill(signal, options, killResult)) {
        return;
      }
      const timeout = getForceKillAfterTimeout(options);
      const t = setTimeout(() => {
        kill("SIGKILL");
      }, timeout);
      if (t.unref) {
        t.unref();
      }
    };
    shouldForceKill = (signal, { forceKillAfterTimeout }, killResult) => isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
    isSigterm = (signal) => signal === import_node_os4.default.constants.signals.SIGTERM || typeof signal === "string" && signal.toUpperCase() === "SIGTERM";
    getForceKillAfterTimeout = ({ forceKillAfterTimeout = true }) => {
      if (forceKillAfterTimeout === true) {
        return DEFAULT_FORCE_KILL_TIMEOUT;
      }
      if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
        throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
      }
      return forceKillAfterTimeout;
    };
    spawnedCancel = (spawned, context) => {
      const killResult = spawned.kill();
      if (killResult) {
        context.isCanceled = true;
      }
    };
    timeoutKill = (spawned, signal, reject) => {
      spawned.kill(signal);
      reject(Object.assign(new Error("Timed out"), { timedOut: true, signal }));
    };
    setupTimeout = (spawned, { timeout, killSignal = "SIGTERM" }, spawnedPromise) => {
      if (timeout === 0 || timeout === void 0) {
        return spawnedPromise;
      }
      let timeoutId;
      const timeoutPromise = new Promise((resolve2, reject) => {
        timeoutId = setTimeout(() => {
          timeoutKill(spawned, killSignal, reject);
        }, timeout);
      });
      const safeSpawnedPromise = spawnedPromise.finally(() => {
        clearTimeout(timeoutId);
      });
      return Promise.race([timeoutPromise, safeSpawnedPromise]);
    };
    validateTimeout = ({ timeout }) => {
      if (timeout !== void 0 && (!Number.isFinite(timeout) || timeout < 0)) {
        throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
      }
    };
    setExitHandler = async (spawned, { cleanup, detached }, timedPromise) => {
      if (!cleanup || detached) {
        return timedPromise;
      }
      const removeExitHandler = onExit(() => {
        spawned.kill();
      });
      return timedPromise.finally(() => {
        removeExitHandler();
      });
    };
  }
});

// node_modules/is-stream/index.js
function isStream(stream) {
  return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
}
function isWritableStream(stream) {
  return isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
}
var init_is_stream = __esm({
  "node_modules/is-stream/index.js"() {
  }
});

// node_modules/execa/lib/pipe.js
var import_node_fs, import_node_child_process, isExecaChildProcess, pipeToTarget, addPipeMethods;
var init_pipe = __esm({
  "node_modules/execa/lib/pipe.js"() {
    import_node_fs = require("node:fs");
    import_node_child_process = require("node:child_process");
    init_is_stream();
    isExecaChildProcess = (target) => target instanceof import_node_child_process.ChildProcess && typeof target.then === "function";
    pipeToTarget = (spawned, streamName, target) => {
      if (typeof target === "string") {
        spawned[streamName].pipe((0, import_node_fs.createWriteStream)(target));
        return spawned;
      }
      if (isWritableStream(target)) {
        spawned[streamName].pipe(target);
        return spawned;
      }
      if (!isExecaChildProcess(target)) {
        throw new TypeError("The second argument must be a string, a stream or an Execa child process.");
      }
      if (!isWritableStream(target.stdin)) {
        throw new TypeError("The target child process's stdin must be available.");
      }
      spawned[streamName].pipe(target.stdin);
      return target;
    };
    addPipeMethods = (spawned) => {
      if (spawned.stdout !== null) {
        spawned.pipeStdout = pipeToTarget.bind(void 0, spawned, "stdout");
      }
      if (spawned.stderr !== null) {
        spawned.pipeStderr = pipeToTarget.bind(void 0, spawned, "stderr");
      }
      if (spawned.all !== void 0) {
        spawned.pipeAll = pipeToTarget.bind(void 0, spawned, "all");
      }
    };
  }
});

// node_modules/get-stream/source/contents.js
var getStreamContents, appendFinalChunk, appendChunk, addNewChunk, isAsyncIterable, getChunkType, objectToString, MaxBufferError;
var init_contents = __esm({
  "node_modules/get-stream/source/contents.js"() {
    getStreamContents = async (stream, { init, convertChunk, getSize, truncateChunk, addChunk, getFinalChunk, finalize }, { maxBuffer = Number.POSITIVE_INFINITY } = {}) => {
      if (!isAsyncIterable(stream)) {
        throw new Error("The first argument must be a Readable, a ReadableStream, or an async iterable.");
      }
      const state = init();
      state.length = 0;
      try {
        for await (const chunk of stream) {
          const chunkType = getChunkType(chunk);
          const convertedChunk = convertChunk[chunkType](chunk, state);
          appendChunk({ convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer });
        }
        appendFinalChunk({ state, convertChunk, getSize, truncateChunk, addChunk, getFinalChunk, maxBuffer });
        return finalize(state);
      } catch (error) {
        error.bufferedData = finalize(state);
        throw error;
      }
    };
    appendFinalChunk = ({ state, getSize, truncateChunk, addChunk, getFinalChunk, maxBuffer }) => {
      const convertedChunk = getFinalChunk(state);
      if (convertedChunk !== void 0) {
        appendChunk({ convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer });
      }
    };
    appendChunk = ({ convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer }) => {
      const chunkSize = getSize(convertedChunk);
      const newLength = state.length + chunkSize;
      if (newLength <= maxBuffer) {
        addNewChunk(convertedChunk, state, addChunk, newLength);
        return;
      }
      const truncatedChunk = truncateChunk(convertedChunk, maxBuffer - state.length);
      if (truncatedChunk !== void 0) {
        addNewChunk(truncatedChunk, state, addChunk, maxBuffer);
      }
      throw new MaxBufferError();
    };
    addNewChunk = (convertedChunk, state, addChunk, newLength) => {
      state.contents = addChunk(convertedChunk, state, newLength);
      state.length = newLength;
    };
    isAsyncIterable = (stream) => typeof stream === "object" && stream !== null && typeof stream[Symbol.asyncIterator] === "function";
    getChunkType = (chunk) => {
      const typeOfChunk = typeof chunk;
      if (typeOfChunk === "string") {
        return "string";
      }
      if (typeOfChunk !== "object" || chunk === null) {
        return "others";
      }
      if (globalThis.Buffer?.isBuffer(chunk)) {
        return "buffer";
      }
      const prototypeName = objectToString.call(chunk);
      if (prototypeName === "[object ArrayBuffer]") {
        return "arrayBuffer";
      }
      if (prototypeName === "[object DataView]") {
        return "dataView";
      }
      if (Number.isInteger(chunk.byteLength) && Number.isInteger(chunk.byteOffset) && objectToString.call(chunk.buffer) === "[object ArrayBuffer]") {
        return "typedArray";
      }
      return "others";
    };
    ({ toString: objectToString } = Object.prototype);
    MaxBufferError = class extends Error {
      name = "MaxBufferError";
      constructor() {
        super("maxBuffer exceeded");
      }
    };
  }
});

// node_modules/get-stream/source/utils.js
var identity, noop, getContentsProp, throwObjectStream, getLengthProp;
var init_utils = __esm({
  "node_modules/get-stream/source/utils.js"() {
    identity = (value) => value;
    noop = () => void 0;
    getContentsProp = ({ contents }) => contents;
    throwObjectStream = (chunk) => {
      throw new Error(`Streams in object mode are not supported: ${String(chunk)}`);
    };
    getLengthProp = (convertedChunk) => convertedChunk.length;
  }
});

// node_modules/get-stream/source/array.js
var init_array = __esm({
  "node_modules/get-stream/source/array.js"() {
    init_contents();
    init_utils();
  }
});

// node_modules/get-stream/source/array-buffer.js
async function getStreamAsArrayBuffer(stream, options) {
  return getStreamContents(stream, arrayBufferMethods, options);
}
var initArrayBuffer, useTextEncoder, textEncoder, useUint8Array, useUint8ArrayWithOffset, truncateArrayBufferChunk, addArrayBufferChunk, resizeArrayBufferSlow, resizeArrayBuffer, getNewContentsLength, SCALE_FACTOR, finalizeArrayBuffer, hasArrayBufferResize, arrayBufferMethods;
var init_array_buffer = __esm({
  "node_modules/get-stream/source/array-buffer.js"() {
    init_contents();
    init_utils();
    initArrayBuffer = () => ({ contents: new ArrayBuffer(0) });
    useTextEncoder = (chunk) => textEncoder.encode(chunk);
    textEncoder = new TextEncoder();
    useUint8Array = (chunk) => new Uint8Array(chunk);
    useUint8ArrayWithOffset = (chunk) => new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    truncateArrayBufferChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);
    addArrayBufferChunk = (convertedChunk, { contents, length: previousLength }, length) => {
      const newContents = hasArrayBufferResize() ? resizeArrayBuffer(contents, length) : resizeArrayBufferSlow(contents, length);
      new Uint8Array(newContents).set(convertedChunk, previousLength);
      return newContents;
    };
    resizeArrayBufferSlow = (contents, length) => {
      if (length <= contents.byteLength) {
        return contents;
      }
      const arrayBuffer = new ArrayBuffer(getNewContentsLength(length));
      new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
      return arrayBuffer;
    };
    resizeArrayBuffer = (contents, length) => {
      if (length <= contents.maxByteLength) {
        contents.resize(length);
        return contents;
      }
      const arrayBuffer = new ArrayBuffer(length, { maxByteLength: getNewContentsLength(length) });
      new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
      return arrayBuffer;
    };
    getNewContentsLength = (length) => SCALE_FACTOR ** Math.ceil(Math.log(length) / Math.log(SCALE_FACTOR));
    SCALE_FACTOR = 2;
    finalizeArrayBuffer = ({ contents, length }) => hasArrayBufferResize() ? contents : contents.slice(0, length);
    hasArrayBufferResize = () => "resize" in ArrayBuffer.prototype;
    arrayBufferMethods = {
      init: initArrayBuffer,
      convertChunk: {
        string: useTextEncoder,
        buffer: useUint8Array,
        arrayBuffer: useUint8Array,
        dataView: useUint8ArrayWithOffset,
        typedArray: useUint8ArrayWithOffset,
        others: throwObjectStream
      },
      getSize: getLengthProp,
      truncateChunk: truncateArrayBufferChunk,
      addChunk: addArrayBufferChunk,
      getFinalChunk: noop,
      finalize: finalizeArrayBuffer
    };
  }
});

// node_modules/get-stream/source/buffer.js
async function getStreamAsBuffer(stream, options) {
  if (!("Buffer" in globalThis)) {
    throw new Error("getStreamAsBuffer() is only supported in Node.js");
  }
  try {
    return arrayBufferToNodeBuffer(await getStreamAsArrayBuffer(stream, options));
  } catch (error) {
    if (error.bufferedData !== void 0) {
      error.bufferedData = arrayBufferToNodeBuffer(error.bufferedData);
    }
    throw error;
  }
}
var arrayBufferToNodeBuffer;
var init_buffer = __esm({
  "node_modules/get-stream/source/buffer.js"() {
    init_array_buffer();
    arrayBufferToNodeBuffer = (arrayBuffer) => globalThis.Buffer.from(arrayBuffer);
  }
});

// node_modules/get-stream/source/string.js
async function getStreamAsString(stream, options) {
  return getStreamContents(stream, stringMethods, options);
}
var initString, useTextDecoder, addStringChunk, truncateStringChunk, getFinalStringChunk, stringMethods;
var init_string = __esm({
  "node_modules/get-stream/source/string.js"() {
    init_contents();
    init_utils();
    initString = () => ({ contents: "", textDecoder: new TextDecoder() });
    useTextDecoder = (chunk, { textDecoder }) => textDecoder.decode(chunk, { stream: true });
    addStringChunk = (convertedChunk, { contents }) => contents + convertedChunk;
    truncateStringChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);
    getFinalStringChunk = ({ textDecoder }) => {
      const finalChunk = textDecoder.decode();
      return finalChunk === "" ? void 0 : finalChunk;
    };
    stringMethods = {
      init: initString,
      convertChunk: {
        string: identity,
        buffer: useTextDecoder,
        arrayBuffer: useTextDecoder,
        dataView: useTextDecoder,
        typedArray: useTextDecoder,
        others: throwObjectStream
      },
      getSize: getLengthProp,
      truncateChunk: truncateStringChunk,
      addChunk: addStringChunk,
      getFinalChunk: getFinalStringChunk,
      finalize: getContentsProp
    };
  }
});

// node_modules/get-stream/source/index.js
var init_source = __esm({
  "node_modules/get-stream/source/index.js"() {
    init_array();
    init_array_buffer();
    init_buffer();
    init_string();
    init_contents();
  }
});

// node_modules/merge-stream/index.js
var require_merge_stream = __commonJS({
  "node_modules/merge-stream/index.js"(exports, module2) {
    "use strict";
    var { PassThrough } = require("stream");
    module2.exports = function() {
      var sources = [];
      var output = new PassThrough({ objectMode: true });
      output.setMaxListeners(0);
      output.add = add;
      output.isEmpty = isEmpty;
      output.on("unpipe", remove);
      Array.prototype.slice.call(arguments).forEach(add);
      return output;
      function add(source) {
        if (Array.isArray(source)) {
          source.forEach(add);
          return this;
        }
        sources.push(source);
        source.once("end", remove.bind(null, source));
        source.once("error", output.emit.bind(output, "error"));
        source.pipe(output, { end: false });
        return this;
      }
      function isEmpty() {
        return sources.length == 0;
      }
      function remove(source) {
        sources = sources.filter(function(it) {
          return it !== source;
        });
        if (!sources.length && output.readable) {
          output.end();
        }
      }
    };
  }
});

// node_modules/execa/lib/stream.js
var import_node_fs2, import_promises, import_merge_stream, validateInputOptions, getInputSync, handleInputSync, getInput, handleInput, makeAllStream, getBufferedData, getStreamPromise, applyEncoding, getSpawnedResult;
var init_stream = __esm({
  "node_modules/execa/lib/stream.js"() {
    import_node_fs2 = require("node:fs");
    import_promises = require("node:timers/promises");
    init_is_stream();
    init_source();
    import_merge_stream = __toESM(require_merge_stream(), 1);
    validateInputOptions = (input) => {
      if (input !== void 0) {
        throw new TypeError("The `input` and `inputFile` options cannot be both set.");
      }
    };
    getInputSync = ({ input, inputFile }) => {
      if (typeof inputFile !== "string") {
        return input;
      }
      validateInputOptions(input);
      return (0, import_node_fs2.readFileSync)(inputFile);
    };
    handleInputSync = (options) => {
      const input = getInputSync(options);
      if (isStream(input)) {
        throw new TypeError("The `input` option cannot be a stream in sync mode");
      }
      return input;
    };
    getInput = ({ input, inputFile }) => {
      if (typeof inputFile !== "string") {
        return input;
      }
      validateInputOptions(input);
      return (0, import_node_fs2.createReadStream)(inputFile);
    };
    handleInput = (spawned, options) => {
      const input = getInput(options);
      if (input === void 0) {
        return;
      }
      if (isStream(input)) {
        input.pipe(spawned.stdin);
      } else {
        spawned.stdin.end(input);
      }
    };
    makeAllStream = (spawned, { all }) => {
      if (!all || !spawned.stdout && !spawned.stderr) {
        return;
      }
      const mixed = (0, import_merge_stream.default)();
      if (spawned.stdout) {
        mixed.add(spawned.stdout);
      }
      if (spawned.stderr) {
        mixed.add(spawned.stderr);
      }
      return mixed;
    };
    getBufferedData = async (stream, streamPromise) => {
      if (!stream || streamPromise === void 0) {
        return;
      }
      await (0, import_promises.setTimeout)(0);
      stream.destroy();
      try {
        return await streamPromise;
      } catch (error) {
        return error.bufferedData;
      }
    };
    getStreamPromise = (stream, { encoding, buffer, maxBuffer }) => {
      if (!stream || !buffer) {
        return;
      }
      if (encoding === "utf8" || encoding === "utf-8") {
        return getStreamAsString(stream, { maxBuffer });
      }
      if (encoding === null || encoding === "buffer") {
        return getStreamAsBuffer(stream, { maxBuffer });
      }
      return applyEncoding(stream, maxBuffer, encoding);
    };
    applyEncoding = async (stream, maxBuffer, encoding) => {
      const buffer = await getStreamAsBuffer(stream, { maxBuffer });
      return buffer.toString(encoding);
    };
    getSpawnedResult = async ({ stdout, stderr, all }, { encoding, buffer, maxBuffer }, processDone) => {
      const stdoutPromise = getStreamPromise(stdout, { encoding, buffer, maxBuffer });
      const stderrPromise = getStreamPromise(stderr, { encoding, buffer, maxBuffer });
      const allPromise = getStreamPromise(all, { encoding, buffer, maxBuffer: maxBuffer * 2 });
      try {
        return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
      } catch (error) {
        return Promise.all([
          { error, signal: error.signal, timedOut: error.timedOut },
          getBufferedData(stdout, stdoutPromise),
          getBufferedData(stderr, stderrPromise),
          getBufferedData(all, allPromise)
        ]);
      }
    };
  }
});

// node_modules/execa/lib/promise.js
var nativePromisePrototype, descriptors, mergePromise, getSpawnedPromise;
var init_promise = __esm({
  "node_modules/execa/lib/promise.js"() {
    nativePromisePrototype = (async () => {
    })().constructor.prototype;
    descriptors = ["then", "catch", "finally"].map((property) => [
      property,
      Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
    ]);
    mergePromise = (spawned, promise) => {
      for (const [property, descriptor] of descriptors) {
        const value = typeof promise === "function" ? (...args) => Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);
        Reflect.defineProperty(spawned, property, { ...descriptor, value });
      }
    };
    getSpawnedPromise = (spawned) => new Promise((resolve2, reject) => {
      spawned.on("exit", (exitCode, signal) => {
        resolve2({ exitCode, signal });
      });
      spawned.on("error", (error) => {
        reject(error);
      });
      if (spawned.stdin) {
        spawned.stdin.on("error", (error) => {
          reject(error);
        });
      }
    });
  }
});

// node_modules/execa/lib/command.js
var import_node_buffer, import_node_child_process2, normalizeArgs, NO_ESCAPE_REGEXP, escapeArg, joinCommand, getEscapedCommand, SPACES_REGEXP, parseCommand, parseExpression, concatTokens, parseTemplate, parseTemplates;
var init_command = __esm({
  "node_modules/execa/lib/command.js"() {
    import_node_buffer = require("node:buffer");
    import_node_child_process2 = require("node:child_process");
    normalizeArgs = (file, args = []) => {
      if (!Array.isArray(args)) {
        return [file];
      }
      return [file, ...args];
    };
    NO_ESCAPE_REGEXP = /^[\w.-]+$/;
    escapeArg = (arg) => {
      if (typeof arg !== "string" || NO_ESCAPE_REGEXP.test(arg)) {
        return arg;
      }
      return `"${arg.replaceAll('"', '\\"')}"`;
    };
    joinCommand = (file, args) => normalizeArgs(file, args).join(" ");
    getEscapedCommand = (file, args) => normalizeArgs(file, args).map((arg) => escapeArg(arg)).join(" ");
    SPACES_REGEXP = / +/g;
    parseCommand = (command) => {
      const tokens = [];
      for (const token of command.trim().split(SPACES_REGEXP)) {
        const previousToken = tokens.at(-1);
        if (previousToken && previousToken.endsWith("\\")) {
          tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
        } else {
          tokens.push(token);
        }
      }
      return tokens;
    };
    parseExpression = (expression) => {
      const typeOfExpression = typeof expression;
      if (typeOfExpression === "string") {
        return expression;
      }
      if (typeOfExpression === "number") {
        return String(expression);
      }
      if (typeOfExpression === "object" && expression !== null && !(expression instanceof import_node_child_process2.ChildProcess) && "stdout" in expression) {
        const typeOfStdout = typeof expression.stdout;
        if (typeOfStdout === "string") {
          return expression.stdout;
        }
        if (import_node_buffer.Buffer.isBuffer(expression.stdout)) {
          return expression.stdout.toString();
        }
        throw new TypeError(`Unexpected "${typeOfStdout}" stdout in template expression`);
      }
      throw new TypeError(`Unexpected "${typeOfExpression}" in template expression`);
    };
    concatTokens = (tokens, nextTokens, isNew) => isNew || tokens.length === 0 || nextTokens.length === 0 ? [...tokens, ...nextTokens] : [
      ...tokens.slice(0, -1),
      `${tokens.at(-1)}${nextTokens[0]}`,
      ...nextTokens.slice(1)
    ];
    parseTemplate = ({ templates: templates2, expressions, tokens, index, template }) => {
      const templateString = template ?? templates2.raw[index];
      const templateTokens = templateString.split(SPACES_REGEXP).filter(Boolean);
      const newTokens = concatTokens(
        tokens,
        templateTokens,
        templateString.startsWith(" ")
      );
      if (index === expressions.length) {
        return newTokens;
      }
      const expression = expressions[index];
      const expressionTokens = Array.isArray(expression) ? expression.map((expression2) => parseExpression(expression2)) : [parseExpression(expression)];
      return concatTokens(
        newTokens,
        expressionTokens,
        templateString.endsWith(" ")
      );
    };
    parseTemplates = (templates2, expressions) => {
      let tokens = [];
      for (const [index, template] of templates2.entries()) {
        tokens = parseTemplate({ templates: templates2, expressions, tokens, index, template });
      }
      return tokens;
    };
  }
});

// node_modules/execa/lib/verbose.js
var import_node_util, import_node_process5, verboseDefault, padField, getTimestamp, logCommand;
var init_verbose = __esm({
  "node_modules/execa/lib/verbose.js"() {
    import_node_util = require("node:util");
    import_node_process5 = __toESM(require("node:process"), 1);
    verboseDefault = (0, import_node_util.debuglog)("execa").enabled;
    padField = (field, padding) => String(field).padStart(padding, "0");
    getTimestamp = () => {
      const date = new Date();
      return `${padField(date.getHours(), 2)}:${padField(date.getMinutes(), 2)}:${padField(date.getSeconds(), 2)}.${padField(date.getMilliseconds(), 3)}`;
    };
    logCommand = (escapedCommand, { verbose }) => {
      if (!verbose) {
        return;
      }
      import_node_process5.default.stderr.write(`[${getTimestamp()}] ${escapedCommand}
`);
    };
  }
});

// node_modules/execa/index.js
var execa_exports = {};
__export(execa_exports, {
  $: () => $,
  execa: () => execa,
  execaCommand: () => execaCommand,
  execaCommandSync: () => execaCommandSync,
  execaNode: () => execaNode,
  execaSync: () => execaSync
});
function execa(file, args, options) {
  const parsed = handleArguments(file, args, options);
  const command = joinCommand(file, args);
  const escapedCommand = getEscapedCommand(file, args);
  logCommand(escapedCommand, parsed.options);
  validateTimeout(parsed.options);
  let spawned;
  try {
    spawned = import_node_child_process3.default.spawn(parsed.file, parsed.args, parsed.options);
  } catch (error) {
    const dummySpawned = new import_node_child_process3.default.ChildProcess();
    const errorPromise = Promise.reject(makeError({
      error,
      stdout: "",
      stderr: "",
      all: "",
      command,
      escapedCommand,
      parsed,
      timedOut: false,
      isCanceled: false,
      killed: false
    }));
    mergePromise(dummySpawned, errorPromise);
    return dummySpawned;
  }
  const spawnedPromise = getSpawnedPromise(spawned);
  const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
  const processDone = setExitHandler(spawned, parsed.options, timedPromise);
  const context = { isCanceled: false };
  spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
  spawned.cancel = spawnedCancel.bind(null, spawned, context);
  const handlePromise = async () => {
    const [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);
    const stdout = handleOutput(parsed.options, stdoutResult);
    const stderr = handleOutput(parsed.options, stderrResult);
    const all = handleOutput(parsed.options, allResult);
    if (error || exitCode !== 0 || signal !== null) {
      const returnedError = makeError({
        error,
        exitCode,
        signal,
        stdout,
        stderr,
        all,
        command,
        escapedCommand,
        parsed,
        timedOut,
        isCanceled: context.isCanceled || (parsed.options.signal ? parsed.options.signal.aborted : false),
        killed: spawned.killed
      });
      if (!parsed.options.reject) {
        return returnedError;
      }
      throw returnedError;
    }
    return {
      command,
      escapedCommand,
      exitCode: 0,
      stdout,
      stderr,
      all,
      failed: false,
      timedOut: false,
      isCanceled: false,
      killed: false
    };
  };
  const handlePromiseOnce = onetime_default(handlePromise);
  handleInput(spawned, parsed.options);
  spawned.all = makeAllStream(spawned, parsed.options);
  addPipeMethods(spawned);
  mergePromise(spawned, handlePromiseOnce);
  return spawned;
}
function execaSync(file, args, options) {
  const parsed = handleArguments(file, args, options);
  const command = joinCommand(file, args);
  const escapedCommand = getEscapedCommand(file, args);
  logCommand(escapedCommand, parsed.options);
  const input = handleInputSync(parsed.options);
  let result;
  try {
    result = import_node_child_process3.default.spawnSync(parsed.file, parsed.args, { ...parsed.options, input });
  } catch (error) {
    throw makeError({
      error,
      stdout: "",
      stderr: "",
      all: "",
      command,
      escapedCommand,
      parsed,
      timedOut: false,
      isCanceled: false,
      killed: false
    });
  }
  const stdout = handleOutput(parsed.options, result.stdout, result.error);
  const stderr = handleOutput(parsed.options, result.stderr, result.error);
  if (result.error || result.status !== 0 || result.signal !== null) {
    const error = makeError({
      stdout,
      stderr,
      error: result.error,
      signal: result.signal,
      exitCode: result.status,
      command,
      escapedCommand,
      parsed,
      timedOut: result.error && result.error.code === "ETIMEDOUT",
      isCanceled: false,
      killed: result.signal !== null
    });
    if (!parsed.options.reject) {
      return error;
    }
    throw error;
  }
  return {
    command,
    escapedCommand,
    exitCode: 0,
    stdout,
    stderr,
    failed: false,
    timedOut: false,
    isCanceled: false,
    killed: false
  };
}
function create$(options) {
  function $2(templatesOrOptions, ...expressions) {
    if (!Array.isArray(templatesOrOptions)) {
      return create$({ ...options, ...templatesOrOptions });
    }
    const [file, ...args] = parseTemplates(templatesOrOptions, expressions);
    return execa(file, args, normalizeScriptOptions(options));
  }
  $2.sync = (templates2, ...expressions) => {
    if (!Array.isArray(templates2)) {
      throw new TypeError("Please use $(options).sync`command` instead of $.sync(options)`command`.");
    }
    const [file, ...args] = parseTemplates(templates2, expressions);
    return execaSync(file, args, normalizeScriptOptions(options));
  };
  return $2;
}
function execaCommand(command, options) {
  const [file, ...args] = parseCommand(command);
  return execa(file, args, options);
}
function execaCommandSync(command, options) {
  const [file, ...args] = parseCommand(command);
  return execaSync(file, args, options);
}
function execaNode(scriptPath, args, options = {}) {
  if (args && !Array.isArray(args) && typeof args === "object") {
    options = args;
    args = [];
  }
  const stdio = normalizeStdioNode(options);
  const defaultExecArgv = import_node_process6.default.execArgv.filter((arg) => !arg.startsWith("--inspect"));
  const {
    nodePath = import_node_process6.default.execPath,
    nodeOptions = defaultExecArgv
  } = options;
  return execa(
    nodePath,
    [
      ...nodeOptions,
      scriptPath,
      ...Array.isArray(args) ? args : []
    ],
    {
      ...options,
      stdin: void 0,
      stdout: void 0,
      stderr: void 0,
      stdio,
      shell: false
    }
  );
}
var import_node_buffer2, import_node_path2, import_node_child_process3, import_node_process6, import_cross_spawn, DEFAULT_MAX_BUFFER, getEnv, handleArguments, handleOutput, normalizeScriptStdin, normalizeScriptOptions, $;
var init_execa = __esm({
  "node_modules/execa/index.js"() {
    import_node_buffer2 = require("node:buffer");
    import_node_path2 = __toESM(require("node:path"), 1);
    import_node_child_process3 = __toESM(require("node:child_process"), 1);
    import_node_process6 = __toESM(require("node:process"), 1);
    import_cross_spawn = __toESM(require_cross_spawn(), 1);
    init_strip_final_newline();
    init_npm_run_path();
    init_onetime();
    init_error();
    init_stdio();
    init_kill();
    init_pipe();
    init_stream();
    init_promise();
    init_command();
    init_verbose();
    DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100;
    getEnv = ({ env: envOption, extendEnv, preferLocal, localDir, execPath }) => {
      const env2 = extendEnv ? { ...import_node_process6.default.env, ...envOption } : envOption;
      if (preferLocal) {
        return npmRunPathEnv({ env: env2, cwd: localDir, execPath });
      }
      return env2;
    };
    handleArguments = (file, args, options = {}) => {
      const parsed = import_cross_spawn.default._parse(file, args, options);
      file = parsed.command;
      args = parsed.args;
      options = parsed.options;
      options = {
        maxBuffer: DEFAULT_MAX_BUFFER,
        buffer: true,
        stripFinalNewline: true,
        extendEnv: true,
        preferLocal: false,
        localDir: options.cwd || import_node_process6.default.cwd(),
        execPath: import_node_process6.default.execPath,
        encoding: "utf8",
        reject: true,
        cleanup: true,
        all: false,
        windowsHide: true,
        verbose: verboseDefault,
        ...options
      };
      options.env = getEnv(options);
      options.stdio = normalizeStdio(options);
      if (import_node_process6.default.platform === "win32" && import_node_path2.default.basename(file, ".exe") === "cmd") {
        args.unshift("/q");
      }
      return { file, args, options, parsed };
    };
    handleOutput = (options, value, error) => {
      if (typeof value !== "string" && !import_node_buffer2.Buffer.isBuffer(value)) {
        return error === void 0 ? void 0 : "";
      }
      if (options.stripFinalNewline) {
        return stripFinalNewline(value);
      }
      return value;
    };
    normalizeScriptStdin = ({ input, inputFile, stdio }) => input === void 0 && inputFile === void 0 && stdio === void 0 ? { stdin: "inherit" } : {};
    normalizeScriptOptions = (options = {}) => ({
      preferLocal: true,
      ...normalizeScriptStdin(options),
      ...options
    });
    $ = create$();
  }
});

// node_modules/node-fetch-native/dist/shared/node-fetch-native.DhEqb06g.cjs
var require_node_fetch_native_DhEqb06g = __commonJS({
  "node_modules/node-fetch-native/dist/shared/node-fetch-native.DhEqb06g.cjs"(exports) {
    "use strict";
    var l = Object.defineProperty;
    var o = (e, t) => l(e, "name", { value: t, configurable: true });
    var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
    function getDefaultExportFromCjs(e) {
      return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
    }
    o(getDefaultExportFromCjs, "getDefaultExportFromCjs"), exports.commonjsGlobal = commonjsGlobal, exports.getDefaultExportFromCjs = getDefaultExportFromCjs;
  }
});

// node_modules/node-fetch-native/dist/chunks/multipart-parser.cjs
var require_multipart_parser = __commonJS({
  "node_modules/node-fetch-native/dist/chunks/multipart-parser.cjs"(exports) {
    "use strict";
    var N = Object.defineProperty;
    var c = (_, a) => N(_, "name", { value: a, configurable: true });
    require("node:fs"), require("node:path");
    var node = require_node();
    require("node:http"), require("node:https"), require("node:zlib"), require("node:stream"), require("node:buffer"), require("node:util"), require_node_fetch_native_DhEqb06g(), require("node:url"), require("node:net");
    var s = 0;
    var S = { START_BOUNDARY: s++, HEADER_FIELD_START: s++, HEADER_FIELD: s++, HEADER_VALUE_START: s++, HEADER_VALUE: s++, HEADER_VALUE_ALMOST_DONE: s++, HEADERS_ALMOST_DONE: s++, PART_DATA_START: s++, PART_DATA: s++, END: s++ };
    var f = 1;
    var F = { PART_BOUNDARY: f, LAST_BOUNDARY: f *= 2 };
    var LF = 10;
    var CR = 13;
    var SPACE = 32;
    var HYPHEN = 45;
    var COLON = 58;
    var A = 97;
    var Z = 122;
    var lower = c((_) => _ | 32, "lower");
    var noop2 = c(() => {
    }, "noop");
    var MultipartParser = class {
      static {
        c(this, "MultipartParser");
      }
      constructor(a) {
        this.index = 0, this.flags = 0, this.onHeaderEnd = noop2, this.onHeaderField = noop2, this.onHeadersEnd = noop2, this.onHeaderValue = noop2, this.onPartBegin = noop2, this.onPartData = noop2, this.onPartEnd = noop2, this.boundaryChars = {}, a = `\r
--` + a;
        const t = new Uint8Array(a.length);
        for (let n = 0; n < a.length; n++)
          t[n] = a.charCodeAt(n), this.boundaryChars[t[n]] = true;
        this.boundary = t, this.lookbehind = new Uint8Array(this.boundary.length + 8), this.state = S.START_BOUNDARY;
      }
      write(a) {
        let t = 0;
        const n = a.length;
        let E = this.index, { lookbehind: d, boundary: h, boundaryChars: H, index: e, state: o, flags: l } = this;
        const b = this.boundary.length, m = b - 1, O = a.length;
        let r, P;
        const u = c((D) => {
          this[D + "Mark"] = t;
        }, "mark"), i = c((D) => {
          delete this[D + "Mark"];
        }, "clear"), T = c((D, p, R, g) => {
          (p === void 0 || p !== R) && this[D](g && g.subarray(p, R));
        }, "callback"), L = c((D, p) => {
          const R = D + "Mark";
          R in this && (p ? (T(D, this[R], t, a), delete this[R]) : (T(D, this[R], a.length, a), this[R] = 0));
        }, "dataCallback");
        for (t = 0; t < n; t++)
          switch (r = a[t], o) {
            case S.START_BOUNDARY:
              if (e === h.length - 2) {
                if (r === HYPHEN)
                  l |= F.LAST_BOUNDARY;
                else if (r !== CR)
                  return;
                e++;
                break;
              } else if (e - 1 === h.length - 2) {
                if (l & F.LAST_BOUNDARY && r === HYPHEN)
                  o = S.END, l = 0;
                else if (!(l & F.LAST_BOUNDARY) && r === LF)
                  e = 0, T("onPartBegin"), o = S.HEADER_FIELD_START;
                else
                  return;
                break;
              }
              r !== h[e + 2] && (e = -2), r === h[e + 2] && e++;
              break;
            case S.HEADER_FIELD_START:
              o = S.HEADER_FIELD, u("onHeaderField"), e = 0;
            case S.HEADER_FIELD:
              if (r === CR) {
                i("onHeaderField"), o = S.HEADERS_ALMOST_DONE;
                break;
              }
              if (e++, r === HYPHEN)
                break;
              if (r === COLON) {
                if (e === 1)
                  return;
                L("onHeaderField", true), o = S.HEADER_VALUE_START;
                break;
              }
              if (P = lower(r), P < A || P > Z)
                return;
              break;
            case S.HEADER_VALUE_START:
              if (r === SPACE)
                break;
              u("onHeaderValue"), o = S.HEADER_VALUE;
            case S.HEADER_VALUE:
              r === CR && (L("onHeaderValue", true), T("onHeaderEnd"), o = S.HEADER_VALUE_ALMOST_DONE);
              break;
            case S.HEADER_VALUE_ALMOST_DONE:
              if (r !== LF)
                return;
              o = S.HEADER_FIELD_START;
              break;
            case S.HEADERS_ALMOST_DONE:
              if (r !== LF)
                return;
              T("onHeadersEnd"), o = S.PART_DATA_START;
              break;
            case S.PART_DATA_START:
              o = S.PART_DATA, u("onPartData");
            case S.PART_DATA:
              if (E = e, e === 0) {
                for (t += m; t < O && !(a[t] in H); )
                  t += b;
                t -= m, r = a[t];
              }
              if (e < h.length)
                h[e] === r ? (e === 0 && L("onPartData", true), e++) : e = 0;
              else if (e === h.length)
                e++, r === CR ? l |= F.PART_BOUNDARY : r === HYPHEN ? l |= F.LAST_BOUNDARY : e = 0;
              else if (e - 1 === h.length)
                if (l & F.PART_BOUNDARY) {
                  if (e = 0, r === LF) {
                    l &= ~F.PART_BOUNDARY, T("onPartEnd"), T("onPartBegin"), o = S.HEADER_FIELD_START;
                    break;
                  }
                } else
                  l & F.LAST_BOUNDARY && r === HYPHEN ? (T("onPartEnd"), o = S.END, l = 0) : e = 0;
              if (e > 0)
                d[e - 1] = r;
              else if (E > 0) {
                const D = new Uint8Array(d.buffer, d.byteOffset, d.byteLength);
                T("onPartData", 0, E, D), E = 0, u("onPartData"), t--;
              }
              break;
            case S.END:
              break;
            default:
              throw new Error(`Unexpected state entered: ${o}`);
          }
        L("onHeaderField"), L("onHeaderValue"), L("onPartData"), this.index = e, this.state = o, this.flags = l;
      }
      end() {
        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length)
          this.onPartEnd();
        else if (this.state !== S.END)
          throw new Error("MultipartParser.end(): stream ended unexpectedly");
      }
    };
    function _fileName(_) {
      const a = _.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
      if (!a)
        return;
      const t = a[2] || a[3] || "";
      let n = t.slice(t.lastIndexOf("\\") + 1);
      return n = n.replace(/%22/g, '"'), n = n.replace(/&#(\d{4});/g, (E, d) => String.fromCharCode(d)), n;
    }
    c(_fileName, "_fileName");
    async function toFormData(_, a) {
      if (!/multipart/i.test(a))
        throw new TypeError("Failed to fetch");
      const t = a.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
      if (!t)
        throw new TypeError("no or bad content-type header, no multipart boundary");
      const n = new MultipartParser(t[1] || t[2]);
      let E, d, h, H, e, o;
      const l = [], b = new node.FormData(), m = c((i) => {
        h += u.decode(i, { stream: true });
      }, "onPartData"), O = c((i) => {
        l.push(i);
      }, "appendToFile"), r = c(() => {
        const i = new node.File(l, o, { type: e });
        b.append(H, i);
      }, "appendFileToFormData"), P = c(() => {
        b.append(H, h);
      }, "appendEntryToFormData"), u = new TextDecoder("utf-8");
      u.decode(), n.onPartBegin = function() {
        n.onPartData = m, n.onPartEnd = P, E = "", d = "", h = "", H = "", e = "", o = null, l.length = 0;
      }, n.onHeaderField = function(i) {
        E += u.decode(i, { stream: true });
      }, n.onHeaderValue = function(i) {
        d += u.decode(i, { stream: true });
      }, n.onHeaderEnd = function() {
        if (d += u.decode(), E = E.toLowerCase(), E === "content-disposition") {
          const i = d.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
          i && (H = i[2] || i[3] || ""), o = _fileName(d), o && (n.onPartData = O, n.onPartEnd = r);
        } else
          E === "content-type" && (e = d);
        d = "", E = "";
      };
      for await (const i of _)
        n.write(i);
      return n.end(), b;
    }
    c(toFormData, "toFormData"), exports.toFormData = toFormData;
  }
});

// node_modules/node-fetch-native/dist/node.cjs
var require_node = __commonJS({
  "node_modules/node-fetch-native/dist/node.cjs"(exports) {
    "use strict";
    var qi = Object.defineProperty;
    var u = (c, l) => qi(c, "name", { value: l, configurable: true });
    Object.defineProperty(exports, "__esModule", { value: true });
    var http2 = require("node:http");
    var https = require("node:https");
    var zlib = require("node:zlib");
    var Stream = require("node:stream");
    var require$$0 = require("node:buffer");
    var require$$0$1 = require("node:util");
    var _commonjsHelpers = require_node_fetch_native_DhEqb06g();
    var require$$1 = require("node:url");
    var require$$0$2 = require("node:net");
    var node_fs = require("node:fs");
    var node_path = require("node:path");
    function _interopDefaultCompat(c) {
      return c && typeof c == "object" && "default" in c ? c.default : c;
    }
    u(_interopDefaultCompat, "_interopDefaultCompat");
    var http__default = _interopDefaultCompat(http2);
    var https__default = _interopDefaultCompat(https);
    var zlib__default = _interopDefaultCompat(zlib);
    var Stream__default = _interopDefaultCompat(Stream);
    function dataUriToBuffer(c) {
      if (!/^data:/i.test(c))
        throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
      c = c.replace(/\r?\n/g, "");
      const l = c.indexOf(",");
      if (l === -1 || l <= 4)
        throw new TypeError("malformed data: URI");
      const d = c.substring(5, l).split(";");
      let y = "", b = false;
      const R = d[0] || "text/plain";
      let w = R;
      for (let z = 1; z < d.length; z++)
        d[z] === "base64" ? b = true : d[z] && (w += `;${d[z]}`, d[z].indexOf("charset=") === 0 && (y = d[z].substring(8)));
      !d[0] && !y.length && (w += ";charset=US-ASCII", y = "US-ASCII");
      const A = b ? "base64" : "ascii", F = unescape(c.substring(l + 1)), B = Buffer.from(F, A);
      return B.type = R, B.typeFull = w, B.charset = y, B;
    }
    u(dataUriToBuffer, "dataUriToBuffer");
    var streams = {};
    var ponyfill_es2018$1 = { exports: {} };
    var ponyfill_es2018 = ponyfill_es2018$1.exports;
    var hasRequiredPonyfill_es2018;
    function requirePonyfill_es2018() {
      return hasRequiredPonyfill_es2018 || (hasRequiredPonyfill_es2018 = 1, function(c, l) {
        (function(d, y) {
          y(l);
        })(ponyfill_es2018, function(d) {
          function y() {
          }
          u(y, "noop");
          function b(n) {
            return typeof n == "object" && n !== null || typeof n == "function";
          }
          u(b, "typeIsObject");
          const R = y;
          function w(n, o) {
            try {
              Object.defineProperty(n, "name", { value: o, configurable: true });
            } catch {
            }
          }
          u(w, "setFunctionName");
          const A = Promise, F = Promise.prototype.then, B = Promise.reject.bind(A);
          function z(n) {
            return new A(n);
          }
          u(z, "newPromise");
          function W(n) {
            return z((o) => o(n));
          }
          u(W, "promiseResolvedWith");
          function T(n) {
            return B(n);
          }
          u(T, "promiseRejectedWith");
          function D(n, o, a) {
            return F.call(n, o, a);
          }
          u(D, "PerformPromiseThen");
          function E(n, o, a) {
            D(D(n, o, a), void 0, R);
          }
          u(E, "uponPromise");
          function Z(n, o) {
            E(n, o);
          }
          u(Z, "uponFulfillment");
          function M(n, o) {
            E(n, void 0, o);
          }
          u(M, "uponRejection");
          function U(n, o, a) {
            return D(n, o, a);
          }
          u(U, "transformPromiseWith");
          function K(n) {
            D(n, void 0, R);
          }
          u(K, "setPromiseIsHandledToTrue");
          let se = u((n) => {
            if (typeof queueMicrotask == "function")
              se = queueMicrotask;
            else {
              const o = W(void 0);
              se = u((a) => D(o, a), "_queueMicrotask");
            }
            return se(n);
          }, "_queueMicrotask");
          function $2(n, o, a) {
            if (typeof n != "function")
              throw new TypeError("Argument is not a function");
            return Function.prototype.apply.call(n, o, a);
          }
          u($2, "reflectCall");
          function N(n, o, a) {
            try {
              return W($2(n, o, a));
            } catch (p) {
              return T(p);
            }
          }
          u(N, "promiseCall");
          const V = 16384;
          class Q {
            static {
              u(this, "SimpleQueue");
            }
            constructor() {
              this._cursor = 0, this._size = 0, this._front = { _elements: [], _next: void 0 }, this._back = this._front, this._cursor = 0, this._size = 0;
            }
            get length() {
              return this._size;
            }
            push(o) {
              const a = this._back;
              let p = a;
              a._elements.length === V - 1 && (p = { _elements: [], _next: void 0 }), a._elements.push(o), p !== a && (this._back = p, a._next = p), ++this._size;
            }
            shift() {
              const o = this._front;
              let a = o;
              const p = this._cursor;
              let g = p + 1;
              const _ = o._elements, S = _[p];
              return g === V && (a = o._next, g = 0), --this._size, this._cursor = g, o !== a && (this._front = a), _[p] = void 0, S;
            }
            forEach(o) {
              let a = this._cursor, p = this._front, g = p._elements;
              for (; (a !== g.length || p._next !== void 0) && !(a === g.length && (p = p._next, g = p._elements, a = 0, g.length === 0)); )
                o(g[a]), ++a;
            }
            peek() {
              const o = this._front, a = this._cursor;
              return o._elements[a];
            }
          }
          const rt = Symbol("[[AbortSteps]]"), wr = Symbol("[[ErrorSteps]]"), Ot = Symbol("[[CancelSteps]]"), Ft = Symbol("[[PullSteps]]"), It = Symbol("[[ReleaseSteps]]");
          function Rr(n, o) {
            n._ownerReadableStream = o, o._reader = n, o._state === "readable" ? jt(n) : o._state === "closed" ? Dn(n) : Tr(n, o._storedError);
          }
          u(Rr, "ReadableStreamReaderGenericInitialize");
          function zt(n, o) {
            const a = n._ownerReadableStream;
            return ne(a, o);
          }
          u(zt, "ReadableStreamReaderGenericCancel");
          function ue(n) {
            const o = n._ownerReadableStream;
            o._state === "readable" ? Lt(n, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : $n(n, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), o._readableStreamController[It](), o._reader = void 0, n._ownerReadableStream = void 0;
          }
          u(ue, "ReadableStreamReaderGenericRelease");
          function nt(n) {
            return new TypeError("Cannot " + n + " a stream using a released reader");
          }
          u(nt, "readerLockException");
          function jt(n) {
            n._closedPromise = z((o, a) => {
              n._closedPromise_resolve = o, n._closedPromise_reject = a;
            });
          }
          u(jt, "defaultReaderClosedPromiseInitialize");
          function Tr(n, o) {
            jt(n), Lt(n, o);
          }
          u(Tr, "defaultReaderClosedPromiseInitializeAsRejected");
          function Dn(n) {
            jt(n), Cr(n);
          }
          u(Dn, "defaultReaderClosedPromiseInitializeAsResolved");
          function Lt(n, o) {
            n._closedPromise_reject !== void 0 && (K(n._closedPromise), n._closedPromise_reject(o), n._closedPromise_resolve = void 0, n._closedPromise_reject = void 0);
          }
          u(Lt, "defaultReaderClosedPromiseReject");
          function $n(n, o) {
            Tr(n, o);
          }
          u($n, "defaultReaderClosedPromiseResetToRejected");
          function Cr(n) {
            n._closedPromise_resolve !== void 0 && (n._closedPromise_resolve(void 0), n._closedPromise_resolve = void 0, n._closedPromise_reject = void 0);
          }
          u(Cr, "defaultReaderClosedPromiseResolve");
          const Pr = Number.isFinite || function(n) {
            return typeof n == "number" && isFinite(n);
          }, Mn = Math.trunc || function(n) {
            return n < 0 ? Math.ceil(n) : Math.floor(n);
          };
          function xn(n) {
            return typeof n == "object" || typeof n == "function";
          }
          u(xn, "isDictionary");
          function ie(n, o) {
            if (n !== void 0 && !xn(n))
              throw new TypeError(`${o} is not an object.`);
          }
          u(ie, "assertDictionary");
          function X(n, o) {
            if (typeof n != "function")
              throw new TypeError(`${o} is not a function.`);
          }
          u(X, "assertFunction");
          function Un(n) {
            return typeof n == "object" && n !== null || typeof n == "function";
          }
          u(Un, "isObject");
          function Er(n, o) {
            if (!Un(n))
              throw new TypeError(`${o} is not an object.`);
          }
          u(Er, "assertObject");
          function le(n, o, a) {
            if (n === void 0)
              throw new TypeError(`Parameter ${o} is required in '${a}'.`);
          }
          u(le, "assertRequiredArgument");
          function Dt(n, o, a) {
            if (n === void 0)
              throw new TypeError(`${o} is required in '${a}'.`);
          }
          u(Dt, "assertRequiredField");
          function $t(n) {
            return Number(n);
          }
          u($t, "convertUnrestrictedDouble");
          function vr(n) {
            return n === 0 ? 0 : n;
          }
          u(vr, "censorNegativeZero");
          function Nn(n) {
            return vr(Mn(n));
          }
          u(Nn, "integerPart");
          function Mt(n, o) {
            const p = Number.MAX_SAFE_INTEGER;
            let g = Number(n);
            if (g = vr(g), !Pr(g))
              throw new TypeError(`${o} is not a finite number`);
            if (g = Nn(g), g < 0 || g > p)
              throw new TypeError(`${o} is outside the accepted range of 0 to ${p}, inclusive`);
            return !Pr(g) || g === 0 ? 0 : g;
          }
          u(Mt, "convertUnsignedLongLongWithEnforceRange");
          function xt(n, o) {
            if (!Re(n))
              throw new TypeError(`${o} is not a ReadableStream.`);
          }
          u(xt, "assertReadableStream");
          function Fe(n) {
            return new me(n);
          }
          u(Fe, "AcquireReadableStreamDefaultReader");
          function Ar(n, o) {
            n._reader._readRequests.push(o);
          }
          u(Ar, "ReadableStreamAddReadRequest");
          function Ut(n, o, a) {
            const g = n._reader._readRequests.shift();
            a ? g._closeSteps() : g._chunkSteps(o);
          }
          u(Ut, "ReadableStreamFulfillReadRequest");
          function ot(n) {
            return n._reader._readRequests.length;
          }
          u(ot, "ReadableStreamGetNumReadRequests");
          function Br(n) {
            const o = n._reader;
            return !(o === void 0 || !ye(o));
          }
          u(Br, "ReadableStreamHasDefaultReader");
          class me {
            static {
              u(this, "ReadableStreamDefaultReader");
            }
            constructor(o) {
              if (le(o, 1, "ReadableStreamDefaultReader"), xt(o, "First parameter"), Te(o))
                throw new TypeError("This stream has already been locked for exclusive reading by another reader");
              Rr(this, o), this._readRequests = new Q();
            }
            get closed() {
              return ye(this) ? this._closedPromise : T(it("closed"));
            }
            cancel(o = void 0) {
              return ye(this) ? this._ownerReadableStream === void 0 ? T(nt("cancel")) : zt(this, o) : T(it("cancel"));
            }
            read() {
              if (!ye(this))
                return T(it("read"));
              if (this._ownerReadableStream === void 0)
                return T(nt("read from"));
              let o, a;
              const p = z((_, S) => {
                o = _, a = S;
              });
              return Ve(this, { _chunkSteps: u((_) => o({ value: _, done: false }), "_chunkSteps"), _closeSteps: u(() => o({ value: void 0, done: true }), "_closeSteps"), _errorSteps: u((_) => a(_), "_errorSteps") }), p;
            }
            releaseLock() {
              if (!ye(this))
                throw it("releaseLock");
              this._ownerReadableStream !== void 0 && Hn(this);
            }
          }
          Object.defineProperties(me.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), w(me.prototype.cancel, "cancel"), w(me.prototype.read, "read"), w(me.prototype.releaseLock, "releaseLock"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(me.prototype, Symbol.toStringTag, { value: "ReadableStreamDefaultReader", configurable: true });
          function ye(n) {
            return !b(n) || !Object.prototype.hasOwnProperty.call(n, "_readRequests") ? false : n instanceof me;
          }
          u(ye, "IsReadableStreamDefaultReader");
          function Ve(n, o) {
            const a = n._ownerReadableStream;
            a._disturbed = true, a._state === "closed" ? o._closeSteps() : a._state === "errored" ? o._errorSteps(a._storedError) : a._readableStreamController[Ft](o);
          }
          u(Ve, "ReadableStreamDefaultReaderRead");
          function Hn(n) {
            ue(n);
            const o = new TypeError("Reader was released");
            qr(n, o);
          }
          u(Hn, "ReadableStreamDefaultReaderRelease");
          function qr(n, o) {
            const a = n._readRequests;
            n._readRequests = new Q(), a.forEach((p) => {
              p._errorSteps(o);
            });
          }
          u(qr, "ReadableStreamDefaultReaderErrorReadRequests");
          function it(n) {
            return new TypeError(`ReadableStreamDefaultReader.prototype.${n} can only be used on a ReadableStreamDefaultReader`);
          }
          u(it, "defaultReaderBrandCheckException");
          const Vn = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
          }).prototype);
          class Wr {
            static {
              u(this, "ReadableStreamAsyncIteratorImpl");
            }
            constructor(o, a) {
              this._ongoingPromise = void 0, this._isFinished = false, this._reader = o, this._preventCancel = a;
            }
            next() {
              const o = u(() => this._nextSteps(), "nextSteps");
              return this._ongoingPromise = this._ongoingPromise ? U(this._ongoingPromise, o, o) : o(), this._ongoingPromise;
            }
            return(o) {
              const a = u(() => this._returnSteps(o), "returnSteps");
              return this._ongoingPromise ? U(this._ongoingPromise, a, a) : a();
            }
            _nextSteps() {
              if (this._isFinished)
                return Promise.resolve({ value: void 0, done: true });
              const o = this._reader;
              let a, p;
              const g = z((S, C) => {
                a = S, p = C;
              });
              return Ve(o, { _chunkSteps: u((S) => {
                this._ongoingPromise = void 0, se(() => a({ value: S, done: false }));
              }, "_chunkSteps"), _closeSteps: u(() => {
                this._ongoingPromise = void 0, this._isFinished = true, ue(o), a({ value: void 0, done: true });
              }, "_closeSteps"), _errorSteps: u((S) => {
                this._ongoingPromise = void 0, this._isFinished = true, ue(o), p(S);
              }, "_errorSteps") }), g;
            }
            _returnSteps(o) {
              if (this._isFinished)
                return Promise.resolve({ value: o, done: true });
              this._isFinished = true;
              const a = this._reader;
              if (!this._preventCancel) {
                const p = zt(a, o);
                return ue(a), U(p, () => ({ value: o, done: true }));
              }
              return ue(a), W({ value: o, done: true });
            }
          }
          const kr = { next() {
            return Or(this) ? this._asyncIteratorImpl.next() : T(Fr("next"));
          }, return(n) {
            return Or(this) ? this._asyncIteratorImpl.return(n) : T(Fr("return"));
          } };
          Object.setPrototypeOf(kr, Vn);
          function Qn(n, o) {
            const a = Fe(n), p = new Wr(a, o), g = Object.create(kr);
            return g._asyncIteratorImpl = p, g;
          }
          u(Qn, "AcquireReadableStreamAsyncIterator");
          function Or(n) {
            if (!b(n) || !Object.prototype.hasOwnProperty.call(n, "_asyncIteratorImpl"))
              return false;
            try {
              return n._asyncIteratorImpl instanceof Wr;
            } catch {
              return false;
            }
          }
          u(Or, "IsReadableStreamAsyncIterator");
          function Fr(n) {
            return new TypeError(`ReadableStreamAsyncIterator.${n} can only be used on a ReadableSteamAsyncIterator`);
          }
          u(Fr, "streamAsyncIteratorBrandCheckException");
          const Ir = Number.isNaN || function(n) {
            return n !== n;
          };
          var Nt, Ht, Vt;
          function Qe(n) {
            return n.slice();
          }
          u(Qe, "CreateArrayFromList");
          function zr(n, o, a, p, g) {
            new Uint8Array(n).set(new Uint8Array(a, p, g), o);
          }
          u(zr, "CopyDataBlockBytes");
          let fe = u((n) => (typeof n.transfer == "function" ? fe = u((o) => o.transfer(), "TransferArrayBuffer") : typeof structuredClone == "function" ? fe = u((o) => structuredClone(o, { transfer: [o] }), "TransferArrayBuffer") : fe = u((o) => o, "TransferArrayBuffer"), fe(n)), "TransferArrayBuffer"), ge = u((n) => (typeof n.detached == "boolean" ? ge = u((o) => o.detached, "IsDetachedBuffer") : ge = u((o) => o.byteLength === 0, "IsDetachedBuffer"), ge(n)), "IsDetachedBuffer");
          function jr(n, o, a) {
            if (n.slice)
              return n.slice(o, a);
            const p = a - o, g = new ArrayBuffer(p);
            return zr(g, 0, n, o, p), g;
          }
          u(jr, "ArrayBufferSlice");
          function at(n, o) {
            const a = n[o];
            if (a != null) {
              if (typeof a != "function")
                throw new TypeError(`${String(o)} is not a function`);
              return a;
            }
          }
          u(at, "GetMethod");
          function Yn(n) {
            const o = { [Symbol.iterator]: () => n.iterator }, a = async function* () {
              return yield* o;
            }(), p = a.next;
            return { iterator: a, nextMethod: p, done: false };
          }
          u(Yn, "CreateAsyncFromSyncIterator");
          const Qt = (Vt = (Nt = Symbol.asyncIterator) !== null && Nt !== void 0 ? Nt : (Ht = Symbol.for) === null || Ht === void 0 ? void 0 : Ht.call(Symbol, "Symbol.asyncIterator")) !== null && Vt !== void 0 ? Vt : "@@asyncIterator";
          function Lr(n, o = "sync", a) {
            if (a === void 0)
              if (o === "async") {
                if (a = at(n, Qt), a === void 0) {
                  const _ = at(n, Symbol.iterator), S = Lr(n, "sync", _);
                  return Yn(S);
                }
              } else
                a = at(n, Symbol.iterator);
            if (a === void 0)
              throw new TypeError("The object is not iterable");
            const p = $2(a, n, []);
            if (!b(p))
              throw new TypeError("The iterator method must return an object");
            const g = p.next;
            return { iterator: p, nextMethod: g, done: false };
          }
          u(Lr, "GetIterator");
          function Gn(n) {
            const o = $2(n.nextMethod, n.iterator, []);
            if (!b(o))
              throw new TypeError("The iterator.next() method must return an object");
            return o;
          }
          u(Gn, "IteratorNext");
          function Zn(n) {
            return !!n.done;
          }
          u(Zn, "IteratorComplete");
          function Kn(n) {
            return n.value;
          }
          u(Kn, "IteratorValue");
          function Jn(n) {
            return !(typeof n != "number" || Ir(n) || n < 0);
          }
          u(Jn, "IsNonNegativeNumber");
          function Dr(n) {
            const o = jr(n.buffer, n.byteOffset, n.byteOffset + n.byteLength);
            return new Uint8Array(o);
          }
          u(Dr, "CloneAsUint8Array");
          function Yt(n) {
            const o = n._queue.shift();
            return n._queueTotalSize -= o.size, n._queueTotalSize < 0 && (n._queueTotalSize = 0), o.value;
          }
          u(Yt, "DequeueValue");
          function Gt(n, o, a) {
            if (!Jn(a) || a === 1 / 0)
              throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
            n._queue.push({ value: o, size: a }), n._queueTotalSize += a;
          }
          u(Gt, "EnqueueValueWithSize");
          function Xn(n) {
            return n._queue.peek().value;
          }
          u(Xn, "PeekQueueValue");
          function _e(n) {
            n._queue = new Q(), n._queueTotalSize = 0;
          }
          u(_e, "ResetQueue");
          function $r(n) {
            return n === DataView;
          }
          u($r, "isDataViewConstructor");
          function eo(n) {
            return $r(n.constructor);
          }
          u(eo, "isDataView");
          function to(n) {
            return $r(n) ? 1 : n.BYTES_PER_ELEMENT;
          }
          u(to, "arrayBufferViewElementSize");
          class Ee {
            static {
              u(this, "ReadableStreamBYOBRequest");
            }
            constructor() {
              throw new TypeError("Illegal constructor");
            }
            get view() {
              if (!Zt(this))
                throw tr("view");
              return this._view;
            }
            respond(o) {
              if (!Zt(this))
                throw tr("respond");
              if (le(o, 1, "respond"), o = Mt(o, "First parameter"), this._associatedReadableByteStreamController === void 0)
                throw new TypeError("This BYOB request has been invalidated");
              if (ge(this._view.buffer))
                throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");
              ft(this._associatedReadableByteStreamController, o);
            }
            respondWithNewView(o) {
              if (!Zt(this))
                throw tr("respondWithNewView");
              if (le(o, 1, "respondWithNewView"), !ArrayBuffer.isView(o))
                throw new TypeError("You can only respond with array buffer views");
              if (this._associatedReadableByteStreamController === void 0)
                throw new TypeError("This BYOB request has been invalidated");
              if (ge(o.buffer))
                throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");
              ct(this._associatedReadableByteStreamController, o);
            }
          }
          Object.defineProperties(Ee.prototype, { respond: { enumerable: true }, respondWithNewView: { enumerable: true }, view: { enumerable: true } }), w(Ee.prototype.respond, "respond"), w(Ee.prototype.respondWithNewView, "respondWithNewView"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(Ee.prototype, Symbol.toStringTag, { value: "ReadableStreamBYOBRequest", configurable: true });
          class ce {
            static {
              u(this, "ReadableByteStreamController");
            }
            constructor() {
              throw new TypeError("Illegal constructor");
            }
            get byobRequest() {
              if (!ve(this))
                throw Ge("byobRequest");
              return er(this);
            }
            get desiredSize() {
              if (!ve(this))
                throw Ge("desiredSize");
              return Zr(this);
            }
            close() {
              if (!ve(this))
                throw Ge("close");
              if (this._closeRequested)
                throw new TypeError("The stream has already been closed; do not close it again!");
              const o = this._controlledReadableByteStream._state;
              if (o !== "readable")
                throw new TypeError(`The stream (in ${o} state) is not in the readable state and cannot be closed`);
              Ye(this);
            }
            enqueue(o) {
              if (!ve(this))
                throw Ge("enqueue");
              if (le(o, 1, "enqueue"), !ArrayBuffer.isView(o))
                throw new TypeError("chunk must be an array buffer view");
              if (o.byteLength === 0)
                throw new TypeError("chunk must have non-zero byteLength");
              if (o.buffer.byteLength === 0)
                throw new TypeError("chunk's buffer must have non-zero byteLength");
              if (this._closeRequested)
                throw new TypeError("stream is closed or draining");
              const a = this._controlledReadableByteStream._state;
              if (a !== "readable")
                throw new TypeError(`The stream (in ${a} state) is not in the readable state and cannot be enqueued to`);
              lt(this, o);
            }
            error(o = void 0) {
              if (!ve(this))
                throw Ge("error");
              ee(this, o);
            }
            [Ot](o) {
              Mr(this), _e(this);
              const a = this._cancelAlgorithm(o);
              return ut(this), a;
            }
            [Ft](o) {
              const a = this._controlledReadableByteStream;
              if (this._queueTotalSize > 0) {
                Gr(this, o);
                return;
              }
              const p = this._autoAllocateChunkSize;
              if (p !== void 0) {
                let g;
                try {
                  g = new ArrayBuffer(p);
                } catch (S) {
                  o._errorSteps(S);
                  return;
                }
                const _ = { buffer: g, bufferByteLength: p, byteOffset: 0, byteLength: p, bytesFilled: 0, minimumFill: 1, elementSize: 1, viewConstructor: Uint8Array, readerType: "default" };
                this._pendingPullIntos.push(_);
              }
              Ar(a, o), Ae(this);
            }
            [It]() {
              if (this._pendingPullIntos.length > 0) {
                const o = this._pendingPullIntos.peek();
                o.readerType = "none", this._pendingPullIntos = new Q(), this._pendingPullIntos.push(o);
              }
            }
          }
          Object.defineProperties(ce.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, byobRequest: { enumerable: true }, desiredSize: { enumerable: true } }), w(ce.prototype.close, "close"), w(ce.prototype.enqueue, "enqueue"), w(ce.prototype.error, "error"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(ce.prototype, Symbol.toStringTag, { value: "ReadableByteStreamController", configurable: true });
          function ve(n) {
            return !b(n) || !Object.prototype.hasOwnProperty.call(n, "_controlledReadableByteStream") ? false : n instanceof ce;
          }
          u(ve, "IsReadableByteStreamController");
          function Zt(n) {
            return !b(n) || !Object.prototype.hasOwnProperty.call(n, "_associatedReadableByteStreamController") ? false : n instanceof Ee;
          }
          u(Zt, "IsReadableStreamBYOBRequest");
          function Ae(n) {
            if (!ao(n))
              return;
            if (n._pulling) {
              n._pullAgain = true;
              return;
            }
            n._pulling = true;
            const a = n._pullAlgorithm();
            E(a, () => (n._pulling = false, n._pullAgain && (n._pullAgain = false, Ae(n)), null), (p) => (ee(n, p), null));
          }
          u(Ae, "ReadableByteStreamControllerCallPullIfNeeded");
          function Mr(n) {
            Jt(n), n._pendingPullIntos = new Q();
          }
          u(Mr, "ReadableByteStreamControllerClearPendingPullIntos");
          function Kt(n, o) {
            let a = false;
            n._state === "closed" && (a = true);
            const p = xr(o);
            o.readerType === "default" ? Ut(n, p, a) : ho(n, p, a);
          }
          u(Kt, "ReadableByteStreamControllerCommitPullIntoDescriptor");
          function xr(n) {
            const o = n.bytesFilled, a = n.elementSize;
            return new n.viewConstructor(n.buffer, n.byteOffset, o / a);
          }
          u(xr, "ReadableByteStreamControllerConvertPullIntoDescriptor");
          function st(n, o, a, p) {
            n._queue.push({ buffer: o, byteOffset: a, byteLength: p }), n._queueTotalSize += p;
          }
          u(st, "ReadableByteStreamControllerEnqueueChunkToQueue");
          function Ur(n, o, a, p) {
            let g;
            try {
              g = jr(o, a, a + p);
            } catch (_) {
              throw ee(n, _), _;
            }
            st(n, g, 0, p);
          }
          u(Ur, "ReadableByteStreamControllerEnqueueClonedChunkToQueue");
          function Nr(n, o) {
            o.bytesFilled > 0 && Ur(n, o.buffer, o.byteOffset, o.bytesFilled), Ie(n);
          }
          u(Nr, "ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue");
          function Hr(n, o) {
            const a = Math.min(n._queueTotalSize, o.byteLength - o.bytesFilled), p = o.bytesFilled + a;
            let g = a, _ = false;
            const S = p % o.elementSize, C = p - S;
            C >= o.minimumFill && (g = C - o.bytesFilled, _ = true);
            const q = n._queue;
            for (; g > 0; ) {
              const P = q.peek(), k = Math.min(g, P.byteLength), O = o.byteOffset + o.bytesFilled;
              zr(o.buffer, O, P.buffer, P.byteOffset, k), P.byteLength === k ? q.shift() : (P.byteOffset += k, P.byteLength -= k), n._queueTotalSize -= k, Vr(n, k, o), g -= k;
            }
            return _;
          }
          u(Hr, "ReadableByteStreamControllerFillPullIntoDescriptorFromQueue");
          function Vr(n, o, a) {
            a.bytesFilled += o;
          }
          u(Vr, "ReadableByteStreamControllerFillHeadPullIntoDescriptor");
          function Qr(n) {
            n._queueTotalSize === 0 && n._closeRequested ? (ut(n), tt(n._controlledReadableByteStream)) : Ae(n);
          }
          u(Qr, "ReadableByteStreamControllerHandleQueueDrain");
          function Jt(n) {
            n._byobRequest !== null && (n._byobRequest._associatedReadableByteStreamController = void 0, n._byobRequest._view = null, n._byobRequest = null);
          }
          u(Jt, "ReadableByteStreamControllerInvalidateBYOBRequest");
          function Xt(n) {
            for (; n._pendingPullIntos.length > 0; ) {
              if (n._queueTotalSize === 0)
                return;
              const o = n._pendingPullIntos.peek();
              Hr(n, o) && (Ie(n), Kt(n._controlledReadableByteStream, o));
            }
          }
          u(Xt, "ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue");
          function ro(n) {
            const o = n._controlledReadableByteStream._reader;
            for (; o._readRequests.length > 0; ) {
              if (n._queueTotalSize === 0)
                return;
              const a = o._readRequests.shift();
              Gr(n, a);
            }
          }
          u(ro, "ReadableByteStreamControllerProcessReadRequestsUsingQueue");
          function no(n, o, a, p) {
            const g = n._controlledReadableByteStream, _ = o.constructor, S = to(_), { byteOffset: C, byteLength: q } = o, P = a * S;
            let k;
            try {
              k = fe(o.buffer);
            } catch (j) {
              p._errorSteps(j);
              return;
            }
            const O = { buffer: k, bufferByteLength: k.byteLength, byteOffset: C, byteLength: q, bytesFilled: 0, minimumFill: P, elementSize: S, viewConstructor: _, readerType: "byob" };
            if (n._pendingPullIntos.length > 0) {
              n._pendingPullIntos.push(O), Xr(g, p);
              return;
            }
            if (g._state === "closed") {
              const j = new _(O.buffer, O.byteOffset, 0);
              p._closeSteps(j);
              return;
            }
            if (n._queueTotalSize > 0) {
              if (Hr(n, O)) {
                const j = xr(O);
                Qr(n), p._chunkSteps(j);
                return;
              }
              if (n._closeRequested) {
                const j = new TypeError("Insufficient bytes to fill elements in the given buffer");
                ee(n, j), p._errorSteps(j);
                return;
              }
            }
            n._pendingPullIntos.push(O), Xr(g, p), Ae(n);
          }
          u(no, "ReadableByteStreamControllerPullInto");
          function oo(n, o) {
            o.readerType === "none" && Ie(n);
            const a = n._controlledReadableByteStream;
            if (rr(a))
              for (; en(a) > 0; ) {
                const p = Ie(n);
                Kt(a, p);
              }
          }
          u(oo, "ReadableByteStreamControllerRespondInClosedState");
          function io(n, o, a) {
            if (Vr(n, o, a), a.readerType === "none") {
              Nr(n, a), Xt(n);
              return;
            }
            if (a.bytesFilled < a.minimumFill)
              return;
            Ie(n);
            const p = a.bytesFilled % a.elementSize;
            if (p > 0) {
              const g = a.byteOffset + a.bytesFilled;
              Ur(n, a.buffer, g - p, p);
            }
            a.bytesFilled -= p, Kt(n._controlledReadableByteStream, a), Xt(n);
          }
          u(io, "ReadableByteStreamControllerRespondInReadableState");
          function Yr(n, o) {
            const a = n._pendingPullIntos.peek();
            Jt(n), n._controlledReadableByteStream._state === "closed" ? oo(n, a) : io(n, o, a), Ae(n);
          }
          u(Yr, "ReadableByteStreamControllerRespondInternal");
          function Ie(n) {
            return n._pendingPullIntos.shift();
          }
          u(Ie, "ReadableByteStreamControllerShiftPendingPullInto");
          function ao(n) {
            const o = n._controlledReadableByteStream;
            return o._state !== "readable" || n._closeRequested || !n._started ? false : !!(Br(o) && ot(o) > 0 || rr(o) && en(o) > 0 || Zr(n) > 0);
          }
          u(ao, "ReadableByteStreamControllerShouldCallPull");
          function ut(n) {
            n._pullAlgorithm = void 0, n._cancelAlgorithm = void 0;
          }
          u(ut, "ReadableByteStreamControllerClearAlgorithms");
          function Ye(n) {
            const o = n._controlledReadableByteStream;
            if (!(n._closeRequested || o._state !== "readable")) {
              if (n._queueTotalSize > 0) {
                n._closeRequested = true;
                return;
              }
              if (n._pendingPullIntos.length > 0) {
                const a = n._pendingPullIntos.peek();
                if (a.bytesFilled % a.elementSize !== 0) {
                  const p = new TypeError("Insufficient bytes to fill elements in the given buffer");
                  throw ee(n, p), p;
                }
              }
              ut(n), tt(o);
            }
          }
          u(Ye, "ReadableByteStreamControllerClose");
          function lt(n, o) {
            const a = n._controlledReadableByteStream;
            if (n._closeRequested || a._state !== "readable")
              return;
            const { buffer: p, byteOffset: g, byteLength: _ } = o;
            if (ge(p))
              throw new TypeError("chunk's buffer is detached and so cannot be enqueued");
            const S = fe(p);
            if (n._pendingPullIntos.length > 0) {
              const C = n._pendingPullIntos.peek();
              if (ge(C.buffer))
                throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");
              Jt(n), C.buffer = fe(C.buffer), C.readerType === "none" && Nr(n, C);
            }
            if (Br(a))
              if (ro(n), ot(a) === 0)
                st(n, S, g, _);
              else {
                n._pendingPullIntos.length > 0 && Ie(n);
                const C = new Uint8Array(S, g, _);
                Ut(a, C, false);
              }
            else
              rr(a) ? (st(n, S, g, _), Xt(n)) : st(n, S, g, _);
            Ae(n);
          }
          u(lt, "ReadableByteStreamControllerEnqueue");
          function ee(n, o) {
            const a = n._controlledReadableByteStream;
            a._state === "readable" && (Mr(n), _e(n), ut(n), Pn(a, o));
          }
          u(ee, "ReadableByteStreamControllerError");
          function Gr(n, o) {
            const a = n._queue.shift();
            n._queueTotalSize -= a.byteLength, Qr(n);
            const p = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
            o._chunkSteps(p);
          }
          u(Gr, "ReadableByteStreamControllerFillReadRequestFromQueue");
          function er(n) {
            if (n._byobRequest === null && n._pendingPullIntos.length > 0) {
              const o = n._pendingPullIntos.peek(), a = new Uint8Array(o.buffer, o.byteOffset + o.bytesFilled, o.byteLength - o.bytesFilled), p = Object.create(Ee.prototype);
              uo(p, n, a), n._byobRequest = p;
            }
            return n._byobRequest;
          }
          u(er, "ReadableByteStreamControllerGetBYOBRequest");
          function Zr(n) {
            const o = n._controlledReadableByteStream._state;
            return o === "errored" ? null : o === "closed" ? 0 : n._strategyHWM - n._queueTotalSize;
          }
          u(Zr, "ReadableByteStreamControllerGetDesiredSize");
          function ft(n, o) {
            const a = n._pendingPullIntos.peek();
            if (n._controlledReadableByteStream._state === "closed") {
              if (o !== 0)
                throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
            } else {
              if (o === 0)
                throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
              if (a.bytesFilled + o > a.byteLength)
                throw new RangeError("bytesWritten out of range");
            }
            a.buffer = fe(a.buffer), Yr(n, o);
          }
          u(ft, "ReadableByteStreamControllerRespond");
          function ct(n, o) {
            const a = n._pendingPullIntos.peek();
            if (n._controlledReadableByteStream._state === "closed") {
              if (o.byteLength !== 0)
                throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
            } else if (o.byteLength === 0)
              throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
            if (a.byteOffset + a.bytesFilled !== o.byteOffset)
              throw new RangeError("The region specified by view does not match byobRequest");
            if (a.bufferByteLength !== o.buffer.byteLength)
              throw new RangeError("The buffer of view has different capacity than byobRequest");
            if (a.bytesFilled + o.byteLength > a.byteLength)
              throw new RangeError("The region specified by view is larger than byobRequest");
            const g = o.byteLength;
            a.buffer = fe(o.buffer), Yr(n, g);
          }
          u(ct, "ReadableByteStreamControllerRespondWithNewView");
          function Kr(n, o, a, p, g, _, S) {
            o._controlledReadableByteStream = n, o._pullAgain = false, o._pulling = false, o._byobRequest = null, o._queue = o._queueTotalSize = void 0, _e(o), o._closeRequested = false, o._started = false, o._strategyHWM = _, o._pullAlgorithm = p, o._cancelAlgorithm = g, o._autoAllocateChunkSize = S, o._pendingPullIntos = new Q(), n._readableStreamController = o;
            const C = a();
            E(W(C), () => (o._started = true, Ae(o), null), (q) => (ee(o, q), null));
          }
          u(Kr, "SetUpReadableByteStreamController");
          function so(n, o, a) {
            const p = Object.create(ce.prototype);
            let g, _, S;
            o.start !== void 0 ? g = u(() => o.start(p), "startAlgorithm") : g = u(() => {
            }, "startAlgorithm"), o.pull !== void 0 ? _ = u(() => o.pull(p), "pullAlgorithm") : _ = u(() => W(void 0), "pullAlgorithm"), o.cancel !== void 0 ? S = u((q) => o.cancel(q), "cancelAlgorithm") : S = u(() => W(void 0), "cancelAlgorithm");
            const C = o.autoAllocateChunkSize;
            if (C === 0)
              throw new TypeError("autoAllocateChunkSize must be greater than 0");
            Kr(n, p, g, _, S, a, C);
          }
          u(so, "SetUpReadableByteStreamControllerFromUnderlyingSource");
          function uo(n, o, a) {
            n._associatedReadableByteStreamController = o, n._view = a;
          }
          u(uo, "SetUpReadableStreamBYOBRequest");
          function tr(n) {
            return new TypeError(`ReadableStreamBYOBRequest.prototype.${n} can only be used on a ReadableStreamBYOBRequest`);
          }
          u(tr, "byobRequestBrandCheckException");
          function Ge(n) {
            return new TypeError(`ReadableByteStreamController.prototype.${n} can only be used on a ReadableByteStreamController`);
          }
          u(Ge, "byteStreamControllerBrandCheckException");
          function lo(n, o) {
            ie(n, o);
            const a = n?.mode;
            return { mode: a === void 0 ? void 0 : fo(a, `${o} has member 'mode' that`) };
          }
          u(lo, "convertReaderOptions");
          function fo(n, o) {
            if (n = `${n}`, n !== "byob")
              throw new TypeError(`${o} '${n}' is not a valid enumeration value for ReadableStreamReaderMode`);
            return n;
          }
          u(fo, "convertReadableStreamReaderMode");
          function co(n, o) {
            var a;
            ie(n, o);
            const p = (a = n?.min) !== null && a !== void 0 ? a : 1;
            return { min: Mt(p, `${o} has member 'min' that`) };
          }
          u(co, "convertByobReadOptions");
          function Jr(n) {
            return new Se(n);
          }
          u(Jr, "AcquireReadableStreamBYOBReader");
          function Xr(n, o) {
            n._reader._readIntoRequests.push(o);
          }
          u(Xr, "ReadableStreamAddReadIntoRequest");
          function ho(n, o, a) {
            const g = n._reader._readIntoRequests.shift();
            a ? g._closeSteps(o) : g._chunkSteps(o);
          }
          u(ho, "ReadableStreamFulfillReadIntoRequest");
          function en(n) {
            return n._reader._readIntoRequests.length;
          }
          u(en, "ReadableStreamGetNumReadIntoRequests");
          function rr(n) {
            const o = n._reader;
            return !(o === void 0 || !Be(o));
          }
          u(rr, "ReadableStreamHasBYOBReader");
          class Se {
            static {
              u(this, "ReadableStreamBYOBReader");
            }
            constructor(o) {
              if (le(o, 1, "ReadableStreamBYOBReader"), xt(o, "First parameter"), Te(o))
                throw new TypeError("This stream has already been locked for exclusive reading by another reader");
              if (!ve(o._readableStreamController))
                throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
              Rr(this, o), this._readIntoRequests = new Q();
            }
            get closed() {
              return Be(this) ? this._closedPromise : T(dt("closed"));
            }
            cancel(o = void 0) {
              return Be(this) ? this._ownerReadableStream === void 0 ? T(nt("cancel")) : zt(this, o) : T(dt("cancel"));
            }
            read(o, a = {}) {
              if (!Be(this))
                return T(dt("read"));
              if (!ArrayBuffer.isView(o))
                return T(new TypeError("view must be an array buffer view"));
              if (o.byteLength === 0)
                return T(new TypeError("view must have non-zero byteLength"));
              if (o.buffer.byteLength === 0)
                return T(new TypeError("view's buffer must have non-zero byteLength"));
              if (ge(o.buffer))
                return T(new TypeError("view's buffer has been detached"));
              let p;
              try {
                p = co(a, "options");
              } catch (P) {
                return T(P);
              }
              const g = p.min;
              if (g === 0)
                return T(new TypeError("options.min must be greater than 0"));
              if (eo(o)) {
                if (g > o.byteLength)
                  return T(new RangeError("options.min must be less than or equal to view's byteLength"));
              } else if (g > o.length)
                return T(new RangeError("options.min must be less than or equal to view's length"));
              if (this._ownerReadableStream === void 0)
                return T(nt("read from"));
              let _, S;
              const C = z((P, k) => {
                _ = P, S = k;
              });
              return tn(this, o, g, { _chunkSteps: u((P) => _({ value: P, done: false }), "_chunkSteps"), _closeSteps: u((P) => _({ value: P, done: true }), "_closeSteps"), _errorSteps: u((P) => S(P), "_errorSteps") }), C;
            }
            releaseLock() {
              if (!Be(this))
                throw dt("releaseLock");
              this._ownerReadableStream !== void 0 && po(this);
            }
          }
          Object.defineProperties(Se.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), w(Se.prototype.cancel, "cancel"), w(Se.prototype.read, "read"), w(Se.prototype.releaseLock, "releaseLock"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(Se.prototype, Symbol.toStringTag, { value: "ReadableStreamBYOBReader", configurable: true });
          function Be(n) {
            return !b(n) || !Object.prototype.hasOwnProperty.call(n, "_readIntoRequests") ? false : n instanceof Se;
          }
          u(Be, "IsReadableStreamBYOBReader");
          function tn(n, o, a, p) {
            const g = n._ownerReadableStream;
            g._disturbed = true, g._state === "errored" ? p._errorSteps(g._storedError) : no(g._readableStreamController, o, a, p);
          }
          u(tn, "ReadableStreamBYOBReaderRead");
          function po(n) {
            ue(n);
            const o = new TypeError("Reader was released");
            rn(n, o);
          }
          u(po, "ReadableStreamBYOBReaderRelease");
          function rn(n, o) {
            const a = n._readIntoRequests;
            n._readIntoRequests = new Q(), a.forEach((p) => {
              p._errorSteps(o);
            });
          }
          u(rn, "ReadableStreamBYOBReaderErrorReadIntoRequests");
          function dt(n) {
            return new TypeError(`ReadableStreamBYOBReader.prototype.${n} can only be used on a ReadableStreamBYOBReader`);
          }
          u(dt, "byobReaderBrandCheckException");
          function Ze(n, o) {
            const { highWaterMark: a } = n;
            if (a === void 0)
              return o;
            if (Ir(a) || a < 0)
              throw new RangeError("Invalid highWaterMark");
            return a;
          }
          u(Ze, "ExtractHighWaterMark");
          function ht(n) {
            const { size: o } = n;
            return o || (() => 1);
          }
          u(ht, "ExtractSizeAlgorithm");
          function pt(n, o) {
            ie(n, o);
            const a = n?.highWaterMark, p = n?.size;
            return { highWaterMark: a === void 0 ? void 0 : $t(a), size: p === void 0 ? void 0 : bo(p, `${o} has member 'size' that`) };
          }
          u(pt, "convertQueuingStrategy");
          function bo(n, o) {
            return X(n, o), (a) => $t(n(a));
          }
          u(bo, "convertQueuingStrategySize");
          function mo(n, o) {
            ie(n, o);
            const a = n?.abort, p = n?.close, g = n?.start, _ = n?.type, S = n?.write;
            return { abort: a === void 0 ? void 0 : yo(a, n, `${o} has member 'abort' that`), close: p === void 0 ? void 0 : go(p, n, `${o} has member 'close' that`), start: g === void 0 ? void 0 : _o(g, n, `${o} has member 'start' that`), write: S === void 0 ? void 0 : So(S, n, `${o} has member 'write' that`), type: _ };
          }
          u(mo, "convertUnderlyingSink");
          function yo(n, o, a) {
            return X(n, a), (p) => N(n, o, [p]);
          }
          u(yo, "convertUnderlyingSinkAbortCallback");
          function go(n, o, a) {
            return X(n, a), () => N(n, o, []);
          }
          u(go, "convertUnderlyingSinkCloseCallback");
          function _o(n, o, a) {
            return X(n, a), (p) => $2(n, o, [p]);
          }
          u(_o, "convertUnderlyingSinkStartCallback");
          function So(n, o, a) {
            return X(n, a), (p, g) => N(n, o, [p, g]);
          }
          u(So, "convertUnderlyingSinkWriteCallback");
          function nn(n, o) {
            if (!ze(n))
              throw new TypeError(`${o} is not a WritableStream.`);
          }
          u(nn, "assertWritableStream");
          function wo(n) {
            if (typeof n != "object" || n === null)
              return false;
            try {
              return typeof n.aborted == "boolean";
            } catch {
              return false;
            }
          }
          u(wo, "isAbortSignal");
          const Ro = typeof AbortController == "function";
          function To() {
            if (Ro)
              return new AbortController();
          }
          u(To, "createAbortController");
          class we {
            static {
              u(this, "WritableStream");
            }
            constructor(o = {}, a = {}) {
              o === void 0 ? o = null : Er(o, "First parameter");
              const p = pt(a, "Second parameter"), g = mo(o, "First parameter");
              if (an(this), g.type !== void 0)
                throw new RangeError("Invalid type is specified");
              const S = ht(p), C = Ze(p, 1);
              jo(this, g, C, S);
            }
            get locked() {
              if (!ze(this))
                throw _t("locked");
              return je(this);
            }
            abort(o = void 0) {
              return ze(this) ? je(this) ? T(new TypeError("Cannot abort a stream that already has a writer")) : bt(this, o) : T(_t("abort"));
            }
            close() {
              return ze(this) ? je(this) ? T(new TypeError("Cannot close a stream that already has a writer")) : ae(this) ? T(new TypeError("Cannot close an already-closing stream")) : sn(this) : T(_t("close"));
            }
            getWriter() {
              if (!ze(this))
                throw _t("getWriter");
              return on(this);
            }
          }
          Object.defineProperties(we.prototype, { abort: { enumerable: true }, close: { enumerable: true }, getWriter: { enumerable: true }, locked: { enumerable: true } }), w(we.prototype.abort, "abort"), w(we.prototype.close, "close"), w(we.prototype.getWriter, "getWriter"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(we.prototype, Symbol.toStringTag, { value: "WritableStream", configurable: true });
          function on(n) {
            return new de(n);
          }
          u(on, "AcquireWritableStreamDefaultWriter");
          function Co(n, o, a, p, g = 1, _ = () => 1) {
            const S = Object.create(we.prototype);
            an(S);
            const C = Object.create(Le.prototype);
            return hn(S, C, n, o, a, p, g, _), S;
          }
          u(Co, "CreateWritableStream");
          function an(n) {
            n._state = "writable", n._storedError = void 0, n._writer = void 0, n._writableStreamController = void 0, n._writeRequests = new Q(), n._inFlightWriteRequest = void 0, n._closeRequest = void 0, n._inFlightCloseRequest = void 0, n._pendingAbortRequest = void 0, n._backpressure = false;
          }
          u(an, "InitializeWritableStream");
          function ze(n) {
            return !b(n) || !Object.prototype.hasOwnProperty.call(n, "_writableStreamController") ? false : n instanceof we;
          }
          u(ze, "IsWritableStream");
          function je(n) {
            return n._writer !== void 0;
          }
          u(je, "IsWritableStreamLocked");
          function bt(n, o) {
            var a;
            if (n._state === "closed" || n._state === "errored")
              return W(void 0);
            n._writableStreamController._abortReason = o, (a = n._writableStreamController._abortController) === null || a === void 0 || a.abort(o);
            const p = n._state;
            if (p === "closed" || p === "errored")
              return W(void 0);
            if (n._pendingAbortRequest !== void 0)
              return n._pendingAbortRequest._promise;
            let g = false;
            p === "erroring" && (g = true, o = void 0);
            const _ = z((S, C) => {
              n._pendingAbortRequest = { _promise: void 0, _resolve: S, _reject: C, _reason: o, _wasAlreadyErroring: g };
            });
            return n._pendingAbortRequest._promise = _, g || or(n, o), _;
          }
          u(bt, "WritableStreamAbort");
          function sn(n) {
            const o = n._state;
            if (o === "closed" || o === "errored")
              return T(new TypeError(`The stream (in ${o} state) is not in the writable state and cannot be closed`));
            const a = z((g, _) => {
              const S = { _resolve: g, _reject: _ };
              n._closeRequest = S;
            }), p = n._writer;
            return p !== void 0 && n._backpressure && o === "writable" && dr(p), Lo(n._writableStreamController), a;
          }
          u(sn, "WritableStreamClose");
          function Po(n) {
            return z((a, p) => {
              const g = { _resolve: a, _reject: p };
              n._writeRequests.push(g);
            });
          }
          u(Po, "WritableStreamAddWriteRequest");
          function nr(n, o) {
            if (n._state === "writable") {
              or(n, o);
              return;
            }
            ir(n);
          }
          u(nr, "WritableStreamDealWithRejection");
          function or(n, o) {
            const a = n._writableStreamController;
            n._state = "erroring", n._storedError = o;
            const p = n._writer;
            p !== void 0 && ln(p, o), !qo(n) && a._started && ir(n);
          }
          u(or, "WritableStreamStartErroring");
          function ir(n) {
            n._state = "errored", n._writableStreamController[wr]();
            const o = n._storedError;
            if (n._writeRequests.forEach((g) => {
              g._reject(o);
            }), n._writeRequests = new Q(), n._pendingAbortRequest === void 0) {
              mt(n);
              return;
            }
            const a = n._pendingAbortRequest;
            if (n._pendingAbortRequest = void 0, a._wasAlreadyErroring) {
              a._reject(o), mt(n);
              return;
            }
            const p = n._writableStreamController[rt](a._reason);
            E(p, () => (a._resolve(), mt(n), null), (g) => (a._reject(g), mt(n), null));
          }
          u(ir, "WritableStreamFinishErroring");
          function Eo(n) {
            n._inFlightWriteRequest._resolve(void 0), n._inFlightWriteRequest = void 0;
          }
          u(Eo, "WritableStreamFinishInFlightWrite");
          function vo(n, o) {
            n._inFlightWriteRequest._reject(o), n._inFlightWriteRequest = void 0, nr(n, o);
          }
          u(vo, "WritableStreamFinishInFlightWriteWithError");
          function Ao(n) {
            n._inFlightCloseRequest._resolve(void 0), n._inFlightCloseRequest = void 0, n._state === "erroring" && (n._storedError = void 0, n._pendingAbortRequest !== void 0 && (n._pendingAbortRequest._resolve(), n._pendingAbortRequest = void 0)), n._state = "closed";
            const a = n._writer;
            a !== void 0 && yn(a);
          }
          u(Ao, "WritableStreamFinishInFlightClose");
          function Bo(n, o) {
            n._inFlightCloseRequest._reject(o), n._inFlightCloseRequest = void 0, n._pendingAbortRequest !== void 0 && (n._pendingAbortRequest._reject(o), n._pendingAbortRequest = void 0), nr(n, o);
          }
          u(Bo, "WritableStreamFinishInFlightCloseWithError");
          function ae(n) {
            return !(n._closeRequest === void 0 && n._inFlightCloseRequest === void 0);
          }
          u(ae, "WritableStreamCloseQueuedOrInFlight");
          function qo(n) {
            return !(n._inFlightWriteRequest === void 0 && n._inFlightCloseRequest === void 0);
          }
          u(qo, "WritableStreamHasOperationMarkedInFlight");
          function Wo(n) {
            n._inFlightCloseRequest = n._closeRequest, n._closeRequest = void 0;
          }
          u(Wo, "WritableStreamMarkCloseRequestInFlight");
          function ko(n) {
            n._inFlightWriteRequest = n._writeRequests.shift();
          }
          u(ko, "WritableStreamMarkFirstWriteRequestInFlight");
          function mt(n) {
            n._closeRequest !== void 0 && (n._closeRequest._reject(n._storedError), n._closeRequest = void 0);
            const o = n._writer;
            o !== void 0 && fr(o, n._storedError);
          }
          u(mt, "WritableStreamRejectCloseAndClosedPromiseIfNeeded");
          function ar(n, o) {
            const a = n._writer;
            a !== void 0 && o !== n._backpressure && (o ? Ho(a) : dr(a)), n._backpressure = o;
          }
          u(ar, "WritableStreamUpdateBackpressure");
          class de {
            static {
              u(this, "WritableStreamDefaultWriter");
            }
            constructor(o) {
              if (le(o, 1, "WritableStreamDefaultWriter"), nn(o, "First parameter"), je(o))
                throw new TypeError("This stream has already been locked for exclusive writing by another writer");
              this._ownerWritableStream = o, o._writer = this;
              const a = o._state;
              if (a === "writable")
                !ae(o) && o._backpressure ? wt(this) : gn(this), St(this);
              else if (a === "erroring")
                cr(this, o._storedError), St(this);
              else if (a === "closed")
                gn(this), Uo(this);
              else {
                const p = o._storedError;
                cr(this, p), mn(this, p);
              }
            }
            get closed() {
              return qe(this) ? this._closedPromise : T(We("closed"));
            }
            get desiredSize() {
              if (!qe(this))
                throw We("desiredSize");
              if (this._ownerWritableStream === void 0)
                throw Je("desiredSize");
              return zo(this);
            }
            get ready() {
              return qe(this) ? this._readyPromise : T(We("ready"));
            }
            abort(o = void 0) {
              return qe(this) ? this._ownerWritableStream === void 0 ? T(Je("abort")) : Oo(this, o) : T(We("abort"));
            }
            close() {
              if (!qe(this))
                return T(We("close"));
              const o = this._ownerWritableStream;
              return o === void 0 ? T(Je("close")) : ae(o) ? T(new TypeError("Cannot close an already-closing stream")) : un(this);
            }
            releaseLock() {
              if (!qe(this))
                throw We("releaseLock");
              this._ownerWritableStream !== void 0 && fn(this);
            }
            write(o = void 0) {
              return qe(this) ? this._ownerWritableStream === void 0 ? T(Je("write to")) : cn(this, o) : T(We("write"));
            }
          }
          Object.defineProperties(de.prototype, { abort: { enumerable: true }, close: { enumerable: true }, releaseLock: { enumerable: true }, write: { enumerable: true }, closed: { enumerable: true }, desiredSize: { enumerable: true }, ready: { enumerable: true } }), w(de.prototype.abort, "abort"), w(de.prototype.close, "close"), w(de.prototype.releaseLock, "releaseLock"), w(de.prototype.write, "write"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(de.prototype, Symbol.toStringTag, { value: "WritableStreamDefaultWriter", configurable: true });
          function qe(n) {
            return !b(n) || !Object.prototype.hasOwnProperty.call(n, "_ownerWritableStream") ? false : n instanceof de;
          }
          u(qe, "IsWritableStreamDefaultWriter");
          function Oo(n, o) {
            const a = n._ownerWritableStream;
            return bt(a, o);
          }
          u(Oo, "WritableStreamDefaultWriterAbort");
          function un(n) {
            const o = n._ownerWritableStream;
            return sn(o);
          }
          u(un, "WritableStreamDefaultWriterClose");
          function Fo(n) {
            const o = n._ownerWritableStream, a = o._state;
            return ae(o) || a === "closed" ? W(void 0) : a === "errored" ? T(o._storedError) : un(n);
          }
          u(Fo, "WritableStreamDefaultWriterCloseWithErrorPropagation");
          function Io(n, o) {
            n._closedPromiseState === "pending" ? fr(n, o) : No(n, o);
          }
          u(Io, "WritableStreamDefaultWriterEnsureClosedPromiseRejected");
          function ln(n, o) {
            n._readyPromiseState === "pending" ? _n(n, o) : Vo(n, o);
          }
          u(ln, "WritableStreamDefaultWriterEnsureReadyPromiseRejected");
          function zo(n) {
            const o = n._ownerWritableStream, a = o._state;
            return a === "errored" || a === "erroring" ? null : a === "closed" ? 0 : pn(o._writableStreamController);
          }
          u(zo, "WritableStreamDefaultWriterGetDesiredSize");
          function fn(n) {
            const o = n._ownerWritableStream, a = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
            ln(n, a), Io(n, a), o._writer = void 0, n._ownerWritableStream = void 0;
          }
          u(fn, "WritableStreamDefaultWriterRelease");
          function cn(n, o) {
            const a = n._ownerWritableStream, p = a._writableStreamController, g = Do(p, o);
            if (a !== n._ownerWritableStream)
              return T(Je("write to"));
            const _ = a._state;
            if (_ === "errored")
              return T(a._storedError);
            if (ae(a) || _ === "closed")
              return T(new TypeError("The stream is closing or closed and cannot be written to"));
            if (_ === "erroring")
              return T(a._storedError);
            const S = Po(a);
            return $o(p, o, g), S;
          }
          u(cn, "WritableStreamDefaultWriterWrite");
          const dn = {};
          class Le {
            static {
              u(this, "WritableStreamDefaultController");
            }
            constructor() {
              throw new TypeError("Illegal constructor");
            }
            get abortReason() {
              if (!sr(this))
                throw lr("abortReason");
              return this._abortReason;
            }
            get signal() {
              if (!sr(this))
                throw lr("signal");
              if (this._abortController === void 0)
                throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
              return this._abortController.signal;
            }
            error(o = void 0) {
              if (!sr(this))
                throw lr("error");
              this._controlledWritableStream._state === "writable" && bn(this, o);
            }
            [rt](o) {
              const a = this._abortAlgorithm(o);
              return yt(this), a;
            }
            [wr]() {
              _e(this);
            }
          }
          Object.defineProperties(Le.prototype, { abortReason: { enumerable: true }, signal: { enumerable: true }, error: { enumerable: true } }), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(Le.prototype, Symbol.toStringTag, { value: "WritableStreamDefaultController", configurable: true });
          function sr(n) {
            return !b(n) || !Object.prototype.hasOwnProperty.call(n, "_controlledWritableStream") ? false : n instanceof Le;
          }
          u(sr, "IsWritableStreamDefaultController");
          function hn(n, o, a, p, g, _, S, C) {
            o._controlledWritableStream = n, n._writableStreamController = o, o._queue = void 0, o._queueTotalSize = void 0, _e(o), o._abortReason = void 0, o._abortController = To(), o._started = false, o._strategySizeAlgorithm = C, o._strategyHWM = S, o._writeAlgorithm = p, o._closeAlgorithm = g, o._abortAlgorithm = _;
            const q = ur(o);
            ar(n, q);
            const P = a(), k = W(P);
            E(k, () => (o._started = true, gt(o), null), (O) => (o._started = true, nr(n, O), null));
          }
          u(hn, "SetUpWritableStreamDefaultController");
          function jo(n, o, a, p) {
            const g = Object.create(Le.prototype);
            let _, S, C, q;
            o.start !== void 0 ? _ = u(() => o.start(g), "startAlgorithm") : _ = u(() => {
            }, "startAlgorithm"), o.write !== void 0 ? S = u((P) => o.write(P, g), "writeAlgorithm") : S = u(() => W(void 0), "writeAlgorithm"), o.close !== void 0 ? C = u(() => o.close(), "closeAlgorithm") : C = u(() => W(void 0), "closeAlgorithm"), o.abort !== void 0 ? q = u((P) => o.abort(P), "abortAlgorithm") : q = u(() => W(void 0), "abortAlgorithm"), hn(n, g, _, S, C, q, a, p);
          }
          u(jo, "SetUpWritableStreamDefaultControllerFromUnderlyingSink");
          function yt(n) {
            n._writeAlgorithm = void 0, n._closeAlgorithm = void 0, n._abortAlgorithm = void 0, n._strategySizeAlgorithm = void 0;
          }
          u(yt, "WritableStreamDefaultControllerClearAlgorithms");
          function Lo(n) {
            Gt(n, dn, 0), gt(n);
          }
          u(Lo, "WritableStreamDefaultControllerClose");
          function Do(n, o) {
            try {
              return n._strategySizeAlgorithm(o);
            } catch (a) {
              return Ke(n, a), 1;
            }
          }
          u(Do, "WritableStreamDefaultControllerGetChunkSize");
          function pn(n) {
            return n._strategyHWM - n._queueTotalSize;
          }
          u(pn, "WritableStreamDefaultControllerGetDesiredSize");
          function $o(n, o, a) {
            try {
              Gt(n, o, a);
            } catch (g) {
              Ke(n, g);
              return;
            }
            const p = n._controlledWritableStream;
            if (!ae(p) && p._state === "writable") {
              const g = ur(n);
              ar(p, g);
            }
            gt(n);
          }
          u($o, "WritableStreamDefaultControllerWrite");
          function gt(n) {
            const o = n._controlledWritableStream;
            if (!n._started || o._inFlightWriteRequest !== void 0)
              return;
            if (o._state === "erroring") {
              ir(o);
              return;
            }
            if (n._queue.length === 0)
              return;
            const p = Xn(n);
            p === dn ? Mo(n) : xo(n, p);
          }
          u(gt, "WritableStreamDefaultControllerAdvanceQueueIfNeeded");
          function Ke(n, o) {
            n._controlledWritableStream._state === "writable" && bn(n, o);
          }
          u(Ke, "WritableStreamDefaultControllerErrorIfNeeded");
          function Mo(n) {
            const o = n._controlledWritableStream;
            Wo(o), Yt(n);
            const a = n._closeAlgorithm();
            yt(n), E(a, () => (Ao(o), null), (p) => (Bo(o, p), null));
          }
          u(Mo, "WritableStreamDefaultControllerProcessClose");
          function xo(n, o) {
            const a = n._controlledWritableStream;
            ko(a);
            const p = n._writeAlgorithm(o);
            E(p, () => {
              Eo(a);
              const g = a._state;
              if (Yt(n), !ae(a) && g === "writable") {
                const _ = ur(n);
                ar(a, _);
              }
              return gt(n), null;
            }, (g) => (a._state === "writable" && yt(n), vo(a, g), null));
          }
          u(xo, "WritableStreamDefaultControllerProcessWrite");
          function ur(n) {
            return pn(n) <= 0;
          }
          u(ur, "WritableStreamDefaultControllerGetBackpressure");
          function bn(n, o) {
            const a = n._controlledWritableStream;
            yt(n), or(a, o);
          }
          u(bn, "WritableStreamDefaultControllerError");
          function _t(n) {
            return new TypeError(`WritableStream.prototype.${n} can only be used on a WritableStream`);
          }
          u(_t, "streamBrandCheckException$2");
          function lr(n) {
            return new TypeError(`WritableStreamDefaultController.prototype.${n} can only be used on a WritableStreamDefaultController`);
          }
          u(lr, "defaultControllerBrandCheckException$2");
          function We(n) {
            return new TypeError(`WritableStreamDefaultWriter.prototype.${n} can only be used on a WritableStreamDefaultWriter`);
          }
          u(We, "defaultWriterBrandCheckException");
          function Je(n) {
            return new TypeError("Cannot " + n + " a stream using a released writer");
          }
          u(Je, "defaultWriterLockException");
          function St(n) {
            n._closedPromise = z((o, a) => {
              n._closedPromise_resolve = o, n._closedPromise_reject = a, n._closedPromiseState = "pending";
            });
          }
          u(St, "defaultWriterClosedPromiseInitialize");
          function mn(n, o) {
            St(n), fr(n, o);
          }
          u(mn, "defaultWriterClosedPromiseInitializeAsRejected");
          function Uo(n) {
            St(n), yn(n);
          }
          u(Uo, "defaultWriterClosedPromiseInitializeAsResolved");
          function fr(n, o) {
            n._closedPromise_reject !== void 0 && (K(n._closedPromise), n._closedPromise_reject(o), n._closedPromise_resolve = void 0, n._closedPromise_reject = void 0, n._closedPromiseState = "rejected");
          }
          u(fr, "defaultWriterClosedPromiseReject");
          function No(n, o) {
            mn(n, o);
          }
          u(No, "defaultWriterClosedPromiseResetToRejected");
          function yn(n) {
            n._closedPromise_resolve !== void 0 && (n._closedPromise_resolve(void 0), n._closedPromise_resolve = void 0, n._closedPromise_reject = void 0, n._closedPromiseState = "resolved");
          }
          u(yn, "defaultWriterClosedPromiseResolve");
          function wt(n) {
            n._readyPromise = z((o, a) => {
              n._readyPromise_resolve = o, n._readyPromise_reject = a;
            }), n._readyPromiseState = "pending";
          }
          u(wt, "defaultWriterReadyPromiseInitialize");
          function cr(n, o) {
            wt(n), _n(n, o);
          }
          u(cr, "defaultWriterReadyPromiseInitializeAsRejected");
          function gn(n) {
            wt(n), dr(n);
          }
          u(gn, "defaultWriterReadyPromiseInitializeAsResolved");
          function _n(n, o) {
            n._readyPromise_reject !== void 0 && (K(n._readyPromise), n._readyPromise_reject(o), n._readyPromise_resolve = void 0, n._readyPromise_reject = void 0, n._readyPromiseState = "rejected");
          }
          u(_n, "defaultWriterReadyPromiseReject");
          function Ho(n) {
            wt(n);
          }
          u(Ho, "defaultWriterReadyPromiseReset");
          function Vo(n, o) {
            cr(n, o);
          }
          u(Vo, "defaultWriterReadyPromiseResetToRejected");
          function dr(n) {
            n._readyPromise_resolve !== void 0 && (n._readyPromise_resolve(void 0), n._readyPromise_resolve = void 0, n._readyPromise_reject = void 0, n._readyPromiseState = "fulfilled");
          }
          u(dr, "defaultWriterReadyPromiseResolve");
          function Qo() {
            if (typeof globalThis < "u")
              return globalThis;
            if (typeof self < "u")
              return self;
            if (typeof _commonjsHelpers.commonjsGlobal < "u")
              return _commonjsHelpers.commonjsGlobal;
          }
          u(Qo, "getGlobals");
          const hr = Qo();
          function Yo(n) {
            if (!(typeof n == "function" || typeof n == "object") || n.name !== "DOMException")
              return false;
            try {
              return new n(), true;
            } catch {
              return false;
            }
          }
          u(Yo, "isDOMExceptionConstructor");
          function Go() {
            const n = hr?.DOMException;
            return Yo(n) ? n : void 0;
          }
          u(Go, "getFromGlobal");
          function Zo() {
            const n = u(function(a, p) {
              this.message = a || "", this.name = p || "Error", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
            }, "DOMException");
            return w(n, "DOMException"), n.prototype = Object.create(Error.prototype), Object.defineProperty(n.prototype, "constructor", { value: n, writable: true, configurable: true }), n;
          }
          u(Zo, "createPolyfill");
          const Ko = Go() || Zo();
          function Sn(n, o, a, p, g, _) {
            const S = Fe(n), C = on(o);
            n._disturbed = true;
            let q = false, P = W(void 0);
            return z((k, O) => {
              let j;
              if (_ !== void 0) {
                if (j = u(() => {
                  const v = _.reason !== void 0 ? _.reason : new Ko("Aborted", "AbortError"), I = [];
                  p || I.push(() => o._state === "writable" ? bt(o, v) : W(void 0)), g || I.push(() => n._state === "readable" ? ne(n, v) : W(void 0)), G(() => Promise.all(I.map((L) => L())), true, v);
                }, "abortAlgorithm"), _.aborted) {
                  j();
                  return;
                }
                _.addEventListener("abort", j);
              }
              function oe() {
                return z((v, I) => {
                  function L(J) {
                    J ? v() : D(xe(), L, I);
                  }
                  u(L, "next"), L(false);
                });
              }
              u(oe, "pipeLoop");
              function xe() {
                return q ? W(true) : D(C._readyPromise, () => z((v, I) => {
                  Ve(S, { _chunkSteps: u((L) => {
                    P = D(cn(C, L), void 0, y), v(false);
                  }, "_chunkSteps"), _closeSteps: u(() => v(true), "_closeSteps"), _errorSteps: I });
                }));
              }
              if (u(xe, "pipeStep"), pe(n, S._closedPromise, (v) => (p ? te(true, v) : G(() => bt(o, v), true, v), null)), pe(o, C._closedPromise, (v) => (g ? te(true, v) : G(() => ne(n, v), true, v), null)), Y(n, S._closedPromise, () => (a ? te() : G(() => Fo(C)), null)), ae(o) || o._state === "closed") {
                const v = new TypeError("the destination writable stream closed before all data could be piped to it");
                g ? te(true, v) : G(() => ne(n, v), true, v);
              }
              K(oe());
              function Pe() {
                const v = P;
                return D(P, () => v !== P ? Pe() : void 0);
              }
              u(Pe, "waitForWritesToFinish");
              function pe(v, I, L) {
                v._state === "errored" ? L(v._storedError) : M(I, L);
              }
              u(pe, "isOrBecomesErrored");
              function Y(v, I, L) {
                v._state === "closed" ? L() : Z(I, L);
              }
              u(Y, "isOrBecomesClosed");
              function G(v, I, L) {
                if (q)
                  return;
                q = true, o._state === "writable" && !ae(o) ? Z(Pe(), J) : J();
                function J() {
                  return E(v(), () => be(I, L), (Ue) => be(true, Ue)), null;
                }
                u(J, "doTheRest");
              }
              u(G, "shutdownWithAction");
              function te(v, I) {
                q || (q = true, o._state === "writable" && !ae(o) ? Z(Pe(), () => be(v, I)) : be(v, I));
              }
              u(te, "shutdown");
              function be(v, I) {
                return fn(C), ue(S), _ !== void 0 && _.removeEventListener("abort", j), v ? O(I) : k(void 0), null;
              }
              u(be, "finalize");
            });
          }
          u(Sn, "ReadableStreamPipeTo");
          class he {
            static {
              u(this, "ReadableStreamDefaultController");
            }
            constructor() {
              throw new TypeError("Illegal constructor");
            }
            get desiredSize() {
              if (!Rt(this))
                throw Ct("desiredSize");
              return pr(this);
            }
            close() {
              if (!Rt(this))
                throw Ct("close");
              if (!$e(this))
                throw new TypeError("The stream is not in a state that permits close");
              ke(this);
            }
            enqueue(o = void 0) {
              if (!Rt(this))
                throw Ct("enqueue");
              if (!$e(this))
                throw new TypeError("The stream is not in a state that permits enqueue");
              return De(this, o);
            }
            error(o = void 0) {
              if (!Rt(this))
                throw Ct("error");
              re(this, o);
            }
            [Ot](o) {
              _e(this);
              const a = this._cancelAlgorithm(o);
              return Tt(this), a;
            }
            [Ft](o) {
              const a = this._controlledReadableStream;
              if (this._queue.length > 0) {
                const p = Yt(this);
                this._closeRequested && this._queue.length === 0 ? (Tt(this), tt(a)) : Xe(this), o._chunkSteps(p);
              } else
                Ar(a, o), Xe(this);
            }
            [It]() {
            }
          }
          Object.defineProperties(he.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, desiredSize: { enumerable: true } }), w(he.prototype.close, "close"), w(he.prototype.enqueue, "enqueue"), w(he.prototype.error, "error"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(he.prototype, Symbol.toStringTag, { value: "ReadableStreamDefaultController", configurable: true });
          function Rt(n) {
            return !b(n) || !Object.prototype.hasOwnProperty.call(n, "_controlledReadableStream") ? false : n instanceof he;
          }
          u(Rt, "IsReadableStreamDefaultController");
          function Xe(n) {
            if (!wn(n))
              return;
            if (n._pulling) {
              n._pullAgain = true;
              return;
            }
            n._pulling = true;
            const a = n._pullAlgorithm();
            E(a, () => (n._pulling = false, n._pullAgain && (n._pullAgain = false, Xe(n)), null), (p) => (re(n, p), null));
          }
          u(Xe, "ReadableStreamDefaultControllerCallPullIfNeeded");
          function wn(n) {
            const o = n._controlledReadableStream;
            return !$e(n) || !n._started ? false : !!(Te(o) && ot(o) > 0 || pr(n) > 0);
          }
          u(wn, "ReadableStreamDefaultControllerShouldCallPull");
          function Tt(n) {
            n._pullAlgorithm = void 0, n._cancelAlgorithm = void 0, n._strategySizeAlgorithm = void 0;
          }
          u(Tt, "ReadableStreamDefaultControllerClearAlgorithms");
          function ke(n) {
            if (!$e(n))
              return;
            const o = n._controlledReadableStream;
            n._closeRequested = true, n._queue.length === 0 && (Tt(n), tt(o));
          }
          u(ke, "ReadableStreamDefaultControllerClose");
          function De(n, o) {
            if (!$e(n))
              return;
            const a = n._controlledReadableStream;
            if (Te(a) && ot(a) > 0)
              Ut(a, o, false);
            else {
              let p;
              try {
                p = n._strategySizeAlgorithm(o);
              } catch (g) {
                throw re(n, g), g;
              }
              try {
                Gt(n, o, p);
              } catch (g) {
                throw re(n, g), g;
              }
            }
            Xe(n);
          }
          u(De, "ReadableStreamDefaultControllerEnqueue");
          function re(n, o) {
            const a = n._controlledReadableStream;
            a._state === "readable" && (_e(n), Tt(n), Pn(a, o));
          }
          u(re, "ReadableStreamDefaultControllerError");
          function pr(n) {
            const o = n._controlledReadableStream._state;
            return o === "errored" ? null : o === "closed" ? 0 : n._strategyHWM - n._queueTotalSize;
          }
          u(pr, "ReadableStreamDefaultControllerGetDesiredSize");
          function Jo(n) {
            return !wn(n);
          }
          u(Jo, "ReadableStreamDefaultControllerHasBackpressure");
          function $e(n) {
            const o = n._controlledReadableStream._state;
            return !n._closeRequested && o === "readable";
          }
          u($e, "ReadableStreamDefaultControllerCanCloseOrEnqueue");
          function Rn(n, o, a, p, g, _, S) {
            o._controlledReadableStream = n, o._queue = void 0, o._queueTotalSize = void 0, _e(o), o._started = false, o._closeRequested = false, o._pullAgain = false, o._pulling = false, o._strategySizeAlgorithm = S, o._strategyHWM = _, o._pullAlgorithm = p, o._cancelAlgorithm = g, n._readableStreamController = o;
            const C = a();
            E(W(C), () => (o._started = true, Xe(o), null), (q) => (re(o, q), null));
          }
          u(Rn, "SetUpReadableStreamDefaultController");
          function Xo(n, o, a, p) {
            const g = Object.create(he.prototype);
            let _, S, C;
            o.start !== void 0 ? _ = u(() => o.start(g), "startAlgorithm") : _ = u(() => {
            }, "startAlgorithm"), o.pull !== void 0 ? S = u(() => o.pull(g), "pullAlgorithm") : S = u(() => W(void 0), "pullAlgorithm"), o.cancel !== void 0 ? C = u((q) => o.cancel(q), "cancelAlgorithm") : C = u(() => W(void 0), "cancelAlgorithm"), Rn(n, g, _, S, C, a, p);
          }
          u(Xo, "SetUpReadableStreamDefaultControllerFromUnderlyingSource");
          function Ct(n) {
            return new TypeError(`ReadableStreamDefaultController.prototype.${n} can only be used on a ReadableStreamDefaultController`);
          }
          u(Ct, "defaultControllerBrandCheckException$1");
          function ei(n, o) {
            return ve(n._readableStreamController) ? ri(n) : ti(n);
          }
          u(ei, "ReadableStreamTee");
          function ti(n, o) {
            const a = Fe(n);
            let p = false, g = false, _ = false, S = false, C, q, P, k, O;
            const j = z((Y) => {
              O = Y;
            });
            function oe() {
              return p ? (g = true, W(void 0)) : (p = true, Ve(a, { _chunkSteps: u((G) => {
                se(() => {
                  g = false;
                  const te = G, be = G;
                  _ || De(P._readableStreamController, te), S || De(k._readableStreamController, be), p = false, g && oe();
                });
              }, "_chunkSteps"), _closeSteps: u(() => {
                p = false, _ || ke(P._readableStreamController), S || ke(k._readableStreamController), (!_ || !S) && O(void 0);
              }, "_closeSteps"), _errorSteps: u(() => {
                p = false;
              }, "_errorSteps") }), W(void 0));
            }
            u(oe, "pullAlgorithm");
            function xe(Y) {
              if (_ = true, C = Y, S) {
                const G = Qe([C, q]), te = ne(n, G);
                O(te);
              }
              return j;
            }
            u(xe, "cancel1Algorithm");
            function Pe(Y) {
              if (S = true, q = Y, _) {
                const G = Qe([C, q]), te = ne(n, G);
                O(te);
              }
              return j;
            }
            u(Pe, "cancel2Algorithm");
            function pe() {
            }
            return u(pe, "startAlgorithm"), P = et(pe, oe, xe), k = et(pe, oe, Pe), M(a._closedPromise, (Y) => (re(P._readableStreamController, Y), re(k._readableStreamController, Y), (!_ || !S) && O(void 0), null)), [P, k];
          }
          u(ti, "ReadableStreamDefaultTee");
          function ri(n) {
            let o = Fe(n), a = false, p = false, g = false, _ = false, S = false, C, q, P, k, O;
            const j = z((v) => {
              O = v;
            });
            function oe(v) {
              M(v._closedPromise, (I) => (v !== o || (ee(P._readableStreamController, I), ee(k._readableStreamController, I), (!_ || !S) && O(void 0)), null));
            }
            u(oe, "forwardReaderError");
            function xe() {
              Be(o) && (ue(o), o = Fe(n), oe(o)), Ve(o, { _chunkSteps: u((I) => {
                se(() => {
                  p = false, g = false;
                  const L = I;
                  let J = I;
                  if (!_ && !S)
                    try {
                      J = Dr(I);
                    } catch (Ue) {
                      ee(P._readableStreamController, Ue), ee(k._readableStreamController, Ue), O(ne(n, Ue));
                      return;
                    }
                  _ || lt(P._readableStreamController, L), S || lt(k._readableStreamController, J), a = false, p ? pe() : g && Y();
                });
              }, "_chunkSteps"), _closeSteps: u(() => {
                a = false, _ || Ye(P._readableStreamController), S || Ye(k._readableStreamController), P._readableStreamController._pendingPullIntos.length > 0 && ft(P._readableStreamController, 0), k._readableStreamController._pendingPullIntos.length > 0 && ft(k._readableStreamController, 0), (!_ || !S) && O(void 0);
              }, "_closeSteps"), _errorSteps: u(() => {
                a = false;
              }, "_errorSteps") });
            }
            u(xe, "pullWithDefaultReader");
            function Pe(v, I) {
              ye(o) && (ue(o), o = Jr(n), oe(o));
              const L = I ? k : P, J = I ? P : k;
              tn(o, v, 1, { _chunkSteps: u((Ne) => {
                se(() => {
                  p = false, g = false;
                  const He = I ? S : _;
                  if (I ? _ : S)
                    He || ct(L._readableStreamController, Ne);
                  else {
                    let Ln;
                    try {
                      Ln = Dr(Ne);
                    } catch (_r) {
                      ee(L._readableStreamController, _r), ee(J._readableStreamController, _r), O(ne(n, _r));
                      return;
                    }
                    He || ct(L._readableStreamController, Ne), lt(J._readableStreamController, Ln);
                  }
                  a = false, p ? pe() : g && Y();
                });
              }, "_chunkSteps"), _closeSteps: u((Ne) => {
                a = false;
                const He = I ? S : _, kt = I ? _ : S;
                He || Ye(L._readableStreamController), kt || Ye(J._readableStreamController), Ne !== void 0 && (He || ct(L._readableStreamController, Ne), !kt && J._readableStreamController._pendingPullIntos.length > 0 && ft(J._readableStreamController, 0)), (!He || !kt) && O(void 0);
              }, "_closeSteps"), _errorSteps: u(() => {
                a = false;
              }, "_errorSteps") });
            }
            u(Pe, "pullWithBYOBReader");
            function pe() {
              if (a)
                return p = true, W(void 0);
              a = true;
              const v = er(P._readableStreamController);
              return v === null ? xe() : Pe(v._view, false), W(void 0);
            }
            u(pe, "pull1Algorithm");
            function Y() {
              if (a)
                return g = true, W(void 0);
              a = true;
              const v = er(k._readableStreamController);
              return v === null ? xe() : Pe(v._view, true), W(void 0);
            }
            u(Y, "pull2Algorithm");
            function G(v) {
              if (_ = true, C = v, S) {
                const I = Qe([C, q]), L = ne(n, I);
                O(L);
              }
              return j;
            }
            u(G, "cancel1Algorithm");
            function te(v) {
              if (S = true, q = v, _) {
                const I = Qe([C, q]), L = ne(n, I);
                O(L);
              }
              return j;
            }
            u(te, "cancel2Algorithm");
            function be() {
            }
            return u(be, "startAlgorithm"), P = Cn(be, pe, G), k = Cn(be, Y, te), oe(o), [P, k];
          }
          u(ri, "ReadableByteStreamTee");
          function ni(n) {
            return b(n) && typeof n.getReader < "u";
          }
          u(ni, "isReadableStreamLike");
          function oi(n) {
            return ni(n) ? ai(n.getReader()) : ii(n);
          }
          u(oi, "ReadableStreamFrom");
          function ii(n) {
            let o;
            const a = Lr(n, "async"), p = y;
            function g() {
              let S;
              try {
                S = Gn(a);
              } catch (q) {
                return T(q);
              }
              const C = W(S);
              return U(C, (q) => {
                if (!b(q))
                  throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");
                if (Zn(q))
                  ke(o._readableStreamController);
                else {
                  const k = Kn(q);
                  De(o._readableStreamController, k);
                }
              });
            }
            u(g, "pullAlgorithm");
            function _(S) {
              const C = a.iterator;
              let q;
              try {
                q = at(C, "return");
              } catch (O) {
                return T(O);
              }
              if (q === void 0)
                return W(void 0);
              let P;
              try {
                P = $2(q, C, [S]);
              } catch (O) {
                return T(O);
              }
              const k = W(P);
              return U(k, (O) => {
                if (!b(O))
                  throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object");
              });
            }
            return u(_, "cancelAlgorithm"), o = et(p, g, _, 0), o;
          }
          u(ii, "ReadableStreamFromIterable");
          function ai(n) {
            let o;
            const a = y;
            function p() {
              let _;
              try {
                _ = n.read();
              } catch (S) {
                return T(S);
              }
              return U(_, (S) => {
                if (!b(S))
                  throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");
                if (S.done)
                  ke(o._readableStreamController);
                else {
                  const C = S.value;
                  De(o._readableStreamController, C);
                }
              });
            }
            u(p, "pullAlgorithm");
            function g(_) {
              try {
                return W(n.cancel(_));
              } catch (S) {
                return T(S);
              }
            }
            return u(g, "cancelAlgorithm"), o = et(a, p, g, 0), o;
          }
          u(ai, "ReadableStreamFromDefaultReader");
          function si(n, o) {
            ie(n, o);
            const a = n, p = a?.autoAllocateChunkSize, g = a?.cancel, _ = a?.pull, S = a?.start, C = a?.type;
            return { autoAllocateChunkSize: p === void 0 ? void 0 : Mt(p, `${o} has member 'autoAllocateChunkSize' that`), cancel: g === void 0 ? void 0 : ui(g, a, `${o} has member 'cancel' that`), pull: _ === void 0 ? void 0 : li(_, a, `${o} has member 'pull' that`), start: S === void 0 ? void 0 : fi(S, a, `${o} has member 'start' that`), type: C === void 0 ? void 0 : ci(C, `${o} has member 'type' that`) };
          }
          u(si, "convertUnderlyingDefaultOrByteSource");
          function ui(n, o, a) {
            return X(n, a), (p) => N(n, o, [p]);
          }
          u(ui, "convertUnderlyingSourceCancelCallback");
          function li(n, o, a) {
            return X(n, a), (p) => N(n, o, [p]);
          }
          u(li, "convertUnderlyingSourcePullCallback");
          function fi(n, o, a) {
            return X(n, a), (p) => $2(n, o, [p]);
          }
          u(fi, "convertUnderlyingSourceStartCallback");
          function ci(n, o) {
            if (n = `${n}`, n !== "bytes")
              throw new TypeError(`${o} '${n}' is not a valid enumeration value for ReadableStreamType`);
            return n;
          }
          u(ci, "convertReadableStreamType");
          function di(n, o) {
            return ie(n, o), { preventCancel: !!n?.preventCancel };
          }
          u(di, "convertIteratorOptions");
          function Tn(n, o) {
            ie(n, o);
            const a = n?.preventAbort, p = n?.preventCancel, g = n?.preventClose, _ = n?.signal;
            return _ !== void 0 && hi(_, `${o} has member 'signal' that`), { preventAbort: !!a, preventCancel: !!p, preventClose: !!g, signal: _ };
          }
          u(Tn, "convertPipeOptions");
          function hi(n, o) {
            if (!wo(n))
              throw new TypeError(`${o} is not an AbortSignal.`);
          }
          u(hi, "assertAbortSignal");
          function pi(n, o) {
            ie(n, o);
            const a = n?.readable;
            Dt(a, "readable", "ReadableWritablePair"), xt(a, `${o} has member 'readable' that`);
            const p = n?.writable;
            return Dt(p, "writable", "ReadableWritablePair"), nn(p, `${o} has member 'writable' that`), { readable: a, writable: p };
          }
          u(pi, "convertReadableWritablePair");
          class H {
            static {
              u(this, "ReadableStream");
            }
            constructor(o = {}, a = {}) {
              o === void 0 ? o = null : Er(o, "First parameter");
              const p = pt(a, "Second parameter"), g = si(o, "First parameter");
              if (br(this), g.type === "bytes") {
                if (p.size !== void 0)
                  throw new RangeError("The strategy for a byte stream cannot have a size function");
                const _ = Ze(p, 0);
                so(this, g, _);
              } else {
                const _ = ht(p), S = Ze(p, 1);
                Xo(this, g, S, _);
              }
            }
            get locked() {
              if (!Re(this))
                throw Oe("locked");
              return Te(this);
            }
            cancel(o = void 0) {
              return Re(this) ? Te(this) ? T(new TypeError("Cannot cancel a stream that already has a reader")) : ne(this, o) : T(Oe("cancel"));
            }
            getReader(o = void 0) {
              if (!Re(this))
                throw Oe("getReader");
              return lo(o, "First parameter").mode === void 0 ? Fe(this) : Jr(this);
            }
            pipeThrough(o, a = {}) {
              if (!Re(this))
                throw Oe("pipeThrough");
              le(o, 1, "pipeThrough");
              const p = pi(o, "First parameter"), g = Tn(a, "Second parameter");
              if (Te(this))
                throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
              if (je(p.writable))
                throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
              const _ = Sn(this, p.writable, g.preventClose, g.preventAbort, g.preventCancel, g.signal);
              return K(_), p.readable;
            }
            pipeTo(o, a = {}) {
              if (!Re(this))
                return T(Oe("pipeTo"));
              if (o === void 0)
                return T("Parameter 1 is required in 'pipeTo'.");
              if (!ze(o))
                return T(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
              let p;
              try {
                p = Tn(a, "Second parameter");
              } catch (g) {
                return T(g);
              }
              return Te(this) ? T(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")) : je(o) ? T(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")) : Sn(this, o, p.preventClose, p.preventAbort, p.preventCancel, p.signal);
            }
            tee() {
              if (!Re(this))
                throw Oe("tee");
              const o = ei(this);
              return Qe(o);
            }
            values(o = void 0) {
              if (!Re(this))
                throw Oe("values");
              const a = di(o, "First parameter");
              return Qn(this, a.preventCancel);
            }
            [Qt](o) {
              return this.values(o);
            }
            static from(o) {
              return oi(o);
            }
          }
          Object.defineProperties(H, { from: { enumerable: true } }), Object.defineProperties(H.prototype, { cancel: { enumerable: true }, getReader: { enumerable: true }, pipeThrough: { enumerable: true }, pipeTo: { enumerable: true }, tee: { enumerable: true }, values: { enumerable: true }, locked: { enumerable: true } }), w(H.from, "from"), w(H.prototype.cancel, "cancel"), w(H.prototype.getReader, "getReader"), w(H.prototype.pipeThrough, "pipeThrough"), w(H.prototype.pipeTo, "pipeTo"), w(H.prototype.tee, "tee"), w(H.prototype.values, "values"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(H.prototype, Symbol.toStringTag, { value: "ReadableStream", configurable: true }), Object.defineProperty(H.prototype, Qt, { value: H.prototype.values, writable: true, configurable: true });
          function et(n, o, a, p = 1, g = () => 1) {
            const _ = Object.create(H.prototype);
            br(_);
            const S = Object.create(he.prototype);
            return Rn(_, S, n, o, a, p, g), _;
          }
          u(et, "CreateReadableStream");
          function Cn(n, o, a) {
            const p = Object.create(H.prototype);
            br(p);
            const g = Object.create(ce.prototype);
            return Kr(p, g, n, o, a, 0, void 0), p;
          }
          u(Cn, "CreateReadableByteStream");
          function br(n) {
            n._state = "readable", n._reader = void 0, n._storedError = void 0, n._disturbed = false;
          }
          u(br, "InitializeReadableStream");
          function Re(n) {
            return !b(n) || !Object.prototype.hasOwnProperty.call(n, "_readableStreamController") ? false : n instanceof H;
          }
          u(Re, "IsReadableStream");
          function Te(n) {
            return n._reader !== void 0;
          }
          u(Te, "IsReadableStreamLocked");
          function ne(n, o) {
            if (n._disturbed = true, n._state === "closed")
              return W(void 0);
            if (n._state === "errored")
              return T(n._storedError);
            tt(n);
            const a = n._reader;
            if (a !== void 0 && Be(a)) {
              const g = a._readIntoRequests;
              a._readIntoRequests = new Q(), g.forEach((_) => {
                _._closeSteps(void 0);
              });
            }
            const p = n._readableStreamController[Ot](o);
            return U(p, y);
          }
          u(ne, "ReadableStreamCancel");
          function tt(n) {
            n._state = "closed";
            const o = n._reader;
            if (o !== void 0 && (Cr(o), ye(o))) {
              const a = o._readRequests;
              o._readRequests = new Q(), a.forEach((p) => {
                p._closeSteps();
              });
            }
          }
          u(tt, "ReadableStreamClose");
          function Pn(n, o) {
            n._state = "errored", n._storedError = o;
            const a = n._reader;
            a !== void 0 && (Lt(a, o), ye(a) ? qr(a, o) : rn(a, o));
          }
          u(Pn, "ReadableStreamError");
          function Oe(n) {
            return new TypeError(`ReadableStream.prototype.${n} can only be used on a ReadableStream`);
          }
          u(Oe, "streamBrandCheckException$1");
          function En(n, o) {
            ie(n, o);
            const a = n?.highWaterMark;
            return Dt(a, "highWaterMark", "QueuingStrategyInit"), { highWaterMark: $t(a) };
          }
          u(En, "convertQueuingStrategyInit");
          const vn = u((n) => n.byteLength, "byteLengthSizeFunction");
          w(vn, "size");
          class Pt {
            static {
              u(this, "ByteLengthQueuingStrategy");
            }
            constructor(o) {
              le(o, 1, "ByteLengthQueuingStrategy"), o = En(o, "First parameter"), this._byteLengthQueuingStrategyHighWaterMark = o.highWaterMark;
            }
            get highWaterMark() {
              if (!Bn(this))
                throw An("highWaterMark");
              return this._byteLengthQueuingStrategyHighWaterMark;
            }
            get size() {
              if (!Bn(this))
                throw An("size");
              return vn;
            }
          }
          Object.defineProperties(Pt.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(Pt.prototype, Symbol.toStringTag, { value: "ByteLengthQueuingStrategy", configurable: true });
          function An(n) {
            return new TypeError(`ByteLengthQueuingStrategy.prototype.${n} can only be used on a ByteLengthQueuingStrategy`);
          }
          u(An, "byteLengthBrandCheckException");
          function Bn(n) {
            return !b(n) || !Object.prototype.hasOwnProperty.call(n, "_byteLengthQueuingStrategyHighWaterMark") ? false : n instanceof Pt;
          }
          u(Bn, "IsByteLengthQueuingStrategy");
          const qn = u(() => 1, "countSizeFunction");
          w(qn, "size");
          class Et {
            static {
              u(this, "CountQueuingStrategy");
            }
            constructor(o) {
              le(o, 1, "CountQueuingStrategy"), o = En(o, "First parameter"), this._countQueuingStrategyHighWaterMark = o.highWaterMark;
            }
            get highWaterMark() {
              if (!kn(this))
                throw Wn("highWaterMark");
              return this._countQueuingStrategyHighWaterMark;
            }
            get size() {
              if (!kn(this))
                throw Wn("size");
              return qn;
            }
          }
          Object.defineProperties(Et.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(Et.prototype, Symbol.toStringTag, { value: "CountQueuingStrategy", configurable: true });
          function Wn(n) {
            return new TypeError(`CountQueuingStrategy.prototype.${n} can only be used on a CountQueuingStrategy`);
          }
          u(Wn, "countBrandCheckException");
          function kn(n) {
            return !b(n) || !Object.prototype.hasOwnProperty.call(n, "_countQueuingStrategyHighWaterMark") ? false : n instanceof Et;
          }
          u(kn, "IsCountQueuingStrategy");
          function bi(n, o) {
            ie(n, o);
            const a = n?.cancel, p = n?.flush, g = n?.readableType, _ = n?.start, S = n?.transform, C = n?.writableType;
            return { cancel: a === void 0 ? void 0 : _i(a, n, `${o} has member 'cancel' that`), flush: p === void 0 ? void 0 : mi(p, n, `${o} has member 'flush' that`), readableType: g, start: _ === void 0 ? void 0 : yi(_, n, `${o} has member 'start' that`), transform: S === void 0 ? void 0 : gi(S, n, `${o} has member 'transform' that`), writableType: C };
          }
          u(bi, "convertTransformer");
          function mi(n, o, a) {
            return X(n, a), (p) => N(n, o, [p]);
          }
          u(mi, "convertTransformerFlushCallback");
          function yi(n, o, a) {
            return X(n, a), (p) => $2(n, o, [p]);
          }
          u(yi, "convertTransformerStartCallback");
          function gi(n, o, a) {
            return X(n, a), (p, g) => N(n, o, [p, g]);
          }
          u(gi, "convertTransformerTransformCallback");
          function _i(n, o, a) {
            return X(n, a), (p) => N(n, o, [p]);
          }
          u(_i, "convertTransformerCancelCallback");
          class vt {
            static {
              u(this, "TransformStream");
            }
            constructor(o = {}, a = {}, p = {}) {
              o === void 0 && (o = null);
              const g = pt(a, "Second parameter"), _ = pt(p, "Third parameter"), S = bi(o, "First parameter");
              if (S.readableType !== void 0)
                throw new RangeError("Invalid readableType specified");
              if (S.writableType !== void 0)
                throw new RangeError("Invalid writableType specified");
              const C = Ze(_, 0), q = ht(_), P = Ze(g, 1), k = ht(g);
              let O;
              const j = z((oe) => {
                O = oe;
              });
              Si(this, j, P, k, C, q), Ri(this, S), S.start !== void 0 ? O(S.start(this._transformStreamController)) : O(void 0);
            }
            get readable() {
              if (!On(this))
                throw jn("readable");
              return this._readable;
            }
            get writable() {
              if (!On(this))
                throw jn("writable");
              return this._writable;
            }
          }
          Object.defineProperties(vt.prototype, { readable: { enumerable: true }, writable: { enumerable: true } }), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(vt.prototype, Symbol.toStringTag, { value: "TransformStream", configurable: true });
          function Si(n, o, a, p, g, _) {
            function S() {
              return o;
            }
            u(S, "startAlgorithm");
            function C(j) {
              return Pi(n, j);
            }
            u(C, "writeAlgorithm");
            function q(j) {
              return Ei(n, j);
            }
            u(q, "abortAlgorithm");
            function P() {
              return vi(n);
            }
            u(P, "closeAlgorithm"), n._writable = Co(S, C, P, q, a, p);
            function k() {
              return Ai(n);
            }
            u(k, "pullAlgorithm");
            function O(j) {
              return Bi(n, j);
            }
            u(O, "cancelAlgorithm"), n._readable = et(S, k, O, g, _), n._backpressure = void 0, n._backpressureChangePromise = void 0, n._backpressureChangePromise_resolve = void 0, At(n, true), n._transformStreamController = void 0;
          }
          u(Si, "InitializeTransformStream");
          function On(n) {
            return !b(n) || !Object.prototype.hasOwnProperty.call(n, "_transformStreamController") ? false : n instanceof vt;
          }
          u(On, "IsTransformStream");
          function Fn(n, o) {
            re(n._readable._readableStreamController, o), mr(n, o);
          }
          u(Fn, "TransformStreamError");
          function mr(n, o) {
            qt(n._transformStreamController), Ke(n._writable._writableStreamController, o), yr(n);
          }
          u(mr, "TransformStreamErrorWritableAndUnblockWrite");
          function yr(n) {
            n._backpressure && At(n, false);
          }
          u(yr, "TransformStreamUnblockWrite");
          function At(n, o) {
            n._backpressureChangePromise !== void 0 && n._backpressureChangePromise_resolve(), n._backpressureChangePromise = z((a) => {
              n._backpressureChangePromise_resolve = a;
            }), n._backpressure = o;
          }
          u(At, "TransformStreamSetBackpressure");
          class Ce {
            static {
              u(this, "TransformStreamDefaultController");
            }
            constructor() {
              throw new TypeError("Illegal constructor");
            }
            get desiredSize() {
              if (!Bt(this))
                throw Wt("desiredSize");
              const o = this._controlledTransformStream._readable._readableStreamController;
              return pr(o);
            }
            enqueue(o = void 0) {
              if (!Bt(this))
                throw Wt("enqueue");
              In(this, o);
            }
            error(o = void 0) {
              if (!Bt(this))
                throw Wt("error");
              Ti(this, o);
            }
            terminate() {
              if (!Bt(this))
                throw Wt("terminate");
              Ci(this);
            }
          }
          Object.defineProperties(Ce.prototype, { enqueue: { enumerable: true }, error: { enumerable: true }, terminate: { enumerable: true }, desiredSize: { enumerable: true } }), w(Ce.prototype.enqueue, "enqueue"), w(Ce.prototype.error, "error"), w(Ce.prototype.terminate, "terminate"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(Ce.prototype, Symbol.toStringTag, { value: "TransformStreamDefaultController", configurable: true });
          function Bt(n) {
            return !b(n) || !Object.prototype.hasOwnProperty.call(n, "_controlledTransformStream") ? false : n instanceof Ce;
          }
          u(Bt, "IsTransformStreamDefaultController");
          function wi(n, o, a, p, g) {
            o._controlledTransformStream = n, n._transformStreamController = o, o._transformAlgorithm = a, o._flushAlgorithm = p, o._cancelAlgorithm = g, o._finishPromise = void 0, o._finishPromise_resolve = void 0, o._finishPromise_reject = void 0;
          }
          u(wi, "SetUpTransformStreamDefaultController");
          function Ri(n, o) {
            const a = Object.create(Ce.prototype);
            let p, g, _;
            o.transform !== void 0 ? p = u((S) => o.transform(S, a), "transformAlgorithm") : p = u((S) => {
              try {
                return In(a, S), W(void 0);
              } catch (C) {
                return T(C);
              }
            }, "transformAlgorithm"), o.flush !== void 0 ? g = u(() => o.flush(a), "flushAlgorithm") : g = u(() => W(void 0), "flushAlgorithm"), o.cancel !== void 0 ? _ = u((S) => o.cancel(S), "cancelAlgorithm") : _ = u(() => W(void 0), "cancelAlgorithm"), wi(n, a, p, g, _);
          }
          u(Ri, "SetUpTransformStreamDefaultControllerFromTransformer");
          function qt(n) {
            n._transformAlgorithm = void 0, n._flushAlgorithm = void 0, n._cancelAlgorithm = void 0;
          }
          u(qt, "TransformStreamDefaultControllerClearAlgorithms");
          function In(n, o) {
            const a = n._controlledTransformStream, p = a._readable._readableStreamController;
            if (!$e(p))
              throw new TypeError("Readable side is not in a state that permits enqueue");
            try {
              De(p, o);
            } catch (_) {
              throw mr(a, _), a._readable._storedError;
            }
            Jo(p) !== a._backpressure && At(a, true);
          }
          u(In, "TransformStreamDefaultControllerEnqueue");
          function Ti(n, o) {
            Fn(n._controlledTransformStream, o);
          }
          u(Ti, "TransformStreamDefaultControllerError");
          function zn(n, o) {
            const a = n._transformAlgorithm(o);
            return U(a, void 0, (p) => {
              throw Fn(n._controlledTransformStream, p), p;
            });
          }
          u(zn, "TransformStreamDefaultControllerPerformTransform");
          function Ci(n) {
            const o = n._controlledTransformStream, a = o._readable._readableStreamController;
            ke(a);
            const p = new TypeError("TransformStream terminated");
            mr(o, p);
          }
          u(Ci, "TransformStreamDefaultControllerTerminate");
          function Pi(n, o) {
            const a = n._transformStreamController;
            if (n._backpressure) {
              const p = n._backpressureChangePromise;
              return U(p, () => {
                const g = n._writable;
                if (g._state === "erroring")
                  throw g._storedError;
                return zn(a, o);
              });
            }
            return zn(a, o);
          }
          u(Pi, "TransformStreamDefaultSinkWriteAlgorithm");
          function Ei(n, o) {
            const a = n._transformStreamController;
            if (a._finishPromise !== void 0)
              return a._finishPromise;
            const p = n._readable;
            a._finishPromise = z((_, S) => {
              a._finishPromise_resolve = _, a._finishPromise_reject = S;
            });
            const g = a._cancelAlgorithm(o);
            return qt(a), E(g, () => (p._state === "errored" ? Me(a, p._storedError) : (re(p._readableStreamController, o), gr(a)), null), (_) => (re(p._readableStreamController, _), Me(a, _), null)), a._finishPromise;
          }
          u(Ei, "TransformStreamDefaultSinkAbortAlgorithm");
          function vi(n) {
            const o = n._transformStreamController;
            if (o._finishPromise !== void 0)
              return o._finishPromise;
            const a = n._readable;
            o._finishPromise = z((g, _) => {
              o._finishPromise_resolve = g, o._finishPromise_reject = _;
            });
            const p = o._flushAlgorithm();
            return qt(o), E(p, () => (a._state === "errored" ? Me(o, a._storedError) : (ke(a._readableStreamController), gr(o)), null), (g) => (re(a._readableStreamController, g), Me(o, g), null)), o._finishPromise;
          }
          u(vi, "TransformStreamDefaultSinkCloseAlgorithm");
          function Ai(n) {
            return At(n, false), n._backpressureChangePromise;
          }
          u(Ai, "TransformStreamDefaultSourcePullAlgorithm");
          function Bi(n, o) {
            const a = n._transformStreamController;
            if (a._finishPromise !== void 0)
              return a._finishPromise;
            const p = n._writable;
            a._finishPromise = z((_, S) => {
              a._finishPromise_resolve = _, a._finishPromise_reject = S;
            });
            const g = a._cancelAlgorithm(o);
            return qt(a), E(g, () => (p._state === "errored" ? Me(a, p._storedError) : (Ke(p._writableStreamController, o), yr(n), gr(a)), null), (_) => (Ke(p._writableStreamController, _), yr(n), Me(a, _), null)), a._finishPromise;
          }
          u(Bi, "TransformStreamDefaultSourceCancelAlgorithm");
          function Wt(n) {
            return new TypeError(`TransformStreamDefaultController.prototype.${n} can only be used on a TransformStreamDefaultController`);
          }
          u(Wt, "defaultControllerBrandCheckException");
          function gr(n) {
            n._finishPromise_resolve !== void 0 && (n._finishPromise_resolve(), n._finishPromise_resolve = void 0, n._finishPromise_reject = void 0);
          }
          u(gr, "defaultControllerFinishPromiseResolve");
          function Me(n, o) {
            n._finishPromise_reject !== void 0 && (K(n._finishPromise), n._finishPromise_reject(o), n._finishPromise_resolve = void 0, n._finishPromise_reject = void 0);
          }
          u(Me, "defaultControllerFinishPromiseReject");
          function jn(n) {
            return new TypeError(`TransformStream.prototype.${n} can only be used on a TransformStream`);
          }
          u(jn, "streamBrandCheckException"), d.ByteLengthQueuingStrategy = Pt, d.CountQueuingStrategy = Et, d.ReadableByteStreamController = ce, d.ReadableStream = H, d.ReadableStreamBYOBReader = Se, d.ReadableStreamBYOBRequest = Ee, d.ReadableStreamDefaultController = he, d.ReadableStreamDefaultReader = me, d.TransformStream = vt, d.TransformStreamDefaultController = Ce, d.WritableStream = we, d.WritableStreamDefaultController = Le, d.WritableStreamDefaultWriter = de;
        });
      }(ponyfill_es2018$1, ponyfill_es2018$1.exports)), ponyfill_es2018$1.exports;
    }
    u(requirePonyfill_es2018, "requirePonyfill_es2018");
    var hasRequiredStreams;
    function requireStreams() {
      if (hasRequiredStreams)
        return streams;
      hasRequiredStreams = 1;
      const c = 65536;
      if (!globalThis.ReadableStream)
        try {
          const l = require("node:process"), { emitWarning: d } = l;
          try {
            l.emitWarning = () => {
            }, Object.assign(globalThis, require("node:stream/web")), l.emitWarning = d;
          } catch (y) {
            throw l.emitWarning = d, y;
          }
        } catch {
          Object.assign(globalThis, requirePonyfill_es2018());
        }
      try {
        const { Blob: l } = require("buffer");
        l && !l.prototype.stream && (l.prototype.stream = u(function(y) {
          let b = 0;
          const R = this;
          return new ReadableStream({ type: "bytes", async pull(w) {
            const F = await R.slice(b, Math.min(R.size, b + c)).arrayBuffer();
            b += F.byteLength, w.enqueue(new Uint8Array(F)), b === R.size && w.close();
          } });
        }, "name"));
      } catch {
      }
      return streams;
    }
    u(requireStreams, "requireStreams"), requireStreams();
    var POOL_SIZE = 65536;
    async function* toIterator(c, l = true) {
      for (const d of c)
        if ("stream" in d)
          yield* d.stream();
        else if (ArrayBuffer.isView(d))
          if (l) {
            let y = d.byteOffset;
            const b = d.byteOffset + d.byteLength;
            for (; y !== b; ) {
              const R = Math.min(b - y, POOL_SIZE), w = d.buffer.slice(y, y + R);
              y += w.byteLength, yield new Uint8Array(w);
            }
          } else
            yield d;
        else {
          let y = 0, b = d;
          for (; y !== b.size; ) {
            const w = await b.slice(y, Math.min(b.size, y + POOL_SIZE)).arrayBuffer();
            y += w.byteLength, yield new Uint8Array(w);
          }
        }
    }
    u(toIterator, "toIterator");
    var _Blob = class Sr {
      static {
        u(this, "Blob");
      }
      #e = [];
      #t = "";
      #r = 0;
      #n = "transparent";
      constructor(l = [], d = {}) {
        if (typeof l != "object" || l === null)
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        if (typeof l[Symbol.iterator] != "function")
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        if (typeof d != "object" && typeof d != "function")
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        d === null && (d = {});
        const y = new TextEncoder();
        for (const R of l) {
          let w;
          ArrayBuffer.isView(R) ? w = new Uint8Array(R.buffer.slice(R.byteOffset, R.byteOffset + R.byteLength)) : R instanceof ArrayBuffer ? w = new Uint8Array(R.slice(0)) : R instanceof Sr ? w = R : w = y.encode(`${R}`), this.#r += ArrayBuffer.isView(w) ? w.byteLength : w.size, this.#e.push(w);
        }
        this.#n = `${d.endings === void 0 ? "transparent" : d.endings}`;
        const b = d.type === void 0 ? "" : String(d.type);
        this.#t = /^[\x20-\x7E]*$/.test(b) ? b : "";
      }
      get size() {
        return this.#r;
      }
      get type() {
        return this.#t;
      }
      async text() {
        const l = new TextDecoder();
        let d = "";
        for await (const y of toIterator(this.#e, false))
          d += l.decode(y, { stream: true });
        return d += l.decode(), d;
      }
      async arrayBuffer() {
        const l = new Uint8Array(this.size);
        let d = 0;
        for await (const y of toIterator(this.#e, false))
          l.set(y, d), d += y.length;
        return l.buffer;
      }
      stream() {
        const l = toIterator(this.#e, true);
        return new globalThis.ReadableStream({ type: "bytes", async pull(d) {
          const y = await l.next();
          y.done ? d.close() : d.enqueue(y.value);
        }, async cancel() {
          await l.return();
        } });
      }
      slice(l = 0, d = this.size, y = "") {
        const { size: b } = this;
        let R = l < 0 ? Math.max(b + l, 0) : Math.min(l, b), w = d < 0 ? Math.max(b + d, 0) : Math.min(d, b);
        const A = Math.max(w - R, 0), F = this.#e, B = [];
        let z = 0;
        for (const T of F) {
          if (z >= A)
            break;
          const D = ArrayBuffer.isView(T) ? T.byteLength : T.size;
          if (R && D <= R)
            R -= D, w -= D;
          else {
            let E;
            ArrayBuffer.isView(T) ? (E = T.subarray(R, Math.min(D, w)), z += E.byteLength) : (E = T.slice(R, Math.min(D, w)), z += E.size), w -= D, B.push(E), R = 0;
          }
        }
        const W = new Sr([], { type: String(y).toLowerCase() });
        return W.#r = A, W.#e = B, W;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](l) {
        return l && typeof l == "object" && typeof l.constructor == "function" && (typeof l.stream == "function" || typeof l.arrayBuffer == "function") && /^(Blob|File)$/.test(l[Symbol.toStringTag]);
      }
    };
    Object.defineProperties(_Blob.prototype, { size: { enumerable: true }, type: { enumerable: true }, slice: { enumerable: true } });
    var Blob2 = _Blob;
    var _File = class extends Blob2 {
      static {
        u(this, "File");
      }
      #e = 0;
      #t = "";
      constructor(l, d, y = {}) {
        if (arguments.length < 2)
          throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        super(l, y), y === null && (y = {});
        const b = y.lastModified === void 0 ? Date.now() : Number(y.lastModified);
        Number.isNaN(b) || (this.#e = b), this.#t = String(d);
      }
      get name() {
        return this.#t;
      }
      get lastModified() {
        return this.#e;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
      static [Symbol.hasInstance](l) {
        return !!l && l instanceof Blob2 && /^(File)$/.test(l[Symbol.toStringTag]);
      }
    };
    var File = _File;
    var { toStringTag: t$1, iterator: i, hasInstance: h } = Symbol;
    var r = Math.random;
    var m = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(",");
    var f = u((c, l, d) => (c += "", /^(Blob|File)$/.test(l && l[t$1]) ? [(d = d !== void 0 ? d + "" : l[t$1] == "File" ? l.name : "blob", c), l.name !== d || l[t$1] == "blob" ? new File([l], d, l) : l] : [c, l + ""]), "f");
    var e$1 = u((c, l) => (l ? c : c.replace(/\r?\n|\r/g, `\r
`)).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), "e$1");
    var x = u((c, l, d) => {
      if (l.length < d)
        throw new TypeError(`Failed to execute '${c}' on 'FormData': ${d} arguments required, but only ${l.length} present.`);
    }, "x");
    var FormData = class {
      static {
        u(this, "FormData");
      }
      #e = [];
      constructor(...l) {
        if (l.length)
          throw new TypeError("Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.");
      }
      get [t$1]() {
        return "FormData";
      }
      [i]() {
        return this.entries();
      }
      static [h](l) {
        return l && typeof l == "object" && l[t$1] === "FormData" && !m.some((d) => typeof l[d] != "function");
      }
      append(...l) {
        x("append", arguments, 2), this.#e.push(f(...l));
      }
      delete(l) {
        x("delete", arguments, 1), l += "", this.#e = this.#e.filter(([d]) => d !== l);
      }
      get(l) {
        x("get", arguments, 1), l += "";
        for (var d = this.#e, y = d.length, b = 0; b < y; b++)
          if (d[b][0] === l)
            return d[b][1];
        return null;
      }
      getAll(l, d) {
        return x("getAll", arguments, 1), d = [], l += "", this.#e.forEach((y) => y[0] === l && d.push(y[1])), d;
      }
      has(l) {
        return x("has", arguments, 1), l += "", this.#e.some((d) => d[0] === l);
      }
      forEach(l, d) {
        x("forEach", arguments, 1);
        for (var [y, b] of this)
          l.call(d, b, y, this);
      }
      set(...l) {
        x("set", arguments, 2);
        var d = [], y = true;
        l = f(...l), this.#e.forEach((b) => {
          b[0] === l[0] ? y && (y = !d.push(l)) : d.push(b);
        }), y && d.push(l), this.#e = d;
      }
      *entries() {
        yield* this.#e;
      }
      *keys() {
        for (var [l] of this)
          yield l;
      }
      *values() {
        for (var [, l] of this)
          yield l;
      }
    };
    function formDataToBlob(c, l = Blob2) {
      var d = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), y = [], b = `--${d}\r
Content-Disposition: form-data; name="`;
      return c.forEach((R, w) => typeof R == "string" ? y.push(b + e$1(w) + `"\r
\r
${R.replace(/\r(?!\n)|(?<!\r)\n/g, `\r
`)}\r
`) : y.push(b + e$1(w) + `"; filename="${e$1(R.name, 1)}"\r
Content-Type: ${R.type || "application/octet-stream"}\r
\r
`, R, `\r
`)), y.push(`--${d}--`), new l(y, { type: "multipart/form-data; boundary=" + d });
    }
    u(formDataToBlob, "formDataToBlob");
    var FetchBaseError = class extends Error {
      static {
        u(this, "FetchBaseError");
      }
      constructor(l, d) {
        super(l), Error.captureStackTrace(this, this.constructor), this.type = d;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    var FetchError = class extends FetchBaseError {
      static {
        u(this, "FetchError");
      }
      constructor(l, d, y) {
        super(l, d), y && (this.code = this.errno = y.code, this.erroredSysCall = y.syscall);
      }
    };
    var NAME = Symbol.toStringTag;
    var isURLSearchParameters = u((c) => typeof c == "object" && typeof c.append == "function" && typeof c.delete == "function" && typeof c.get == "function" && typeof c.getAll == "function" && typeof c.has == "function" && typeof c.set == "function" && typeof c.sort == "function" && c[NAME] === "URLSearchParams", "isURLSearchParameters");
    var isBlob = u((c) => c && typeof c == "object" && typeof c.arrayBuffer == "function" && typeof c.type == "string" && typeof c.stream == "function" && typeof c.constructor == "function" && /^(Blob|File)$/.test(c[NAME]), "isBlob");
    var isAbortSignal = u((c) => typeof c == "object" && (c[NAME] === "AbortSignal" || c[NAME] === "EventTarget"), "isAbortSignal");
    var isDomainOrSubdomain = u((c, l) => {
      const d = new URL(l).hostname, y = new URL(c).hostname;
      return d === y || d.endsWith(`.${y}`);
    }, "isDomainOrSubdomain");
    var isSameProtocol = u((c, l) => {
      const d = new URL(l).protocol, y = new URL(c).protocol;
      return d === y;
    }, "isSameProtocol");
    var pipeline2 = require$$0$1.promisify(Stream__default.pipeline);
    var INTERNALS$2 = Symbol("Body internals");
    var Body = class {
      static {
        u(this, "Body");
      }
      constructor(l, { size: d = 0 } = {}) {
        let y = null;
        l === null ? l = null : isURLSearchParameters(l) ? l = require$$0.Buffer.from(l.toString()) : isBlob(l) || require$$0.Buffer.isBuffer(l) || (require$$0$1.types.isAnyArrayBuffer(l) ? l = require$$0.Buffer.from(l) : ArrayBuffer.isView(l) ? l = require$$0.Buffer.from(l.buffer, l.byteOffset, l.byteLength) : l instanceof Stream__default || (l instanceof FormData ? (l = formDataToBlob(l), y = l.type.split("=")[1]) : l = require$$0.Buffer.from(String(l))));
        let b = l;
        require$$0.Buffer.isBuffer(l) ? b = Stream__default.Readable.from(l) : isBlob(l) && (b = Stream__default.Readable.from(l.stream())), this[INTERNALS$2] = { body: l, stream: b, boundary: y, disturbed: false, error: null }, this.size = d, l instanceof Stream__default && l.on("error", (R) => {
          const w = R instanceof FetchBaseError ? R : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${R.message}`, "system", R);
          this[INTERNALS$2].error = w;
        });
      }
      get body() {
        return this[INTERNALS$2].stream;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      async arrayBuffer() {
        const { buffer: l, byteOffset: d, byteLength: y } = await consumeBody(this);
        return l.slice(d, d + y);
      }
      async formData() {
        const l = this.headers.get("content-type");
        if (l.startsWith("application/x-www-form-urlencoded")) {
          const y = new FormData(), b = new URLSearchParams(await this.text());
          for (const [R, w] of b)
            y.append(R, w);
          return y;
        }
        const { toFormData: d } = await Promise.resolve().then(() => __toESM(require_multipart_parser()));
        return d(this.body, l);
      }
      async blob() {
        const l = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "", d = await this.arrayBuffer();
        return new Blob2([d], { type: l });
      }
      async json() {
        const l = await this.text();
        return JSON.parse(l);
      }
      async text() {
        const l = await consumeBody(this);
        return new TextDecoder().decode(l);
      }
      buffer() {
        return consumeBody(this);
      }
    };
    Body.prototype.buffer = require$$0$1.deprecate(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer"), Object.defineProperties(Body.prototype, { body: { enumerable: true }, bodyUsed: { enumerable: true }, arrayBuffer: { enumerable: true }, blob: { enumerable: true }, json: { enumerable: true }, text: { enumerable: true }, data: { get: require$$0$1.deprecate(() => {
    }, "data doesn't exist, use json(), text(), arrayBuffer(), or body instead", "https://github.com/node-fetch/node-fetch/issues/1000 (response)") } });
    async function consumeBody(c) {
      if (c[INTERNALS$2].disturbed)
        throw new TypeError(`body used already for: ${c.url}`);
      if (c[INTERNALS$2].disturbed = true, c[INTERNALS$2].error)
        throw c[INTERNALS$2].error;
      const { body: l } = c;
      if (l === null || !(l instanceof Stream__default))
        return require$$0.Buffer.alloc(0);
      const d = [];
      let y = 0;
      try {
        for await (const b of l) {
          if (c.size > 0 && y + b.length > c.size) {
            const R = new FetchError(`content size at ${c.url} over limit: ${c.size}`, "max-size");
            throw l.destroy(R), R;
          }
          y += b.length, d.push(b);
        }
      } catch (b) {
        throw b instanceof FetchBaseError ? b : new FetchError(`Invalid response body while trying to fetch ${c.url}: ${b.message}`, "system", b);
      }
      if (l.readableEnded === true || l._readableState.ended === true)
        try {
          return d.every((b) => typeof b == "string") ? require$$0.Buffer.from(d.join("")) : require$$0.Buffer.concat(d, y);
        } catch (b) {
          throw new FetchError(`Could not create Buffer from response body for ${c.url}: ${b.message}`, "system", b);
        }
      else
        throw new FetchError(`Premature close of server response while trying to fetch ${c.url}`);
    }
    u(consumeBody, "consumeBody");
    var clone = u((c, l) => {
      let d, y, { body: b } = c[INTERNALS$2];
      if (c.bodyUsed)
        throw new Error("cannot clone body after it is used");
      return b instanceof Stream__default && typeof b.getBoundary != "function" && (d = new Stream.PassThrough({ highWaterMark: l }), y = new Stream.PassThrough({ highWaterMark: l }), b.pipe(d), b.pipe(y), c[INTERNALS$2].stream = d, b = y), b;
    }, "clone");
    var getNonSpecFormDataBoundary = require$$0$1.deprecate((c) => c.getBoundary(), "form-data doesn't follow the spec and requires special treatment. Use alternative package", "https://github.com/node-fetch/node-fetch/issues/1167");
    var extractContentType = u((c, l) => c === null ? null : typeof c == "string" ? "text/plain;charset=UTF-8" : isURLSearchParameters(c) ? "application/x-www-form-urlencoded;charset=UTF-8" : isBlob(c) ? c.type || null : require$$0.Buffer.isBuffer(c) || require$$0$1.types.isAnyArrayBuffer(c) || ArrayBuffer.isView(c) ? null : c instanceof FormData ? `multipart/form-data; boundary=${l[INTERNALS$2].boundary}` : c && typeof c.getBoundary == "function" ? `multipart/form-data;boundary=${getNonSpecFormDataBoundary(c)}` : c instanceof Stream__default ? null : "text/plain;charset=UTF-8", "extractContentType");
    var getTotalBytes = u((c) => {
      const { body: l } = c[INTERNALS$2];
      return l === null ? 0 : isBlob(l) ? l.size : require$$0.Buffer.isBuffer(l) ? l.length : l && typeof l.getLengthSync == "function" && l.hasKnownLength && l.hasKnownLength() ? l.getLengthSync() : null;
    }, "getTotalBytes");
    var writeToStream = u(async (c, { body: l }) => {
      l === null ? c.end() : await pipeline2(l, c);
    }, "writeToStream");
    var validateHeaderName = typeof http__default.validateHeaderName == "function" ? http__default.validateHeaderName : (c) => {
      if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(c)) {
        const l = new TypeError(`Header name must be a valid HTTP token [${c}]`);
        throw Object.defineProperty(l, "code", { value: "ERR_INVALID_HTTP_TOKEN" }), l;
      }
    };
    var validateHeaderValue = typeof http__default.validateHeaderValue == "function" ? http__default.validateHeaderValue : (c, l) => {
      if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(l)) {
        const d = new TypeError(`Invalid character in header content ["${c}"]`);
        throw Object.defineProperty(d, "code", { value: "ERR_INVALID_CHAR" }), d;
      }
    };
    var Headers = class extends URLSearchParams {
      static {
        u(this, "Headers");
      }
      constructor(l) {
        let d = [];
        if (l instanceof Headers) {
          const y = l.raw();
          for (const [b, R] of Object.entries(y))
            d.push(...R.map((w) => [b, w]));
        } else if (l != null)
          if (typeof l == "object" && !require$$0$1.types.isBoxedPrimitive(l)) {
            const y = l[Symbol.iterator];
            if (y == null)
              d.push(...Object.entries(l));
            else {
              if (typeof y != "function")
                throw new TypeError("Header pairs must be iterable");
              d = [...l].map((b) => {
                if (typeof b != "object" || require$$0$1.types.isBoxedPrimitive(b))
                  throw new TypeError("Each header pair must be an iterable object");
                return [...b];
              }).map((b) => {
                if (b.length !== 2)
                  throw new TypeError("Each header pair must be a name/value tuple");
                return [...b];
              });
            }
          } else
            throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        return d = d.length > 0 ? d.map(([y, b]) => (validateHeaderName(y), validateHeaderValue(y, String(b)), [String(y).toLowerCase(), String(b)])) : void 0, super(d), new Proxy(this, { get(y, b, R) {
          switch (b) {
            case "append":
            case "set":
              return (w, A) => (validateHeaderName(w), validateHeaderValue(w, String(A)), URLSearchParams.prototype[b].call(y, String(w).toLowerCase(), String(A)));
            case "delete":
            case "has":
            case "getAll":
              return (w) => (validateHeaderName(w), URLSearchParams.prototype[b].call(y, String(w).toLowerCase()));
            case "keys":
              return () => (y.sort(), new Set(URLSearchParams.prototype.keys.call(y)).keys());
            default:
              return Reflect.get(y, b, R);
          }
        } });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      get(l) {
        const d = this.getAll(l);
        if (d.length === 0)
          return null;
        let y = d.join(", ");
        return /^content-encoding$/i.test(l) && (y = y.toLowerCase()), y;
      }
      forEach(l, d = void 0) {
        for (const y of this.keys())
          Reflect.apply(l, d, [this.get(y), y, this]);
      }
      *values() {
        for (const l of this.keys())
          yield this.get(l);
      }
      *entries() {
        for (const l of this.keys())
          yield [l, this.get(l)];
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      raw() {
        return [...this.keys()].reduce((l, d) => (l[d] = this.getAll(d), l), {});
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce((l, d) => {
          const y = this.getAll(d);
          return d === "host" ? l[d] = y[0] : l[d] = y.length > 1 ? y : y[0], l;
        }, {});
      }
    };
    Object.defineProperties(Headers.prototype, ["get", "entries", "forEach", "values"].reduce((c, l) => (c[l] = { enumerable: true }, c), {}));
    function fromRawHeaders(c = []) {
      return new Headers(c.reduce((l, d, y, b) => (y % 2 === 0 && l.push(b.slice(y, y + 2)), l), []).filter(([l, d]) => {
        try {
          return validateHeaderName(l), validateHeaderValue(l, String(d)), true;
        } catch {
          return false;
        }
      }));
    }
    u(fromRawHeaders, "fromRawHeaders");
    var redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
    var isRedirect = u((c) => redirectStatus.has(c), "isRedirect");
    var INTERNALS$1 = Symbol("Response internals");
    var Response = class extends Body {
      static {
        u(this, "Response");
      }
      constructor(l = null, d = {}) {
        super(l, d);
        const y = d.status != null ? d.status : 200, b = new Headers(d.headers);
        if (l !== null && !b.has("Content-Type")) {
          const R = extractContentType(l, this);
          R && b.append("Content-Type", R);
        }
        this[INTERNALS$1] = { type: "default", url: d.url, status: y, statusText: d.statusText || "", headers: b, counter: d.counter, highWaterMark: d.highWaterMark };
      }
      get type() {
        return this[INTERNALS$1].type;
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      clone() {
        return new Response(clone(this, this.highWaterMark), { type: this.type, url: this.url, status: this.status, statusText: this.statusText, headers: this.headers, ok: this.ok, redirected: this.redirected, size: this.size, highWaterMark: this.highWaterMark });
      }
      static redirect(l, d = 302) {
        if (!isRedirect(d))
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        return new Response(null, { headers: { location: new URL(l).toString() }, status: d });
      }
      static error() {
        const l = new Response(null, { status: 0, statusText: "" });
        return l[INTERNALS$1].type = "error", l;
      }
      static json(l = void 0, d = {}) {
        const y = JSON.stringify(l);
        if (y === void 0)
          throw new TypeError("data is not JSON serializable");
        const b = new Headers(d && d.headers);
        return b.has("content-type") || b.set("content-type", "application/json"), new Response(y, { ...d, headers: b });
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response.prototype, { type: { enumerable: true }, url: { enumerable: true }, status: { enumerable: true }, ok: { enumerable: true }, redirected: { enumerable: true }, statusText: { enumerable: true }, headers: { enumerable: true }, clone: { enumerable: true } });
    var getSearch = u((c) => {
      if (c.search)
        return c.search;
      const l = c.href.length - 1, d = c.hash || (c.href[l] === "#" ? "#" : "");
      return c.href[l - d.length] === "?" ? "?" : "";
    }, "getSearch");
    function stripURLForUseAsAReferrer(c, l = false) {
      return c == null || (c = new URL(c), /^(about|blob|data):$/.test(c.protocol)) ? "no-referrer" : (c.username = "", c.password = "", c.hash = "", l && (c.pathname = "", c.search = ""), c);
    }
    u(stripURLForUseAsAReferrer, "stripURLForUseAsAReferrer");
    var ReferrerPolicy = /* @__PURE__ */ new Set(["", "no-referrer", "no-referrer-when-downgrade", "same-origin", "origin", "strict-origin", "origin-when-cross-origin", "strict-origin-when-cross-origin", "unsafe-url"]);
    var DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
    function validateReferrerPolicy(c) {
      if (!ReferrerPolicy.has(c))
        throw new TypeError(`Invalid referrerPolicy: ${c}`);
      return c;
    }
    u(validateReferrerPolicy, "validateReferrerPolicy");
    function isOriginPotentiallyTrustworthy(c) {
      if (/^(http|ws)s:$/.test(c.protocol))
        return true;
      const l = c.host.replace(/(^\[)|(]$)/g, ""), d = require$$0$2.isIP(l);
      return d === 4 && /^127\./.test(l) || d === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(l) ? true : c.host === "localhost" || c.host.endsWith(".localhost") ? false : c.protocol === "file:";
    }
    u(isOriginPotentiallyTrustworthy, "isOriginPotentiallyTrustworthy");
    function isUrlPotentiallyTrustworthy(c) {
      return /^about:(blank|srcdoc)$/.test(c) || c.protocol === "data:" || /^(blob|filesystem):$/.test(c.protocol) ? true : isOriginPotentiallyTrustworthy(c);
    }
    u(isUrlPotentiallyTrustworthy, "isUrlPotentiallyTrustworthy");
    function determineRequestsReferrer(c, { referrerURLCallback: l, referrerOriginCallback: d } = {}) {
      if (c.referrer === "no-referrer" || c.referrerPolicy === "")
        return null;
      const y = c.referrerPolicy;
      if (c.referrer === "about:client")
        return "no-referrer";
      const b = c.referrer;
      let R = stripURLForUseAsAReferrer(b), w = stripURLForUseAsAReferrer(b, true);
      R.toString().length > 4096 && (R = w), l && (R = l(R)), d && (w = d(w));
      const A = new URL(c.url);
      switch (y) {
        case "no-referrer":
          return "no-referrer";
        case "origin":
          return w;
        case "unsafe-url":
          return R;
        case "strict-origin":
          return isUrlPotentiallyTrustworthy(R) && !isUrlPotentiallyTrustworthy(A) ? "no-referrer" : w.toString();
        case "strict-origin-when-cross-origin":
          return R.origin === A.origin ? R : isUrlPotentiallyTrustworthy(R) && !isUrlPotentiallyTrustworthy(A) ? "no-referrer" : w;
        case "same-origin":
          return R.origin === A.origin ? R : "no-referrer";
        case "origin-when-cross-origin":
          return R.origin === A.origin ? R : w;
        case "no-referrer-when-downgrade":
          return isUrlPotentiallyTrustworthy(R) && !isUrlPotentiallyTrustworthy(A) ? "no-referrer" : R;
        default:
          throw new TypeError(`Invalid referrerPolicy: ${y}`);
      }
    }
    u(determineRequestsReferrer, "determineRequestsReferrer");
    function parseReferrerPolicyFromHeader(c) {
      const l = (c.get("referrer-policy") || "").split(/[,\s]+/);
      let d = "";
      for (const y of l)
        y && ReferrerPolicy.has(y) && (d = y);
      return d;
    }
    u(parseReferrerPolicyFromHeader, "parseReferrerPolicyFromHeader");
    var INTERNALS = Symbol("Request internals");
    var isRequest = u((c) => typeof c == "object" && typeof c[INTERNALS] == "object", "isRequest");
    var doBadDataWarn = require$$0$1.deprecate(() => {
    }, ".data is not a valid RequestInit property, use .body instead", "https://github.com/node-fetch/node-fetch/issues/1000 (request)");
    var Request = class extends Body {
      static {
        u(this, "Request");
      }
      constructor(l, d = {}) {
        let y;
        if (isRequest(l) ? y = new URL(l.url) : (y = new URL(l), l = {}), y.username !== "" || y.password !== "")
          throw new TypeError(`${y} is an url with embedded credentials.`);
        let b = d.method || l.method || "GET";
        if (/^(delete|get|head|options|post|put)$/i.test(b) && (b = b.toUpperCase()), !isRequest(d) && "data" in d && doBadDataWarn(), (d.body != null || isRequest(l) && l.body !== null) && (b === "GET" || b === "HEAD"))
          throw new TypeError("Request with GET/HEAD method cannot have body");
        const R = d.body ? d.body : isRequest(l) && l.body !== null ? clone(l) : null;
        super(R, { size: d.size || l.size || 0 });
        const w = new Headers(d.headers || l.headers || {});
        if (R !== null && !w.has("Content-Type")) {
          const B = extractContentType(R, this);
          B && w.set("Content-Type", B);
        }
        let A = isRequest(l) ? l.signal : null;
        if ("signal" in d && (A = d.signal), A != null && !isAbortSignal(A))
          throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
        let F = d.referrer == null ? l.referrer : d.referrer;
        if (F === "")
          F = "no-referrer";
        else if (F) {
          const B = new URL(F);
          F = /^about:(\/\/)?client$/.test(B) ? "client" : B;
        } else
          F = void 0;
        this[INTERNALS] = { method: b, redirect: d.redirect || l.redirect || "follow", headers: w, parsedURL: y, signal: A, referrer: F }, this.follow = d.follow === void 0 ? l.follow === void 0 ? 20 : l.follow : d.follow, this.compress = d.compress === void 0 ? l.compress === void 0 ? true : l.compress : d.compress, this.counter = d.counter || l.counter || 0, this.agent = d.agent || l.agent, this.highWaterMark = d.highWaterMark || l.highWaterMark || 16384, this.insecureHTTPParser = d.insecureHTTPParser || l.insecureHTTPParser || false, this.referrerPolicy = d.referrerPolicy || l.referrerPolicy || "";
      }
      get method() {
        return this[INTERNALS].method;
      }
      get url() {
        return require$$1.format(this[INTERNALS].parsedURL);
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      get signal() {
        return this[INTERNALS].signal;
      }
      get referrer() {
        if (this[INTERNALS].referrer === "no-referrer")
          return "";
        if (this[INTERNALS].referrer === "client")
          return "about:client";
        if (this[INTERNALS].referrer)
          return this[INTERNALS].referrer.toString();
      }
      get referrerPolicy() {
        return this[INTERNALS].referrerPolicy;
      }
      set referrerPolicy(l) {
        this[INTERNALS].referrerPolicy = validateReferrerPolicy(l);
      }
      clone() {
        return new Request(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request.prototype, { method: { enumerable: true }, url: { enumerable: true }, headers: { enumerable: true }, redirect: { enumerable: true }, clone: { enumerable: true }, signal: { enumerable: true }, referrer: { enumerable: true }, referrerPolicy: { enumerable: true } });
    var getNodeRequestOptions = u((c) => {
      const { parsedURL: l } = c[INTERNALS], d = new Headers(c[INTERNALS].headers);
      d.has("Accept") || d.set("Accept", "*/*");
      let y = null;
      if (c.body === null && /^(post|put)$/i.test(c.method) && (y = "0"), c.body !== null) {
        const A = getTotalBytes(c);
        typeof A == "number" && !Number.isNaN(A) && (y = String(A));
      }
      y && d.set("Content-Length", y), c.referrerPolicy === "" && (c.referrerPolicy = DEFAULT_REFERRER_POLICY), c.referrer && c.referrer !== "no-referrer" ? c[INTERNALS].referrer = determineRequestsReferrer(c) : c[INTERNALS].referrer = "no-referrer", c[INTERNALS].referrer instanceof URL && d.set("Referer", c.referrer), d.has("User-Agent") || d.set("User-Agent", "node-fetch"), c.compress && !d.has("Accept-Encoding") && d.set("Accept-Encoding", "gzip, deflate, br");
      let { agent: b } = c;
      typeof b == "function" && (b = b(l));
      const R = getSearch(l), w = { path: l.pathname + R, method: c.method, headers: d[Symbol.for("nodejs.util.inspect.custom")](), insecureHTTPParser: c.insecureHTTPParser, agent: b };
      return { parsedURL: l, options: w };
    }, "getNodeRequestOptions");
    var AbortError = class extends FetchBaseError {
      static {
        u(this, "AbortError");
      }
      constructor(l, d = "aborted") {
        super(l, d);
      }
    };
    var nodeDomexception;
    var hasRequiredNodeDomexception;
    function requireNodeDomexception() {
      if (hasRequiredNodeDomexception)
        return nodeDomexception;
      if (hasRequiredNodeDomexception = 1, !globalThis.DOMException)
        try {
          const { MessageChannel: c } = require("worker_threads"), l = new c().port1, d = new ArrayBuffer();
          l.postMessage(d, [d, d]);
        } catch (c) {
          c.constructor.name === "DOMException" && (globalThis.DOMException = c.constructor);
        }
      return nodeDomexception = globalThis.DOMException, nodeDomexception;
    }
    u(requireNodeDomexception, "requireNodeDomexception");
    var nodeDomexceptionExports = requireNodeDomexception();
    var DOMException2 = _commonjsHelpers.getDefaultExportFromCjs(nodeDomexceptionExports);
    var { stat } = node_fs.promises;
    var blobFromSync = u((c, l) => fromBlob(node_fs.statSync(c), c, l), "blobFromSync");
    var blobFrom = u((c, l) => stat(c).then((d) => fromBlob(d, c, l)), "blobFrom");
    var fileFrom = u((c, l) => stat(c).then((d) => fromFile(d, c, l)), "fileFrom");
    var fileFromSync = u((c, l) => fromFile(node_fs.statSync(c), c, l), "fileFromSync");
    var fromBlob = u((c, l, d = "") => new Blob2([new BlobDataItem({ path: l, size: c.size, lastModified: c.mtimeMs, start: 0 })], { type: d }), "fromBlob");
    var fromFile = u((c, l, d = "") => new File([new BlobDataItem({ path: l, size: c.size, lastModified: c.mtimeMs, start: 0 })], node_path.basename(l), { type: d, lastModified: c.mtimeMs }), "fromFile");
    var BlobDataItem = class {
      static {
        u(this, "BlobDataItem");
      }
      #e;
      #t;
      constructor(l) {
        this.#e = l.path, this.#t = l.start, this.size = l.size, this.lastModified = l.lastModified;
      }
      slice(l, d) {
        return new BlobDataItem({ path: this.#e, lastModified: this.lastModified, size: d - l, start: this.#t + l });
      }
      async *stream() {
        const { mtimeMs: l } = await stat(this.#e);
        if (l > this.lastModified)
          throw new DOMException2("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.", "NotReadableError");
        yield* node_fs.createReadStream(this.#e, { start: this.#t, end: this.#t + this.size - 1 });
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
    };
    var supportedSchemas = /* @__PURE__ */ new Set(["data:", "http:", "https:"]);
    async function fetch$1(c, l) {
      return new Promise((d, y) => {
        const b = new Request(c, l), { parsedURL: R, options: w } = getNodeRequestOptions(b);
        if (!supportedSchemas.has(R.protocol))
          throw new TypeError(`node-fetch cannot load ${c}. URL scheme "${R.protocol.replace(/:$/, "")}" is not supported.`);
        if (R.protocol === "data:") {
          const E = dataUriToBuffer(b.url), Z = new Response(E, { headers: { "Content-Type": E.typeFull } });
          d(Z);
          return;
        }
        const A = (R.protocol === "https:" ? https__default : http__default).request, { signal: F } = b;
        let B = null;
        const z = u(() => {
          const E = new AbortError("The operation was aborted.");
          y(E), b.body && b.body instanceof Stream__default.Readable && b.body.destroy(E), !(!B || !B.body) && B.body.emit("error", E);
        }, "abort");
        if (F && F.aborted) {
          z();
          return;
        }
        const W = u(() => {
          z(), D();
        }, "abortAndFinalize"), T = A(R.toString(), w);
        F && F.addEventListener("abort", W);
        const D = u(() => {
          T.abort(), F && F.removeEventListener("abort", W);
        }, "finalize");
        T.on("error", (E) => {
          y(new FetchError(`request to ${b.url} failed, reason: ${E.message}`, "system", E)), D();
        }), fixResponseChunkedTransferBadEnding(T, (E) => {
          B && B.body && B.body.destroy(E);
        }), process.version < "v14" && T.on("socket", (E) => {
          let Z;
          E.prependListener("end", () => {
            Z = E._eventsCount;
          }), E.prependListener("close", (M) => {
            if (B && Z < E._eventsCount && !M) {
              const U = new Error("Premature close");
              U.code = "ERR_STREAM_PREMATURE_CLOSE", B.body.emit("error", U);
            }
          });
        }), T.on("response", (E) => {
          T.setTimeout(0);
          const Z = fromRawHeaders(E.rawHeaders);
          if (isRedirect(E.statusCode)) {
            const $2 = Z.get("Location");
            let N = null;
            try {
              N = $2 === null ? null : new URL($2, b.url);
            } catch {
              if (b.redirect !== "manual") {
                y(new FetchError(`uri requested responds with an invalid redirect URL: ${$2}`, "invalid-redirect")), D();
                return;
              }
            }
            switch (b.redirect) {
              case "error":
                y(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${b.url}`, "no-redirect")), D();
                return;
              case "manual":
                break;
              case "follow": {
                if (N === null)
                  break;
                if (b.counter >= b.follow) {
                  y(new FetchError(`maximum redirect reached at: ${b.url}`, "max-redirect")), D();
                  return;
                }
                const V = { headers: new Headers(b.headers), follow: b.follow, counter: b.counter + 1, agent: b.agent, compress: b.compress, method: b.method, body: clone(b), signal: b.signal, size: b.size, referrer: b.referrer, referrerPolicy: b.referrerPolicy };
                if (!isDomainOrSubdomain(b.url, N) || !isSameProtocol(b.url, N))
                  for (const rt of ["authorization", "www-authenticate", "cookie", "cookie2"])
                    V.headers.delete(rt);
                if (E.statusCode !== 303 && b.body && l.body instanceof Stream__default.Readable) {
                  y(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect")), D();
                  return;
                }
                (E.statusCode === 303 || (E.statusCode === 301 || E.statusCode === 302) && b.method === "POST") && (V.method = "GET", V.body = void 0, V.headers.delete("content-length"));
                const Q = parseReferrerPolicyFromHeader(Z);
                Q && (V.referrerPolicy = Q), d(fetch$1(new Request(N, V))), D();
                return;
              }
              default:
                return y(new TypeError(`Redirect option '${b.redirect}' is not a valid value of RequestRedirect`));
            }
          }
          F && E.once("end", () => {
            F.removeEventListener("abort", W);
          });
          let M = Stream.pipeline(E, new Stream.PassThrough(), ($2) => {
            $2 && y($2);
          });
          process.version < "v12.10" && E.on("aborted", W);
          const U = { url: b.url, status: E.statusCode, statusText: E.statusMessage, headers: Z, size: b.size, counter: b.counter, highWaterMark: b.highWaterMark }, K = Z.get("Content-Encoding");
          if (!b.compress || b.method === "HEAD" || K === null || E.statusCode === 204 || E.statusCode === 304) {
            B = new Response(M, U), d(B);
            return;
          }
          const se = { flush: zlib__default.Z_SYNC_FLUSH, finishFlush: zlib__default.Z_SYNC_FLUSH };
          if (K === "gzip" || K === "x-gzip") {
            M = Stream.pipeline(M, zlib__default.createGunzip(se), ($2) => {
              $2 && y($2);
            }), B = new Response(M, U), d(B);
            return;
          }
          if (K === "deflate" || K === "x-deflate") {
            const $2 = Stream.pipeline(E, new Stream.PassThrough(), (N) => {
              N && y(N);
            });
            $2.once("data", (N) => {
              (N[0] & 15) === 8 ? M = Stream.pipeline(M, zlib__default.createInflate(), (V) => {
                V && y(V);
              }) : M = Stream.pipeline(M, zlib__default.createInflateRaw(), (V) => {
                V && y(V);
              }), B = new Response(M, U), d(B);
            }), $2.once("end", () => {
              B || (B = new Response(M, U), d(B));
            });
            return;
          }
          if (K === "br") {
            M = Stream.pipeline(M, zlib__default.createBrotliDecompress(), ($2) => {
              $2 && y($2);
            }), B = new Response(M, U), d(B);
            return;
          }
          B = new Response(M, U), d(B);
        }), writeToStream(T, b).catch(y);
      });
    }
    u(fetch$1, "fetch$1");
    function fixResponseChunkedTransferBadEnding(c, l) {
      const d = require$$0.Buffer.from(`0\r
\r
`);
      let y = false, b = false, R;
      c.on("response", (w) => {
        const { headers: A } = w;
        y = A["transfer-encoding"] === "chunked" && !A["content-length"];
      }), c.on("socket", (w) => {
        const A = u(() => {
          if (y && !b) {
            const B = new Error("Premature close");
            B.code = "ERR_STREAM_PREMATURE_CLOSE", l(B);
          }
        }, "onSocketClose"), F = u((B) => {
          b = require$$0.Buffer.compare(B.slice(-5), d) === 0, !b && R && (b = require$$0.Buffer.compare(R.slice(-3), d.slice(0, 3)) === 0 && require$$0.Buffer.compare(B.slice(-2), d.slice(3)) === 0), R = B;
        }, "onData");
        w.prependListener("close", A), w.on("data", F), c.on("close", () => {
          w.removeListener("close", A), w.removeListener("data", F);
        });
      });
    }
    u(fixResponseChunkedTransferBadEnding, "fixResponseChunkedTransferBadEnding");
    var privateData = /* @__PURE__ */ new WeakMap();
    var wrappers = /* @__PURE__ */ new WeakMap();
    function pd(c) {
      const l = privateData.get(c);
      return console.assert(l != null, "'this' is expected an Event object, but got", c), l;
    }
    u(pd, "pd");
    function setCancelFlag(c) {
      if (c.passiveListener != null) {
        typeof console < "u" && typeof console.error == "function" && console.error("Unable to preventDefault inside passive event listener invocation.", c.passiveListener);
        return;
      }
      c.event.cancelable && (c.canceled = true, typeof c.event.preventDefault == "function" && c.event.preventDefault());
    }
    u(setCancelFlag, "setCancelFlag");
    function Event2(c, l) {
      privateData.set(this, { eventTarget: c, event: l, eventPhase: 2, currentTarget: c, canceled: false, stopped: false, immediateStopped: false, passiveListener: null, timeStamp: l.timeStamp || Date.now() }), Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
      const d = Object.keys(l);
      for (let y = 0; y < d.length; ++y) {
        const b = d[y];
        b in this || Object.defineProperty(this, b, defineRedirectDescriptor(b));
      }
    }
    u(Event2, "Event"), Event2.prototype = { get type() {
      return pd(this).event.type;
    }, get target() {
      return pd(this).eventTarget;
    }, get currentTarget() {
      return pd(this).currentTarget;
    }, composedPath() {
      const c = pd(this).currentTarget;
      return c == null ? [] : [c];
    }, get NONE() {
      return 0;
    }, get CAPTURING_PHASE() {
      return 1;
    }, get AT_TARGET() {
      return 2;
    }, get BUBBLING_PHASE() {
      return 3;
    }, get eventPhase() {
      return pd(this).eventPhase;
    }, stopPropagation() {
      const c = pd(this);
      c.stopped = true, typeof c.event.stopPropagation == "function" && c.event.stopPropagation();
    }, stopImmediatePropagation() {
      const c = pd(this);
      c.stopped = true, c.immediateStopped = true, typeof c.event.stopImmediatePropagation == "function" && c.event.stopImmediatePropagation();
    }, get bubbles() {
      return !!pd(this).event.bubbles;
    }, get cancelable() {
      return !!pd(this).event.cancelable;
    }, preventDefault() {
      setCancelFlag(pd(this));
    }, get defaultPrevented() {
      return pd(this).canceled;
    }, get composed() {
      return !!pd(this).event.composed;
    }, get timeStamp() {
      return pd(this).timeStamp;
    }, get srcElement() {
      return pd(this).eventTarget;
    }, get cancelBubble() {
      return pd(this).stopped;
    }, set cancelBubble(c) {
      if (!c)
        return;
      const l = pd(this);
      l.stopped = true, typeof l.event.cancelBubble == "boolean" && (l.event.cancelBubble = true);
    }, get returnValue() {
      return !pd(this).canceled;
    }, set returnValue(c) {
      c || setCancelFlag(pd(this));
    }, initEvent() {
    } }, Object.defineProperty(Event2.prototype, "constructor", { value: Event2, configurable: true, writable: true }), typeof window < "u" && typeof window.Event < "u" && (Object.setPrototypeOf(Event2.prototype, window.Event.prototype), wrappers.set(window.Event.prototype, Event2));
    function defineRedirectDescriptor(c) {
      return { get() {
        return pd(this).event[c];
      }, set(l) {
        pd(this).event[c] = l;
      }, configurable: true, enumerable: true };
    }
    u(defineRedirectDescriptor, "defineRedirectDescriptor");
    function defineCallDescriptor(c) {
      return { value() {
        const l = pd(this).event;
        return l[c].apply(l, arguments);
      }, configurable: true, enumerable: true };
    }
    u(defineCallDescriptor, "defineCallDescriptor");
    function defineWrapper(c, l) {
      const d = Object.keys(l);
      if (d.length === 0)
        return c;
      function y(b, R) {
        c.call(this, b, R);
      }
      u(y, "CustomEvent"), y.prototype = Object.create(c.prototype, { constructor: { value: y, configurable: true, writable: true } });
      for (let b = 0; b < d.length; ++b) {
        const R = d[b];
        if (!(R in c.prototype)) {
          const A = typeof Object.getOwnPropertyDescriptor(l, R).value == "function";
          Object.defineProperty(y.prototype, R, A ? defineCallDescriptor(R) : defineRedirectDescriptor(R));
        }
      }
      return y;
    }
    u(defineWrapper, "defineWrapper");
    function getWrapper(c) {
      if (c == null || c === Object.prototype)
        return Event2;
      let l = wrappers.get(c);
      return l == null && (l = defineWrapper(getWrapper(Object.getPrototypeOf(c)), c), wrappers.set(c, l)), l;
    }
    u(getWrapper, "getWrapper");
    function wrapEvent(c, l) {
      const d = getWrapper(Object.getPrototypeOf(l));
      return new d(c, l);
    }
    u(wrapEvent, "wrapEvent");
    function isStopped(c) {
      return pd(c).immediateStopped;
    }
    u(isStopped, "isStopped");
    function setEventPhase(c, l) {
      pd(c).eventPhase = l;
    }
    u(setEventPhase, "setEventPhase");
    function setCurrentTarget(c, l) {
      pd(c).currentTarget = l;
    }
    u(setCurrentTarget, "setCurrentTarget");
    function setPassiveListener(c, l) {
      pd(c).passiveListener = l;
    }
    u(setPassiveListener, "setPassiveListener");
    var listenersMap = /* @__PURE__ */ new WeakMap();
    var CAPTURE = 1;
    var BUBBLE = 2;
    var ATTRIBUTE = 3;
    function isObject(c) {
      return c !== null && typeof c == "object";
    }
    u(isObject, "isObject");
    function getListeners(c) {
      const l = listenersMap.get(c);
      if (l == null)
        throw new TypeError("'this' is expected an EventTarget object, but got another value.");
      return l;
    }
    u(getListeners, "getListeners");
    function defineEventAttributeDescriptor(c) {
      return { get() {
        let d = getListeners(this).get(c);
        for (; d != null; ) {
          if (d.listenerType === ATTRIBUTE)
            return d.listener;
          d = d.next;
        }
        return null;
      }, set(l) {
        typeof l != "function" && !isObject(l) && (l = null);
        const d = getListeners(this);
        let y = null, b = d.get(c);
        for (; b != null; )
          b.listenerType === ATTRIBUTE ? y !== null ? y.next = b.next : b.next !== null ? d.set(c, b.next) : d.delete(c) : y = b, b = b.next;
        if (l !== null) {
          const R = { listener: l, listenerType: ATTRIBUTE, passive: false, once: false, next: null };
          y === null ? d.set(c, R) : y.next = R;
        }
      }, configurable: true, enumerable: true };
    }
    u(defineEventAttributeDescriptor, "defineEventAttributeDescriptor");
    function defineEventAttribute(c, l) {
      Object.defineProperty(c, `on${l}`, defineEventAttributeDescriptor(l));
    }
    u(defineEventAttribute, "defineEventAttribute");
    function defineCustomEventTarget(c) {
      function l() {
        EventTarget2.call(this);
      }
      u(l, "CustomEventTarget"), l.prototype = Object.create(EventTarget2.prototype, { constructor: { value: l, configurable: true, writable: true } });
      for (let d = 0; d < c.length; ++d)
        defineEventAttribute(l.prototype, c[d]);
      return l;
    }
    u(defineCustomEventTarget, "defineCustomEventTarget");
    function EventTarget2() {
      if (this instanceof EventTarget2) {
        listenersMap.set(this, /* @__PURE__ */ new Map());
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0]))
        return defineCustomEventTarget(arguments[0]);
      if (arguments.length > 0) {
        const c = new Array(arguments.length);
        for (let l = 0; l < arguments.length; ++l)
          c[l] = arguments[l];
        return defineCustomEventTarget(c);
      }
      throw new TypeError("Cannot call a class as a function");
    }
    u(EventTarget2, "EventTarget"), EventTarget2.prototype = { addEventListener(c, l, d) {
      if (l == null)
        return;
      if (typeof l != "function" && !isObject(l))
        throw new TypeError("'listener' should be a function or an object.");
      const y = getListeners(this), b = isObject(d), w = (b ? !!d.capture : !!d) ? CAPTURE : BUBBLE, A = { listener: l, listenerType: w, passive: b && !!d.passive, once: b && !!d.once, next: null };
      let F = y.get(c);
      if (F === void 0) {
        y.set(c, A);
        return;
      }
      let B = null;
      for (; F != null; ) {
        if (F.listener === l && F.listenerType === w)
          return;
        B = F, F = F.next;
      }
      B.next = A;
    }, removeEventListener(c, l, d) {
      if (l == null)
        return;
      const y = getListeners(this), R = (isObject(d) ? !!d.capture : !!d) ? CAPTURE : BUBBLE;
      let w = null, A = y.get(c);
      for (; A != null; ) {
        if (A.listener === l && A.listenerType === R) {
          w !== null ? w.next = A.next : A.next !== null ? y.set(c, A.next) : y.delete(c);
          return;
        }
        w = A, A = A.next;
      }
    }, dispatchEvent(c) {
      if (c == null || typeof c.type != "string")
        throw new TypeError('"event.type" should be a string.');
      const l = getListeners(this), d = c.type;
      let y = l.get(d);
      if (y == null)
        return true;
      const b = wrapEvent(this, c);
      let R = null;
      for (; y != null; ) {
        if (y.once ? R !== null ? R.next = y.next : y.next !== null ? l.set(d, y.next) : l.delete(d) : R = y, setPassiveListener(b, y.passive ? y.listener : null), typeof y.listener == "function")
          try {
            y.listener.call(this, b);
          } catch (w) {
            typeof console < "u" && typeof console.error == "function" && console.error(w);
          }
        else
          y.listenerType !== ATTRIBUTE && typeof y.listener.handleEvent == "function" && y.listener.handleEvent(b);
        if (isStopped(b))
          break;
        y = y.next;
      }
      return setPassiveListener(b, null), setEventPhase(b, 0), setCurrentTarget(b, null), !b.defaultPrevented;
    } }, Object.defineProperty(EventTarget2.prototype, "constructor", { value: EventTarget2, configurable: true, writable: true }), typeof window < "u" && typeof window.EventTarget < "u" && Object.setPrototypeOf(EventTarget2.prototype, window.EventTarget.prototype);
    var AbortSignal2 = class extends EventTarget2 {
      static {
        u(this, "AbortSignal");
      }
      constructor() {
        throw super(), new TypeError("AbortSignal cannot be constructed directly");
      }
      get aborted() {
        const l = abortedFlags.get(this);
        if (typeof l != "boolean")
          throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        return l;
      }
    };
    defineEventAttribute(AbortSignal2.prototype, "abort");
    function createAbortSignal() {
      const c = Object.create(AbortSignal2.prototype);
      return EventTarget2.call(c), abortedFlags.set(c, false), c;
    }
    u(createAbortSignal, "createAbortSignal");
    function abortSignal(c) {
      abortedFlags.get(c) === false && (abortedFlags.set(c, true), c.dispatchEvent({ type: "abort" }));
    }
    u(abortSignal, "abortSignal");
    var abortedFlags = /* @__PURE__ */ new WeakMap();
    Object.defineProperties(AbortSignal2.prototype, { aborted: { enumerable: true } }), typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol" && Object.defineProperty(AbortSignal2.prototype, Symbol.toStringTag, { configurable: true, value: "AbortSignal" });
    var AbortController$1 = class {
      static {
        u(this, "AbortController");
      }
      constructor() {
        signals2.set(this, createAbortSignal());
      }
      get signal() {
        return getSignal(this);
      }
      abort() {
        abortSignal(getSignal(this));
      }
    };
    var signals2 = /* @__PURE__ */ new WeakMap();
    function getSignal(c) {
      const l = signals2.get(c);
      if (l == null)
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${c === null ? "null" : typeof c}`);
      return l;
    }
    u(getSignal, "getSignal"), Object.defineProperties(AbortController$1.prototype, { signal: { enumerable: true }, abort: { enumerable: true } }), typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol" && Object.defineProperty(AbortController$1.prototype, Symbol.toStringTag, { configurable: true, value: "AbortController" });
    var t = Object.defineProperty;
    var e = u((c, l) => t(c, "name", { value: l, configurable: true }), "e");
    var fetch2 = fetch$1;
    s();
    function s() {
      !globalThis.process?.versions?.node && !globalThis.process?.env?.DISABLE_NODE_FETCH_NATIVE_WARN && console.warn("[node-fetch-native] Node.js compatible build of `node-fetch-native` is being used in a non-Node.js environment. Please make sure you are using proper export conditions or report this issue to https://github.com/unjs/node-fetch-native. You can set `process.env.DISABLE_NODE_FETCH_NATIVE_WARN` to disable this warning.");
    }
    u(s, "s"), e(s, "checkNodeEnvironment"), exports.AbortController = AbortController$1, exports.AbortError = AbortError, exports.Blob = Blob2, exports.FetchError = FetchError, exports.File = File, exports.FormData = FormData, exports.Headers = Headers, exports.Request = Request, exports.Response = Response, exports.blobFrom = blobFrom, exports.blobFromSync = blobFromSync, exports.default = fetch2, exports.fetch = fetch2, exports.fileFrom = fileFrom, exports.fileFromSync = fileFromSync, exports.isRedirect = isRedirect;
  }
});

// node_modules/node-fetch-native/dist/index.cjs
var require_dist = __commonJS({
  "node_modules/node-fetch-native/dist/index.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var node = require_node();
    require("node:http"), require("node:https"), require("node:zlib"), require("node:stream"), require("node:buffer"), require("node:util"), require_node_fetch_native_DhEqb06g(), require("node:url"), require("node:net"), require("node:fs"), require("node:path");
    var o = !!globalThis.process?.env?.FORCE_NODE_FETCH;
    var fetch2 = !o && globalThis.fetch || node.fetch;
    var Blob2 = !o && globalThis.Blob || node.Blob;
    var File = !o && globalThis.File || node.File;
    var FormData = !o && globalThis.FormData || node.FormData;
    var Headers = !o && globalThis.Headers || node.Headers;
    var Request = !o && globalThis.Request || node.Request;
    var Response = !o && globalThis.Response || node.Response;
    var AbortController2 = !o && globalThis.AbortController || node.AbortController;
    exports.AbortError = node.AbortError, exports.FetchError = node.FetchError, exports.blobFrom = node.blobFrom, exports.blobFromSync = node.blobFromSync, exports.fileFrom = node.fileFrom, exports.fileFromSync = node.fileFromSync, exports.isRedirect = node.isRedirect, exports.AbortController = AbortController2, exports.Blob = Blob2, exports.File = File, exports.FormData = FormData, exports.Headers = Headers, exports.Request = Request, exports.Response = Response, exports.default = fetch2, exports.fetch = fetch2;
  }
});

// node_modules/node-fetch-native/lib/index.cjs
var require_lib2 = __commonJS({
  "node_modules/node-fetch-native/lib/index.cjs"(exports, module2) {
    var nodeFetch = require_dist();
    function fetch2(input, options) {
      return nodeFetch.fetch(input, options);
    }
    for (const key in nodeFetch) {
      fetch2[key] = nodeFetch[key];
    }
    module2.exports = fetch2;
  }
});

// node_modules/node-fetch-native/dist/proxy.cjs
var require_proxy = __commonJS({
  "node_modules/node-fetch-native/dist/proxy.cjs"(exports) {
    "use strict";
    var le = Object.defineProperty;
    var e = (A, p) => le(A, "name", { value: p, configurable: true });
    var http2 = require("node:http");
    var https = require("node:https");
    var require$$1$1 = require("node:url");
    var require$$0 = require("node:assert");
    var require$$0$1 = require("node:net");
    var Stream = require("node:stream");
    var require$$0$2 = require("node:buffer");
    var require$$0$3 = require("node:util");
    var require$$7 = require("node:querystring");
    var require$$8 = require("node:events");
    var require$$0$4 = require("node:diagnostics_channel");
    var _commonjsHelpers = require_node_fetch_native_DhEqb06g();
    var require$$5 = require("node:tls");
    var zlib = require("node:zlib");
    var require$$5$1 = require("node:perf_hooks");
    var require$$8$1 = require("node:util/types");
    var require$$1 = require("node:worker_threads");
    var require$$5$2 = require("node:async_hooks");
    var require$$1$2 = require("node:console");
    var require$$1$3 = require("node:dns");
    var require$$5$3 = require("string_decoder");
    var require$$0$6 = require("net");
    var require$$0$5 = require("http");
    var require$$1$4 = require("https");
    var require$$1$7 = require("tls");
    var require$$1$5 = require("tty");
    var require$$1$6 = require("util");
    var require$$0$7 = require("os");
    var require$$3 = require("events");
    var require$$5$4 = require("url");
    var require$$2 = require("assert");
    var nodeFetchNative = require_lib2();
    function _interopDefaultCompat(A) {
      return A && typeof A == "object" && "default" in A ? A.default : A;
    }
    e(_interopDefaultCompat, "_interopDefaultCompat");
    function _interopNamespaceCompat(A) {
      if (A && typeof A == "object" && "default" in A)
        return A;
      const p = /* @__PURE__ */ Object.create(null);
      if (A)
        for (const c in A)
          p[c] = A[c];
      return p.default = A, p;
    }
    e(_interopNamespaceCompat, "_interopNamespaceCompat");
    var http__default = _interopDefaultCompat(http2);
    var http__namespace = _interopNamespaceCompat(http2);
    var https__namespace = _interopNamespaceCompat(https);
    var require$$1__default$1 = _interopDefaultCompat(require$$1$1);
    var require$$0__default = _interopDefaultCompat(require$$0);
    var require$$0__default$1 = _interopDefaultCompat(require$$0$1);
    var Stream__default = _interopDefaultCompat(Stream);
    var require$$0__default$2 = _interopDefaultCompat(require$$0$2);
    var require$$0__default$3 = _interopDefaultCompat(require$$0$3);
    var require$$7__default = _interopDefaultCompat(require$$7);
    var require$$8__default = _interopDefaultCompat(require$$8);
    var require$$0__default$4 = _interopDefaultCompat(require$$0$4);
    var require$$5__default = _interopDefaultCompat(require$$5);
    var zlib__default = _interopDefaultCompat(zlib);
    var require$$5__default$1 = _interopDefaultCompat(require$$5$1);
    var require$$8__default$1 = _interopDefaultCompat(require$$8$1);
    var require$$1__default = _interopDefaultCompat(require$$1);
    var require$$5__default$2 = _interopDefaultCompat(require$$5$2);
    var require$$1__default$2 = _interopDefaultCompat(require$$1$2);
    var require$$1__default$3 = _interopDefaultCompat(require$$1$3);
    var require$$5__default$3 = _interopDefaultCompat(require$$5$3);
    var require$$0__default$6 = _interopDefaultCompat(require$$0$6);
    var require$$0__default$5 = _interopDefaultCompat(require$$0$5);
    var require$$1__default$4 = _interopDefaultCompat(require$$1$4);
    var require$$1__default$7 = _interopDefaultCompat(require$$1$7);
    var require$$1__default$5 = _interopDefaultCompat(require$$1$5);
    var require$$1__default$6 = _interopDefaultCompat(require$$1$6);
    var require$$0__default$7 = _interopDefaultCompat(require$$0$7);
    var require$$3__default = _interopDefaultCompat(require$$3);
    var require$$5__default$4 = _interopDefaultCompat(require$$5$4);
    var require$$2__default = _interopDefaultCompat(require$$2);
    var undici = {};
    var symbols$4;
    var hasRequiredSymbols$4;
    function requireSymbols$4() {
      return hasRequiredSymbols$4 || (hasRequiredSymbols$4 = 1, symbols$4 = { kClose: Symbol("close"), kDestroy: Symbol("destroy"), kDispatch: Symbol("dispatch"), kUrl: Symbol("url"), kWriting: Symbol("writing"), kResuming: Symbol("resuming"), kQueue: Symbol("queue"), kConnect: Symbol("connect"), kConnecting: Symbol("connecting"), kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"), kKeepAliveMaxTimeout: Symbol("max keep alive timeout"), kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"), kKeepAliveTimeoutValue: Symbol("keep alive timeout"), kKeepAlive: Symbol("keep alive"), kHeadersTimeout: Symbol("headers timeout"), kBodyTimeout: Symbol("body timeout"), kServerName: Symbol("server name"), kLocalAddress: Symbol("local address"), kHost: Symbol("host"), kNoRef: Symbol("no ref"), kBodyUsed: Symbol("used"), kBody: Symbol("abstracted request body"), kRunning: Symbol("running"), kBlocking: Symbol("blocking"), kPending: Symbol("pending"), kSize: Symbol("size"), kBusy: Symbol("busy"), kQueued: Symbol("queued"), kFree: Symbol("free"), kConnected: Symbol("connected"), kClosed: Symbol("closed"), kNeedDrain: Symbol("need drain"), kReset: Symbol("reset"), kDestroyed: Symbol.for("nodejs.stream.destroyed"), kResume: Symbol("resume"), kOnError: Symbol("on error"), kMaxHeadersSize: Symbol("max headers size"), kRunningIdx: Symbol("running index"), kPendingIdx: Symbol("pending index"), kError: Symbol("error"), kClients: Symbol("clients"), kClient: Symbol("client"), kParser: Symbol("parser"), kOnDestroyed: Symbol("destroy callbacks"), kPipelining: Symbol("pipelining"), kSocket: Symbol("socket"), kHostHeader: Symbol("host header"), kConnector: Symbol("connector"), kStrictContentLength: Symbol("strict content length"), kMaxRedirections: Symbol("maxRedirections"), kMaxRequests: Symbol("maxRequestsPerClient"), kProxy: Symbol("proxy agent options"), kCounter: Symbol("socket request counter"), kInterceptors: Symbol("dispatch interceptors"), kMaxResponseSize: Symbol("max response size"), kHTTP2Session: Symbol("http2Session"), kHTTP2SessionState: Symbol("http2Session state"), kRetryHandlerDefaultRetry: Symbol("retry agent default retry"), kConstruct: Symbol("constructable"), kListeners: Symbol("listeners"), kHTTPContext: Symbol("http context"), kMaxConcurrentStreams: Symbol("max concurrent streams"), kNoProxyAgent: Symbol("no proxy agent"), kHttpProxyAgent: Symbol("http proxy agent"), kHttpsProxyAgent: Symbol("https proxy agent") }), symbols$4;
    }
    e(requireSymbols$4, "requireSymbols$4");
    var errors;
    var hasRequiredErrors;
    function requireErrors() {
      if (hasRequiredErrors)
        return errors;
      hasRequiredErrors = 1;
      class A extends Error {
        static {
          e(this, "UndiciError");
        }
        constructor(k) {
          super(k), this.name = "UndiciError", this.code = "UND_ERR";
        }
      }
      class p extends A {
        static {
          e(this, "ConnectTimeoutError");
        }
        constructor(k) {
          super(k), this.name = "ConnectTimeoutError", this.message = k || "Connect Timeout Error", this.code = "UND_ERR_CONNECT_TIMEOUT";
        }
      }
      class c extends A {
        static {
          e(this, "HeadersTimeoutError");
        }
        constructor(k) {
          super(k), this.name = "HeadersTimeoutError", this.message = k || "Headers Timeout Error", this.code = "UND_ERR_HEADERS_TIMEOUT";
        }
      }
      class E extends A {
        static {
          e(this, "HeadersOverflowError");
        }
        constructor(k) {
          super(k), this.name = "HeadersOverflowError", this.message = k || "Headers Overflow Error", this.code = "UND_ERR_HEADERS_OVERFLOW";
        }
      }
      class t extends A {
        static {
          e(this, "BodyTimeoutError");
        }
        constructor(k) {
          super(k), this.name = "BodyTimeoutError", this.message = k || "Body Timeout Error", this.code = "UND_ERR_BODY_TIMEOUT";
        }
      }
      class B extends A {
        static {
          e(this, "ResponseStatusCodeError");
        }
        constructor(k, i, F, m) {
          super(k), this.name = "ResponseStatusCodeError", this.message = k || "Response Status Code Error", this.code = "UND_ERR_RESPONSE_STATUS_CODE", this.body = m, this.status = i, this.statusCode = i, this.headers = F;
        }
      }
      class f extends A {
        static {
          e(this, "InvalidArgumentError");
        }
        constructor(k) {
          super(k), this.name = "InvalidArgumentError", this.message = k || "Invalid Argument Error", this.code = "UND_ERR_INVALID_ARG";
        }
      }
      class l extends A {
        static {
          e(this, "InvalidReturnValueError");
        }
        constructor(k) {
          super(k), this.name = "InvalidReturnValueError", this.message = k || "Invalid Return Value Error", this.code = "UND_ERR_INVALID_RETURN_VALUE";
        }
      }
      class Q extends A {
        static {
          e(this, "AbortError");
        }
        constructor(k) {
          super(k), this.name = "AbortError", this.message = k || "The operation was aborted";
        }
      }
      class u extends Q {
        static {
          e(this, "RequestAbortedError");
        }
        constructor(k) {
          super(k), this.name = "AbortError", this.message = k || "Request aborted", this.code = "UND_ERR_ABORTED";
        }
      }
      class n extends A {
        static {
          e(this, "InformationalError");
        }
        constructor(k) {
          super(k), this.name = "InformationalError", this.message = k || "Request information", this.code = "UND_ERR_INFO";
        }
      }
      class r extends A {
        static {
          e(this, "RequestContentLengthMismatchError");
        }
        constructor(k) {
          super(k), this.name = "RequestContentLengthMismatchError", this.message = k || "Request body length does not match content-length header", this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
        }
      }
      class o extends A {
        static {
          e(this, "ResponseContentLengthMismatchError");
        }
        constructor(k) {
          super(k), this.name = "ResponseContentLengthMismatchError", this.message = k || "Response body length does not match content-length header", this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
        }
      }
      class a extends A {
        static {
          e(this, "ClientDestroyedError");
        }
        constructor(k) {
          super(k), this.name = "ClientDestroyedError", this.message = k || "The client is destroyed", this.code = "UND_ERR_DESTROYED";
        }
      }
      class g extends A {
        static {
          e(this, "ClientClosedError");
        }
        constructor(k) {
          super(k), this.name = "ClientClosedError", this.message = k || "The client is closed", this.code = "UND_ERR_CLOSED";
        }
      }
      class d extends A {
        static {
          e(this, "SocketError");
        }
        constructor(k, i) {
          super(k), this.name = "SocketError", this.message = k || "Socket error", this.code = "UND_ERR_SOCKET", this.socket = i;
        }
      }
      class N extends A {
        static {
          e(this, "NotSupportedError");
        }
        constructor(k) {
          super(k), this.name = "NotSupportedError", this.message = k || "Not supported error", this.code = "UND_ERR_NOT_SUPPORTED";
        }
      }
      class M extends A {
        static {
          e(this, "BalancedPoolMissingUpstreamError");
        }
        constructor(k) {
          super(k), this.name = "MissingUpstreamError", this.message = k || "No upstream has been added to the BalancedPool", this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
        }
      }
      class Y extends Error {
        static {
          e(this, "HTTPParserError");
        }
        constructor(k, i, F) {
          super(k), this.name = "HTTPParserError", this.code = i ? `HPE_${i}` : void 0, this.data = F ? F.toString() : void 0;
        }
      }
      class J extends A {
        static {
          e(this, "ResponseExceededMaxSizeError");
        }
        constructor(k) {
          super(k), this.name = "ResponseExceededMaxSizeError", this.message = k || "Response content exceeded max size", this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
        }
      }
      class V extends A {
        static {
          e(this, "RequestRetryError");
        }
        constructor(k, i, { headers: F, data: m }) {
          super(k), this.name = "RequestRetryError", this.message = k || "Request retry error", this.code = "UND_ERR_REQ_RETRY", this.statusCode = i, this.data = m, this.headers = F;
        }
      }
      class H extends A {
        static {
          e(this, "ResponseError");
        }
        constructor(k, i, { headers: F, data: m }) {
          super(k), this.name = "ResponseError", this.message = k || "Response error", this.code = "UND_ERR_RESPONSE", this.statusCode = i, this.data = m, this.headers = F;
        }
      }
      class h extends A {
        static {
          e(this, "SecureProxyConnectionError");
        }
        constructor(k, i, F) {
          super(i, { cause: k, ...F ?? {} }), this.name = "SecureProxyConnectionError", this.message = i || "Secure Proxy Connection failed", this.code = "UND_ERR_PRX_TLS", this.cause = k;
        }
      }
      return errors = { AbortError: Q, HTTPParserError: Y, UndiciError: A, HeadersTimeoutError: c, HeadersOverflowError: E, BodyTimeoutError: t, RequestContentLengthMismatchError: r, ConnectTimeoutError: p, ResponseStatusCodeError: B, InvalidArgumentError: f, InvalidReturnValueError: l, RequestAbortedError: u, ClientDestroyedError: a, ClientClosedError: g, InformationalError: n, SocketError: d, NotSupportedError: N, ResponseContentLengthMismatchError: o, BalancedPoolMissingUpstreamError: M, ResponseExceededMaxSizeError: J, RequestRetryError: V, ResponseError: H, SecureProxyConnectionError: h }, errors;
    }
    e(requireErrors, "requireErrors");
    var constants$4;
    var hasRequiredConstants$4;
    function requireConstants$4() {
      if (hasRequiredConstants$4)
        return constants$4;
      hasRequiredConstants$4 = 1;
      const A = {}, p = ["Accept", "Accept-Encoding", "Accept-Language", "Accept-Ranges", "Access-Control-Allow-Credentials", "Access-Control-Allow-Headers", "Access-Control-Allow-Methods", "Access-Control-Allow-Origin", "Access-Control-Expose-Headers", "Access-Control-Max-Age", "Access-Control-Request-Headers", "Access-Control-Request-Method", "Age", "Allow", "Alt-Svc", "Alt-Used", "Authorization", "Cache-Control", "Clear-Site-Data", "Connection", "Content-Disposition", "Content-Encoding", "Content-Language", "Content-Length", "Content-Location", "Content-Range", "Content-Security-Policy", "Content-Security-Policy-Report-Only", "Content-Type", "Cookie", "Cross-Origin-Embedder-Policy", "Cross-Origin-Opener-Policy", "Cross-Origin-Resource-Policy", "Date", "Device-Memory", "Downlink", "ECT", "ETag", "Expect", "Expect-CT", "Expires", "Forwarded", "From", "Host", "If-Match", "If-Modified-Since", "If-None-Match", "If-Range", "If-Unmodified-Since", "Keep-Alive", "Last-Modified", "Link", "Location", "Max-Forwards", "Origin", "Permissions-Policy", "Pragma", "Proxy-Authenticate", "Proxy-Authorization", "RTT", "Range", "Referer", "Referrer-Policy", "Refresh", "Retry-After", "Sec-WebSocket-Accept", "Sec-WebSocket-Extensions", "Sec-WebSocket-Key", "Sec-WebSocket-Protocol", "Sec-WebSocket-Version", "Server", "Server-Timing", "Service-Worker-Allowed", "Service-Worker-Navigation-Preload", "Set-Cookie", "SourceMap", "Strict-Transport-Security", "Supports-Loading-Mode", "TE", "Timing-Allow-Origin", "Trailer", "Transfer-Encoding", "Upgrade", "Upgrade-Insecure-Requests", "User-Agent", "Vary", "Via", "WWW-Authenticate", "X-Content-Type-Options", "X-DNS-Prefetch-Control", "X-Frame-Options", "X-Permitted-Cross-Domain-Policies", "X-Powered-By", "X-Requested-With", "X-XSS-Protection"];
      for (let c = 0; c < p.length; ++c) {
        const E = p[c], t = E.toLowerCase();
        A[E] = A[t] = t;
      }
      return Object.setPrototypeOf(A, null), constants$4 = { wellknownHeaderNames: p, headerNameLowerCasedRecord: A }, constants$4;
    }
    e(requireConstants$4, "requireConstants$4");
    var tree_1;
    var hasRequiredTree;
    function requireTree() {
      if (hasRequiredTree)
        return tree_1;
      hasRequiredTree = 1;
      const { wellknownHeaderNames: A, headerNameLowerCasedRecord: p } = requireConstants$4();
      class c {
        static {
          e(this, "TstNode");
        }
        value = null;
        left = null;
        middle = null;
        right = null;
        code;
        constructor(f, l, Q) {
          if (Q === void 0 || Q >= f.length)
            throw new TypeError("Unreachable");
          if ((this.code = f.charCodeAt(Q)) > 127)
            throw new TypeError("key must be ascii string");
          f.length !== ++Q ? this.middle = new c(f, l, Q) : this.value = l;
        }
        add(f, l) {
          const Q = f.length;
          if (Q === 0)
            throw new TypeError("Unreachable");
          let u = 0, n = this;
          for (; ; ) {
            const r = f.charCodeAt(u);
            if (r > 127)
              throw new TypeError("key must be ascii string");
            if (n.code === r)
              if (Q === ++u) {
                n.value = l;
                break;
              } else if (n.middle !== null)
                n = n.middle;
              else {
                n.middle = new c(f, l, u);
                break;
              }
            else if (n.code < r)
              if (n.left !== null)
                n = n.left;
              else {
                n.left = new c(f, l, u);
                break;
              }
            else if (n.right !== null)
              n = n.right;
            else {
              n.right = new c(f, l, u);
              break;
            }
          }
        }
        search(f) {
          const l = f.length;
          let Q = 0, u = this;
          for (; u !== null && Q < l; ) {
            let n = f[Q];
            for (n <= 90 && n >= 65 && (n |= 32); u !== null; ) {
              if (n === u.code) {
                if (l === ++Q)
                  return u;
                u = u.middle;
                break;
              }
              u = u.code < n ? u.left : u.right;
            }
          }
          return null;
        }
      }
      class E {
        static {
          e(this, "TernarySearchTree");
        }
        node = null;
        insert(f, l) {
          this.node === null ? this.node = new c(f, l, 0) : this.node.add(f, l);
        }
        lookup(f) {
          return this.node?.search(f)?.value ?? null;
        }
      }
      const t = new E();
      for (let B = 0; B < A.length; ++B) {
        const f = p[A[B]];
        t.insert(f, f);
      }
      return tree_1 = { TernarySearchTree: E, tree: t }, tree_1;
    }
    e(requireTree, "requireTree");
    var util$7;
    var hasRequiredUtil$7;
    function requireUtil$7() {
      if (hasRequiredUtil$7)
        return util$7;
      hasRequiredUtil$7 = 1;
      const A = require$$0__default, { kDestroyed: p, kBodyUsed: c, kListeners: E, kBody: t } = requireSymbols$4(), { IncomingMessage: B } = http__default, f = Stream__default, l = require$$0__default$1, { Blob: Q } = require$$0__default$2, u = require$$0__default$3, { stringify: n } = require$$7__default, { EventEmitter: r } = require$$8__default, { InvalidArgumentError: o } = requireErrors(), { headerNameLowerCasedRecord: a } = requireConstants$4(), { tree: g } = requireTree(), [d, N] = process.versions.node.split(".").map((L) => Number(L));
      class M {
        static {
          e(this, "BodyAsyncIterable");
        }
        constructor(AA) {
          this[t] = AA, this[c] = false;
        }
        async *[Symbol.asyncIterator]() {
          A(!this[c], "disturbed"), this[c] = true, yield* this[t];
        }
      }
      function Y(L) {
        return V(L) ? (O(L) === 0 && L.on("data", function() {
          A(false);
        }), typeof L.readableDidRead != "boolean" && (L[c] = false, r.prototype.on.call(L, "data", function() {
          this[c] = true;
        })), L) : L && typeof L.pipeTo == "function" ? new M(L) : L && typeof L != "string" && !ArrayBuffer.isView(L) && q(L) ? new M(L) : L;
      }
      e(Y, "wrapRequestBody");
      function J() {
      }
      e(J, "nop");
      function V(L) {
        return L && typeof L == "object" && typeof L.pipe == "function" && typeof L.on == "function";
      }
      e(V, "isStream");
      function H(L) {
        if (L === null)
          return false;
        if (L instanceof Q)
          return true;
        if (typeof L != "object")
          return false;
        {
          const AA = L[Symbol.toStringTag];
          return (AA === "Blob" || AA === "File") && ("stream" in L && typeof L.stream == "function" || "arrayBuffer" in L && typeof L.arrayBuffer == "function");
        }
      }
      e(H, "isBlobLike");
      function h(L, AA) {
        if (L.includes("?") || L.includes("#"))
          throw new Error('Query params cannot be passed when url already contains "?" or "#".');
        const IA = n(AA);
        return IA && (L += "?" + IA), L;
      }
      e(h, "buildURL");
      function I(L) {
        const AA = parseInt(L, 10);
        return AA === Number(L) && AA >= 0 && AA <= 65535;
      }
      e(I, "isValidPort");
      function k(L) {
        return L != null && L[0] === "h" && L[1] === "t" && L[2] === "t" && L[3] === "p" && (L[4] === ":" || L[4] === "s" && L[5] === ":");
      }
      e(k, "isHttpOrHttpsPrefixed");
      function i(L) {
        if (typeof L == "string") {
          if (L = new URL(L), !k(L.origin || L.protocol))
            throw new o("Invalid URL protocol: the URL must start with `http:` or `https:`.");
          return L;
        }
        if (!L || typeof L != "object")
          throw new o("Invalid URL: The URL argument must be a non-null object.");
        if (!(L instanceof URL)) {
          if (L.port != null && L.port !== "" && I(L.port) === false)
            throw new o("Invalid URL: port must be a valid integer or a string representation of an integer.");
          if (L.path != null && typeof L.path != "string")
            throw new o("Invalid URL path: the path must be a string or null/undefined.");
          if (L.pathname != null && typeof L.pathname != "string")
            throw new o("Invalid URL pathname: the pathname must be a string or null/undefined.");
          if (L.hostname != null && typeof L.hostname != "string")
            throw new o("Invalid URL hostname: the hostname must be a string or null/undefined.");
          if (L.origin != null && typeof L.origin != "string")
            throw new o("Invalid URL origin: the origin must be a string or null/undefined.");
          if (!k(L.origin || L.protocol))
            throw new o("Invalid URL protocol: the URL must start with `http:` or `https:`.");
          const AA = L.port != null ? L.port : L.protocol === "https:" ? 443 : 80;
          let IA = L.origin != null ? L.origin : `${L.protocol || ""}//${L.hostname || ""}:${AA}`, wA = L.path != null ? L.path : `${L.pathname || ""}${L.search || ""}`;
          return IA[IA.length - 1] === "/" && (IA = IA.slice(0, IA.length - 1)), wA && wA[0] !== "/" && (wA = `/${wA}`), new URL(`${IA}${wA}`);
        }
        if (!k(L.origin || L.protocol))
          throw new o("Invalid URL protocol: the URL must start with `http:` or `https:`.");
        return L;
      }
      e(i, "parseURL");
      function F(L) {
        if (L = i(L), L.pathname !== "/" || L.search || L.hash)
          throw new o("invalid url");
        return L;
      }
      e(F, "parseOrigin");
      function m(L) {
        if (L[0] === "[") {
          const IA = L.indexOf("]");
          return A(IA !== -1), L.substring(1, IA);
        }
        const AA = L.indexOf(":");
        return AA === -1 ? L : L.substring(0, AA);
      }
      e(m, "getHostname");
      function D(L) {
        if (!L)
          return null;
        A(typeof L == "string");
        const AA = m(L);
        return l.isIP(AA) ? "" : AA;
      }
      e(D, "getServerName");
      function S(L) {
        return JSON.parse(JSON.stringify(L));
      }
      e(S, "deepClone");
      function W(L) {
        return L != null && typeof L[Symbol.asyncIterator] == "function";
      }
      e(W, "isAsyncIterable");
      function q(L) {
        return L != null && (typeof L[Symbol.iterator] == "function" || typeof L[Symbol.asyncIterator] == "function");
      }
      e(q, "isIterable");
      function O(L) {
        if (L == null)
          return 0;
        if (V(L)) {
          const AA = L._readableState;
          return AA && AA.objectMode === false && AA.ended === true && Number.isFinite(AA.length) ? AA.length : null;
        } else {
          if (H(L))
            return L.size != null ? L.size : null;
          if (DA(L))
            return L.byteLength;
        }
        return null;
      }
      e(O, "bodyLength");
      function P(L) {
        return L && !!(L.destroyed || L[p] || f.isDestroyed?.(L));
      }
      e(P, "isDestroyed");
      function Z(L, AA) {
        L == null || !V(L) || P(L) || (typeof L.destroy == "function" ? (Object.getPrototypeOf(L).constructor === B && (L.socket = null), L.destroy(AA)) : AA && queueMicrotask(() => {
          L.emit("error", AA);
        }), L.destroyed !== true && (L[p] = true));
      }
      e(Z, "destroy");
      const cA = /timeout=(\d+)/;
      function EA(L) {
        const AA = L.toString().match(cA);
        return AA ? parseInt(AA[1], 10) * 1e3 : null;
      }
      e(EA, "parseKeepAliveTimeout");
      function fA(L) {
        return typeof L == "string" ? a[L] ?? L.toLowerCase() : g.lookup(L) ?? L.toString("latin1").toLowerCase();
      }
      e(fA, "headerNameToString");
      function uA(L) {
        return g.lookup(L) ?? L.toString("latin1").toLowerCase();
      }
      e(uA, "bufferToLowerCasedHeaderName");
      function pA(L, AA) {
        AA === void 0 && (AA = {});
        for (let IA = 0; IA < L.length; IA += 2) {
          const wA = fA(L[IA]);
          let FA = AA[wA];
          if (FA)
            typeof FA == "string" && (FA = [FA], AA[wA] = FA), FA.push(L[IA + 1].toString("utf8"));
          else {
            const MA = L[IA + 1];
            typeof MA == "string" ? AA[wA] = MA : AA[wA] = Array.isArray(MA) ? MA.map((OA) => OA.toString("utf8")) : MA.toString("utf8");
          }
        }
        return "content-length" in AA && "content-disposition" in AA && (AA["content-disposition"] = Buffer.from(AA["content-disposition"]).toString("latin1")), AA;
      }
      e(pA, "parseHeaders");
      function RA(L) {
        const AA = L.length, IA = new Array(AA);
        let wA = false, FA = -1, MA, OA, _A = 0;
        for (let $A = 0; $A < L.length; $A += 2)
          MA = L[$A], OA = L[$A + 1], typeof MA != "string" && (MA = MA.toString()), typeof OA != "string" && (OA = OA.toString("utf8")), _A = MA.length, _A === 14 && MA[7] === "-" && (MA === "content-length" || MA.toLowerCase() === "content-length") ? wA = true : _A === 19 && MA[7] === "-" && (MA === "content-disposition" || MA.toLowerCase() === "content-disposition") && (FA = $A + 1), IA[$A] = MA, IA[$A + 1] = OA;
        return wA && FA !== -1 && (IA[FA] = Buffer.from(IA[FA]).toString("latin1")), IA;
      }
      e(RA, "parseRawHeaders");
      function DA(L) {
        return L instanceof Uint8Array || Buffer.isBuffer(L);
      }
      e(DA, "isBuffer");
      function TA(L, AA, IA) {
        if (!L || typeof L != "object")
          throw new o("handler must be an object");
        if (typeof L.onConnect != "function")
          throw new o("invalid onConnect method");
        if (typeof L.onError != "function")
          throw new o("invalid onError method");
        if (typeof L.onBodySent != "function" && L.onBodySent !== void 0)
          throw new o("invalid onBodySent method");
        if (IA || AA === "CONNECT") {
          if (typeof L.onUpgrade != "function")
            throw new o("invalid onUpgrade method");
        } else {
          if (typeof L.onHeaders != "function")
            throw new o("invalid onHeaders method");
          if (typeof L.onData != "function")
            throw new o("invalid onData method");
          if (typeof L.onComplete != "function")
            throw new o("invalid onComplete method");
        }
      }
      e(TA, "validateHandler");
      function UA(L) {
        return !!(L && (f.isDisturbed(L) || L[c]));
      }
      e(UA, "isDisturbed");
      function QA(L) {
        return !!(L && f.isErrored(L));
      }
      e(QA, "isErrored");
      function eA(L) {
        return !!(L && f.isReadable(L));
      }
      e(eA, "isReadable");
      function lA(L) {
        return { localAddress: L.localAddress, localPort: L.localPort, remoteAddress: L.remoteAddress, remotePort: L.remotePort, remoteFamily: L.remoteFamily, timeout: L.timeout, bytesWritten: L.bytesWritten, bytesRead: L.bytesRead };
      }
      e(lA, "getSocketInfo");
      function YA(L) {
        let AA;
        return new ReadableStream({ async start() {
          AA = L[Symbol.asyncIterator]();
        }, async pull(IA) {
          const { done: wA, value: FA } = await AA.next();
          if (wA)
            queueMicrotask(() => {
              IA.close(), IA.byobRequest?.respond(0);
            });
          else {
            const MA = Buffer.isBuffer(FA) ? FA : Buffer.from(FA);
            MA.byteLength && IA.enqueue(new Uint8Array(MA));
          }
          return IA.desiredSize > 0;
        }, async cancel(IA) {
          await AA.return();
        }, type: "bytes" });
      }
      e(YA, "ReadableStreamFrom");
      function nA(L) {
        return L && typeof L == "object" && typeof L.append == "function" && typeof L.delete == "function" && typeof L.get == "function" && typeof L.getAll == "function" && typeof L.has == "function" && typeof L.set == "function" && L[Symbol.toStringTag] === "FormData";
      }
      e(nA, "isFormDataLike");
      function $2(L, AA) {
        return "addEventListener" in L ? (L.addEventListener("abort", AA, { once: true }), () => L.removeEventListener("abort", AA)) : (L.addListener("abort", AA), () => L.removeListener("abort", AA));
      }
      e($2, "addAbortListener");
      const sA = typeof String.prototype.toWellFormed == "function", BA = typeof String.prototype.isWellFormed == "function";
      function dA(L) {
        return sA ? `${L}`.toWellFormed() : u.toUSVString(L);
      }
      e(dA, "toUSVString");
      function CA(L) {
        return BA ? `${L}`.isWellFormed() : dA(L) === `${L}`;
      }
      e(CA, "isUSVString");
      function mA(L) {
        switch (L) {
          case 34:
          case 40:
          case 41:
          case 44:
          case 47:
          case 58:
          case 59:
          case 60:
          case 61:
          case 62:
          case 63:
          case 64:
          case 91:
          case 92:
          case 93:
          case 123:
          case 125:
            return false;
          default:
            return L >= 33 && L <= 126;
        }
      }
      e(mA, "isTokenCharCode");
      function xA(L) {
        if (L.length === 0)
          return false;
        for (let AA = 0; AA < L.length; ++AA)
          if (!mA(L.charCodeAt(AA)))
            return false;
        return true;
      }
      e(xA, "isValidHTTPToken");
      const bA = /[^\t\x20-\x7e\x80-\xff]/;
      function WA(L) {
        return !bA.test(L);
      }
      e(WA, "isValidHeaderValue");
      function LA(L) {
        if (L == null || L === "")
          return { start: 0, end: null, size: null };
        const AA = L ? L.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
        return AA ? { start: parseInt(AA[1]), end: AA[2] ? parseInt(AA[2]) : null, size: AA[3] ? parseInt(AA[3]) : null } : null;
      }
      e(LA, "parseRangeHeader");
      function GA(L, AA, IA) {
        return (L[E] ??= []).push([AA, IA]), L.on(AA, IA), L;
      }
      e(GA, "addListener");
      function NA(L) {
        for (const [AA, IA] of L[E] ?? [])
          L.removeListener(AA, IA);
        L[E] = null;
      }
      e(NA, "removeAllListeners");
      function KA(L, AA, IA) {
        try {
          AA.onError(IA), A(AA.aborted);
        } catch (wA) {
          L.emit("error", wA);
        }
      }
      e(KA, "errorRequest");
      const ZA = /* @__PURE__ */ Object.create(null);
      ZA.enumerable = true;
      const PA = { delete: "DELETE", DELETE: "DELETE", get: "GET", GET: "GET", head: "HEAD", HEAD: "HEAD", options: "OPTIONS", OPTIONS: "OPTIONS", post: "POST", POST: "POST", put: "PUT", PUT: "PUT" }, oA = { ...PA, patch: "patch", PATCH: "PATCH" };
      return Object.setPrototypeOf(PA, null), Object.setPrototypeOf(oA, null), util$7 = { kEnumerableProperty: ZA, nop: J, isDisturbed: UA, isErrored: QA, isReadable: eA, toUSVString: dA, isUSVString: CA, isBlobLike: H, parseOrigin: F, parseURL: i, getServerName: D, isStream: V, isIterable: q, isAsyncIterable: W, isDestroyed: P, headerNameToString: fA, bufferToLowerCasedHeaderName: uA, addListener: GA, removeAllListeners: NA, errorRequest: KA, parseRawHeaders: RA, parseHeaders: pA, parseKeepAliveTimeout: EA, destroy: Z, bodyLength: O, deepClone: S, ReadableStreamFrom: YA, isBuffer: DA, validateHandler: TA, getSocketInfo: lA, isFormDataLike: nA, buildURL: h, addAbortListener: $2, isValidHTTPToken: xA, isValidHeaderValue: WA, isTokenCharCode: mA, parseRangeHeader: LA, normalizedMethodRecordsBase: PA, normalizedMethodRecords: oA, isValidPort: I, isHttpOrHttpsPrefixed: k, nodeMajor: d, nodeMinor: N, safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"], wrapRequestBody: Y }, util$7;
    }
    e(requireUtil$7, "requireUtil$7");
    var diagnostics;
    var hasRequiredDiagnostics;
    function requireDiagnostics() {
      if (hasRequiredDiagnostics)
        return diagnostics;
      hasRequiredDiagnostics = 1;
      const A = require$$0__default$4, p = require$$0__default$3, c = p.debuglog("undici"), E = p.debuglog("fetch"), t = p.debuglog("websocket");
      let B = false;
      const f = { beforeConnect: A.channel("undici:client:beforeConnect"), connected: A.channel("undici:client:connected"), connectError: A.channel("undici:client:connectError"), sendHeaders: A.channel("undici:client:sendHeaders"), create: A.channel("undici:request:create"), bodySent: A.channel("undici:request:bodySent"), headers: A.channel("undici:request:headers"), trailers: A.channel("undici:request:trailers"), error: A.channel("undici:request:error"), open: A.channel("undici:websocket:open"), close: A.channel("undici:websocket:close"), socketError: A.channel("undici:websocket:socket_error"), ping: A.channel("undici:websocket:ping"), pong: A.channel("undici:websocket:pong") };
      if (c.enabled || E.enabled) {
        const l = E.enabled ? E : c;
        A.channel("undici:client:beforeConnect").subscribe((Q) => {
          const { connectParams: { version: u, protocol: n, port: r, host: o } } = Q;
          l("connecting to %s using %s%s", `${o}${r ? `:${r}` : ""}`, n, u);
        }), A.channel("undici:client:connected").subscribe((Q) => {
          const { connectParams: { version: u, protocol: n, port: r, host: o } } = Q;
          l("connected to %s using %s%s", `${o}${r ? `:${r}` : ""}`, n, u);
        }), A.channel("undici:client:connectError").subscribe((Q) => {
          const { connectParams: { version: u, protocol: n, port: r, host: o }, error: a } = Q;
          l("connection to %s using %s%s errored - %s", `${o}${r ? `:${r}` : ""}`, n, u, a.message);
        }), A.channel("undici:client:sendHeaders").subscribe((Q) => {
          const { request: { method: u, path: n, origin: r } } = Q;
          l("sending request to %s %s/%s", u, r, n);
        }), A.channel("undici:request:headers").subscribe((Q) => {
          const { request: { method: u, path: n, origin: r }, response: { statusCode: o } } = Q;
          l("received response to %s %s/%s - HTTP %d", u, r, n, o);
        }), A.channel("undici:request:trailers").subscribe((Q) => {
          const { request: { method: u, path: n, origin: r } } = Q;
          l("trailers received from %s %s/%s", u, r, n);
        }), A.channel("undici:request:error").subscribe((Q) => {
          const { request: { method: u, path: n, origin: r }, error: o } = Q;
          l("request to %s %s/%s errored - %s", u, r, n, o.message);
        }), B = true;
      }
      if (t.enabled) {
        if (!B) {
          const l = c.enabled ? c : t;
          A.channel("undici:client:beforeConnect").subscribe((Q) => {
            const { connectParams: { version: u, protocol: n, port: r, host: o } } = Q;
            l("connecting to %s%s using %s%s", o, r ? `:${r}` : "", n, u);
          }), A.channel("undici:client:connected").subscribe((Q) => {
            const { connectParams: { version: u, protocol: n, port: r, host: o } } = Q;
            l("connected to %s%s using %s%s", o, r ? `:${r}` : "", n, u);
          }), A.channel("undici:client:connectError").subscribe((Q) => {
            const { connectParams: { version: u, protocol: n, port: r, host: o }, error: a } = Q;
            l("connection to %s%s using %s%s errored - %s", o, r ? `:${r}` : "", n, u, a.message);
          }), A.channel("undici:client:sendHeaders").subscribe((Q) => {
            const { request: { method: u, path: n, origin: r } } = Q;
            l("sending request to %s %s/%s", u, r, n);
          });
        }
        A.channel("undici:websocket:open").subscribe((l) => {
          const { address: { address: Q, port: u } } = l;
          t("connection opened %s%s", Q, u ? `:${u}` : "");
        }), A.channel("undici:websocket:close").subscribe((l) => {
          const { websocket: Q, code: u, reason: n } = l;
          t("closed connection to %s - %s %s", Q.url, u, n);
        }), A.channel("undici:websocket:socket_error").subscribe((l) => {
          t("connection errored - %s", l.message);
        }), A.channel("undici:websocket:ping").subscribe((l) => {
          t("ping received");
        }), A.channel("undici:websocket:pong").subscribe((l) => {
          t("pong received");
        });
      }
      return diagnostics = { channels: f }, diagnostics;
    }
    e(requireDiagnostics, "requireDiagnostics");
    var request$1;
    var hasRequiredRequest$1;
    function requireRequest$1() {
      if (hasRequiredRequest$1)
        return request$1;
      hasRequiredRequest$1 = 1;
      const { InvalidArgumentError: A, NotSupportedError: p } = requireErrors(), c = require$$0__default, { isValidHTTPToken: E, isValidHeaderValue: t, isStream: B, destroy: f, isBuffer: l, isFormDataLike: Q, isIterable: u, isBlobLike: n, buildURL: r, validateHandler: o, getServerName: a, normalizedMethodRecords: g } = requireUtil$7(), { channels: d } = requireDiagnostics(), { headerNameLowerCasedRecord: N } = requireConstants$4(), M = /[^\u0021-\u00ff]/, Y = Symbol("handler");
      class J {
        static {
          e(this, "Request");
        }
        constructor(h, { path: I, method: k, body: i, headers: F, query: m, idempotent: D, blocking: S, upgrade: W, headersTimeout: q, bodyTimeout: O, reset: P, throwOnError: Z, expectContinue: cA, servername: EA }, fA) {
          if (typeof I != "string")
            throw new A("path must be a string");
          if (I[0] !== "/" && !(I.startsWith("http://") || I.startsWith("https://")) && k !== "CONNECT")
            throw new A("path must be an absolute URL or start with a slash");
          if (M.test(I))
            throw new A("invalid request path");
          if (typeof k != "string")
            throw new A("method must be a string");
          if (g[k] === void 0 && !E(k))
            throw new A("invalid request method");
          if (W && typeof W != "string")
            throw new A("upgrade must be a string");
          if (q != null && (!Number.isFinite(q) || q < 0))
            throw new A("invalid headersTimeout");
          if (O != null && (!Number.isFinite(O) || O < 0))
            throw new A("invalid bodyTimeout");
          if (P != null && typeof P != "boolean")
            throw new A("invalid reset");
          if (cA != null && typeof cA != "boolean")
            throw new A("invalid expectContinue");
          if (this.headersTimeout = q, this.bodyTimeout = O, this.throwOnError = Z === true, this.method = k, this.abort = null, i == null)
            this.body = null;
          else if (B(i)) {
            this.body = i;
            const uA = this.body._readableState;
            (!uA || !uA.autoDestroy) && (this.endHandler = e(function() {
              f(this);
            }, "autoDestroy"), this.body.on("end", this.endHandler)), this.errorHandler = (pA) => {
              this.abort ? this.abort(pA) : this.error = pA;
            }, this.body.on("error", this.errorHandler);
          } else if (l(i))
            this.body = i.byteLength ? i : null;
          else if (ArrayBuffer.isView(i))
            this.body = i.buffer.byteLength ? Buffer.from(i.buffer, i.byteOffset, i.byteLength) : null;
          else if (i instanceof ArrayBuffer)
            this.body = i.byteLength ? Buffer.from(i) : null;
          else if (typeof i == "string")
            this.body = i.length ? Buffer.from(i) : null;
          else if (Q(i) || u(i) || n(i))
            this.body = i;
          else
            throw new A("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
          if (this.completed = false, this.aborted = false, this.upgrade = W || null, this.path = m ? r(I, m) : I, this.origin = h, this.idempotent = D ?? (k === "HEAD" || k === "GET"), this.blocking = S ?? false, this.reset = P ?? null, this.host = null, this.contentLength = null, this.contentType = null, this.headers = [], this.expectContinue = cA ?? false, Array.isArray(F)) {
            if (F.length % 2 !== 0)
              throw new A("headers array must be even");
            for (let uA = 0; uA < F.length; uA += 2)
              V(this, F[uA], F[uA + 1]);
          } else if (F && typeof F == "object")
            if (F[Symbol.iterator])
              for (const uA of F) {
                if (!Array.isArray(uA) || uA.length !== 2)
                  throw new A("headers must be in key-value pair format");
                V(this, uA[0], uA[1]);
              }
            else {
              const uA = Object.keys(F);
              for (let pA = 0; pA < uA.length; ++pA)
                V(this, uA[pA], F[uA[pA]]);
            }
          else if (F != null)
            throw new A("headers must be an object or an array");
          o(fA, k, W), this.servername = EA || a(this.host), this[Y] = fA, d.create.hasSubscribers && d.create.publish({ request: this });
        }
        onBodySent(h) {
          if (this[Y].onBodySent)
            try {
              return this[Y].onBodySent(h);
            } catch (I) {
              this.abort(I);
            }
        }
        onRequestSent() {
          if (d.bodySent.hasSubscribers && d.bodySent.publish({ request: this }), this[Y].onRequestSent)
            try {
              return this[Y].onRequestSent();
            } catch (h) {
              this.abort(h);
            }
        }
        onConnect(h) {
          if (c(!this.aborted), c(!this.completed), this.error)
            h(this.error);
          else
            return this.abort = h, this[Y].onConnect(h);
        }
        onResponseStarted() {
          return this[Y].onResponseStarted?.();
        }
        onHeaders(h, I, k, i) {
          c(!this.aborted), c(!this.completed), d.headers.hasSubscribers && d.headers.publish({ request: this, response: { statusCode: h, headers: I, statusText: i } });
          try {
            return this[Y].onHeaders(h, I, k, i);
          } catch (F) {
            this.abort(F);
          }
        }
        onData(h) {
          c(!this.aborted), c(!this.completed);
          try {
            return this[Y].onData(h);
          } catch (I) {
            return this.abort(I), false;
          }
        }
        onUpgrade(h, I, k) {
          return c(!this.aborted), c(!this.completed), this[Y].onUpgrade(h, I, k);
        }
        onComplete(h) {
          this.onFinally(), c(!this.aborted), this.completed = true, d.trailers.hasSubscribers && d.trailers.publish({ request: this, trailers: h });
          try {
            return this[Y].onComplete(h);
          } catch (I) {
            this.onError(I);
          }
        }
        onError(h) {
          if (this.onFinally(), d.error.hasSubscribers && d.error.publish({ request: this, error: h }), !this.aborted)
            return this.aborted = true, this[Y].onError(h);
        }
        onFinally() {
          this.errorHandler && (this.body.off("error", this.errorHandler), this.errorHandler = null), this.endHandler && (this.body.off("end", this.endHandler), this.endHandler = null);
        }
        addHeader(h, I) {
          return V(this, h, I), this;
        }
      }
      function V(H, h, I) {
        if (I && typeof I == "object" && !Array.isArray(I))
          throw new A(`invalid ${h} header`);
        if (I === void 0)
          return;
        let k = N[h];
        if (k === void 0 && (k = h.toLowerCase(), N[k] === void 0 && !E(k)))
          throw new A("invalid header key");
        if (Array.isArray(I)) {
          const i = [];
          for (let F = 0; F < I.length; F++)
            if (typeof I[F] == "string") {
              if (!t(I[F]))
                throw new A(`invalid ${h} header`);
              i.push(I[F]);
            } else if (I[F] === null)
              i.push("");
            else {
              if (typeof I[F] == "object")
                throw new A(`invalid ${h} header`);
              i.push(`${I[F]}`);
            }
          I = i;
        } else if (typeof I == "string") {
          if (!t(I))
            throw new A(`invalid ${h} header`);
        } else
          I === null ? I = "" : I = `${I}`;
        if (H.host === null && k === "host") {
          if (typeof I != "string")
            throw new A("invalid host header");
          H.host = I;
        } else if (H.contentLength === null && k === "content-length") {
          if (H.contentLength = parseInt(I, 10), !Number.isFinite(H.contentLength))
            throw new A("invalid content-length header");
        } else if (H.contentType === null && k === "content-type")
          H.contentType = I, H.headers.push(h, I);
        else {
          if (k === "transfer-encoding" || k === "keep-alive" || k === "upgrade")
            throw new A(`invalid ${k} header`);
          if (k === "connection") {
            const i = typeof I == "string" ? I.toLowerCase() : null;
            if (i !== "close" && i !== "keep-alive")
              throw new A("invalid connection header");
            i === "close" && (H.reset = true);
          } else {
            if (k === "expect")
              throw new p("expect header not supported");
            H.headers.push(h, I);
          }
        }
      }
      return e(V, "processHeader"), request$1 = J, request$1;
    }
    e(requireRequest$1, "requireRequest$1");
    var dispatcher;
    var hasRequiredDispatcher;
    function requireDispatcher() {
      if (hasRequiredDispatcher)
        return dispatcher;
      hasRequiredDispatcher = 1;
      const A = require$$8__default;
      class p extends A {
        static {
          e(this, "Dispatcher");
        }
        dispatch() {
          throw new Error("not implemented");
        }
        close() {
          throw new Error("not implemented");
        }
        destroy() {
          throw new Error("not implemented");
        }
        compose(...t) {
          const B = Array.isArray(t[0]) ? t[0] : t;
          let f = this.dispatch.bind(this);
          for (const l of B)
            if (l != null) {
              if (typeof l != "function")
                throw new TypeError(`invalid interceptor, expected function received ${typeof l}`);
              if (f = l(f), f == null || typeof f != "function" || f.length !== 2)
                throw new TypeError("invalid interceptor");
            }
          return new c(this, f);
        }
      }
      class c extends p {
        static {
          e(this, "ComposedDispatcher");
        }
        #A = null;
        #e = null;
        constructor(t, B) {
          super(), this.#A = t, this.#e = B;
        }
        dispatch(...t) {
          this.#e(...t);
        }
        close(...t) {
          return this.#A.close(...t);
        }
        destroy(...t) {
          return this.#A.destroy(...t);
        }
      }
      return dispatcher = p, dispatcher;
    }
    e(requireDispatcher, "requireDispatcher");
    var dispatcherBase;
    var hasRequiredDispatcherBase;
    function requireDispatcherBase() {
      if (hasRequiredDispatcherBase)
        return dispatcherBase;
      hasRequiredDispatcherBase = 1;
      const A = requireDispatcher(), { ClientDestroyedError: p, ClientClosedError: c, InvalidArgumentError: E } = requireErrors(), { kDestroy: t, kClose: B, kClosed: f, kDestroyed: l, kDispatch: Q, kInterceptors: u } = requireSymbols$4(), n = Symbol("onDestroyed"), r = Symbol("onClosed"), o = Symbol("Intercepted Dispatch");
      class a extends A {
        static {
          e(this, "DispatcherBase");
        }
        constructor() {
          super(), this[l] = false, this[n] = null, this[f] = false, this[r] = [];
        }
        get destroyed() {
          return this[l];
        }
        get closed() {
          return this[f];
        }
        get interceptors() {
          return this[u];
        }
        set interceptors(d) {
          if (d) {
            for (let N = d.length - 1; N >= 0; N--)
              if (typeof this[u][N] != "function")
                throw new E("interceptor must be an function");
          }
          this[u] = d;
        }
        close(d) {
          if (d === void 0)
            return new Promise((M, Y) => {
              this.close((J, V) => J ? Y(J) : M(V));
            });
          if (typeof d != "function")
            throw new E("invalid callback");
          if (this[l]) {
            queueMicrotask(() => d(new p(), null));
            return;
          }
          if (this[f]) {
            this[r] ? this[r].push(d) : queueMicrotask(() => d(null, null));
            return;
          }
          this[f] = true, this[r].push(d);
          const N = e(() => {
            const M = this[r];
            this[r] = null;
            for (let Y = 0; Y < M.length; Y++)
              M[Y](null, null);
          }, "onClosed");
          this[B]().then(() => this.destroy()).then(() => {
            queueMicrotask(N);
          });
        }
        destroy(d, N) {
          if (typeof d == "function" && (N = d, d = null), N === void 0)
            return new Promise((Y, J) => {
              this.destroy(d, (V, H) => V ? J(V) : Y(H));
            });
          if (typeof N != "function")
            throw new E("invalid callback");
          if (this[l]) {
            this[n] ? this[n].push(N) : queueMicrotask(() => N(null, null));
            return;
          }
          d || (d = new p()), this[l] = true, this[n] = this[n] || [], this[n].push(N);
          const M = e(() => {
            const Y = this[n];
            this[n] = null;
            for (let J = 0; J < Y.length; J++)
              Y[J](null, null);
          }, "onDestroyed");
          this[t](d).then(() => {
            queueMicrotask(M);
          });
        }
        [o](d, N) {
          if (!this[u] || this[u].length === 0)
            return this[o] = this[Q], this[Q](d, N);
          let M = this[Q].bind(this);
          for (let Y = this[u].length - 1; Y >= 0; Y--)
            M = this[u][Y](M);
          return this[o] = M, M(d, N);
        }
        dispatch(d, N) {
          if (!N || typeof N != "object")
            throw new E("handler must be an object");
          try {
            if (!d || typeof d != "object")
              throw new E("opts must be an object.");
            if (this[l] || this[n])
              throw new p();
            if (this[f])
              throw new c();
            return this[o](d, N);
          } catch (M) {
            if (typeof N.onError != "function")
              throw new E("invalid onError method");
            return N.onError(M), false;
          }
        }
      }
      return dispatcherBase = a, dispatcherBase;
    }
    e(requireDispatcherBase, "requireDispatcherBase");
    var timers;
    var hasRequiredTimers;
    function requireTimers() {
      if (hasRequiredTimers)
        return timers;
      hasRequiredTimers = 1;
      let A = 0;
      const p = 1e3, c = (p >> 1) - 1;
      let E;
      const t = Symbol("kFastTimer"), B = [], f = -2, l = -1, Q = 0, u = 1;
      function n() {
        A += c;
        let a = 0, g = B.length;
        for (; a < g; ) {
          const d = B[a];
          d._state === Q ? (d._idleStart = A - c, d._state = u) : d._state === u && A >= d._idleStart + d._idleTimeout && (d._state = l, d._idleStart = -1, d._onTimeout(d._timerArg)), d._state === l ? (d._state = f, --g !== 0 && (B[a] = B[g])) : ++a;
        }
        B.length = g, B.length !== 0 && r();
      }
      e(n, "onTick");
      function r() {
        E ? E.refresh() : (clearTimeout(E), E = setTimeout(n, c), E.unref && E.unref());
      }
      e(r, "refreshTimeout");
      class o {
        static {
          e(this, "FastTimer");
        }
        [t] = true;
        _state = f;
        _idleTimeout = -1;
        _idleStart = -1;
        _onTimeout;
        _timerArg;
        constructor(g, d, N) {
          this._onTimeout = g, this._idleTimeout = d, this._timerArg = N, this.refresh();
        }
        refresh() {
          this._state === f && B.push(this), (!E || B.length === 1) && r(), this._state = Q;
        }
        clear() {
          this._state = l, this._idleStart = -1;
        }
      }
      return timers = { setTimeout(a, g, d) {
        return g <= p ? setTimeout(a, g, d) : new o(a, g, d);
      }, clearTimeout(a) {
        a[t] ? a.clear() : clearTimeout(a);
      }, setFastTimeout(a, g, d) {
        return new o(a, g, d);
      }, clearFastTimeout(a) {
        a.clear();
      }, now() {
        return A;
      }, tick(a = 0) {
        A += a - p + 1, n(), n();
      }, reset() {
        A = 0, B.length = 0, clearTimeout(E), E = null;
      }, kFastTimer: t }, timers;
    }
    e(requireTimers, "requireTimers");
    var connect;
    var hasRequiredConnect;
    function requireConnect() {
      if (hasRequiredConnect)
        return connect;
      hasRequiredConnect = 1;
      const A = require$$0__default$1, p = require$$0__default, c = requireUtil$7(), { InvalidArgumentError: E, ConnectTimeoutError: t } = requireErrors(), B = requireTimers();
      function f() {
      }
      e(f, "noop");
      let l, Q;
      _commonjsHelpers.commonjsGlobal.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG) ? Q = class {
        static {
          e(this, "WeakSessionCache");
        }
        constructor(a) {
          this._maxCachedSessions = a, this._sessionCache = /* @__PURE__ */ new Map(), this._sessionRegistry = new _commonjsHelpers.commonjsGlobal.FinalizationRegistry((g) => {
            if (this._sessionCache.size < this._maxCachedSessions)
              return;
            const d = this._sessionCache.get(g);
            d !== void 0 && d.deref() === void 0 && this._sessionCache.delete(g);
          });
        }
        get(a) {
          const g = this._sessionCache.get(a);
          return g ? g.deref() : null;
        }
        set(a, g) {
          this._maxCachedSessions !== 0 && (this._sessionCache.set(a, new WeakRef(g)), this._sessionRegistry.register(g, a));
        }
      } : Q = class {
        static {
          e(this, "SimpleSessionCache");
        }
        constructor(a) {
          this._maxCachedSessions = a, this._sessionCache = /* @__PURE__ */ new Map();
        }
        get(a) {
          return this._sessionCache.get(a);
        }
        set(a, g) {
          if (this._maxCachedSessions !== 0) {
            if (this._sessionCache.size >= this._maxCachedSessions) {
              const { value: d } = this._sessionCache.keys().next();
              this._sessionCache.delete(d);
            }
            this._sessionCache.set(a, g);
          }
        }
      };
      function u({ allowH2: o, maxCachedSessions: a, socketPath: g, timeout: d, session: N, ...M }) {
        if (a != null && (!Number.isInteger(a) || a < 0))
          throw new E("maxCachedSessions must be a positive integer or zero");
        const Y = { path: g, ...M }, J = new Q(a ?? 100);
        return d = d ?? 1e4, o = o ?? false, e(function({ hostname: H, host: h, protocol: I, port: k, servername: i, localAddress: F, httpSocket: m }, D) {
          let S;
          if (I === "https:") {
            l || (l = require$$5__default), i = i || Y.servername || c.getServerName(h) || null;
            const q = i || H;
            p(q);
            const O = N || J.get(q) || null;
            k = k || 443, S = l.connect({ highWaterMark: 16384, ...Y, servername: i, session: O, localAddress: F, ALPNProtocols: o ? ["http/1.1", "h2"] : ["http/1.1"], socket: m, port: k, host: H }), S.on("session", function(P) {
              J.set(q, P);
            });
          } else
            p(!m, "httpSocket can only be sent on TLS update"), k = k || 80, S = A.connect({ highWaterMark: 64 * 1024, ...Y, localAddress: F, port: k, host: H });
          if (Y.keepAlive == null || Y.keepAlive) {
            const q = Y.keepAliveInitialDelay === void 0 ? 6e4 : Y.keepAliveInitialDelay;
            S.setKeepAlive(true, q);
          }
          const W = n(new WeakRef(S), { timeout: d, hostname: H, port: k });
          return S.setNoDelay(true).once(I === "https:" ? "secureConnect" : "connect", function() {
            if (queueMicrotask(W), D) {
              const q = D;
              D = null, q(null, this);
            }
          }).on("error", function(q) {
            if (queueMicrotask(W), D) {
              const O = D;
              D = null, O(q);
            }
          }), S;
        }, "connect");
      }
      e(u, "buildConnector");
      const n = process.platform === "win32" ? (o, a) => {
        if (!a.timeout)
          return f;
        let g = null, d = null;
        const N = B.setFastTimeout(() => {
          g = setImmediate(() => {
            d = setImmediate(() => r(o.deref(), a));
          });
        }, a.timeout);
        return () => {
          B.clearFastTimeout(N), clearImmediate(g), clearImmediate(d);
        };
      } : (o, a) => {
        if (!a.timeout)
          return f;
        let g = null;
        const d = B.setFastTimeout(() => {
          g = setImmediate(() => {
            r(o.deref(), a);
          });
        }, a.timeout);
        return () => {
          B.clearFastTimeout(d), clearImmediate(g);
        };
      };
      function r(o, a) {
        if (o == null)
          return;
        let g = "Connect Timeout Error";
        Array.isArray(o.autoSelectFamilyAttemptedAddresses) ? g += ` (attempted addresses: ${o.autoSelectFamilyAttemptedAddresses.join(", ")},` : g += ` (attempted address: ${a.hostname}:${a.port},`, g += ` timeout: ${a.timeout}ms)`, c.destroy(o, new t(g));
      }
      return e(r, "onConnectTimeout"), connect = u, connect;
    }
    e(requireConnect, "requireConnect");
    var constants$3 = {};
    var utils = {};
    var hasRequiredUtils;
    function requireUtils() {
      if (hasRequiredUtils)
        return utils;
      hasRequiredUtils = 1, Object.defineProperty(utils, "__esModule", { value: true }), utils.enumToMap = void 0;
      function A(p) {
        const c = {};
        return Object.keys(p).forEach((E) => {
          const t = p[E];
          typeof t == "number" && (c[E] = t);
        }), c;
      }
      return e(A, "enumToMap"), utils.enumToMap = A, utils;
    }
    e(requireUtils, "requireUtils");
    var hasRequiredConstants$3;
    function requireConstants$3() {
      return hasRequiredConstants$3 || (hasRequiredConstants$3 = 1, function(A) {
        Object.defineProperty(A, "__esModule", { value: true }), A.SPECIAL_HEADERS = A.HEADER_STATE = A.MINOR = A.MAJOR = A.CONNECTION_TOKEN_CHARS = A.HEADER_CHARS = A.TOKEN = A.STRICT_TOKEN = A.HEX = A.URL_CHAR = A.STRICT_URL_CHAR = A.USERINFO_CHARS = A.MARK = A.ALPHANUM = A.NUM = A.HEX_MAP = A.NUM_MAP = A.ALPHA = A.FINISH = A.H_METHOD_MAP = A.METHOD_MAP = A.METHODS_RTSP = A.METHODS_ICE = A.METHODS_HTTP = A.METHODS = A.LENIENT_FLAGS = A.FLAGS = A.TYPE = A.ERROR = void 0;
        const p = requireUtils();
        (function(t) {
          t[t.OK = 0] = "OK", t[t.INTERNAL = 1] = "INTERNAL", t[t.STRICT = 2] = "STRICT", t[t.LF_EXPECTED = 3] = "LF_EXPECTED", t[t.UNEXPECTED_CONTENT_LENGTH = 4] = "UNEXPECTED_CONTENT_LENGTH", t[t.CLOSED_CONNECTION = 5] = "CLOSED_CONNECTION", t[t.INVALID_METHOD = 6] = "INVALID_METHOD", t[t.INVALID_URL = 7] = "INVALID_URL", t[t.INVALID_CONSTANT = 8] = "INVALID_CONSTANT", t[t.INVALID_VERSION = 9] = "INVALID_VERSION", t[t.INVALID_HEADER_TOKEN = 10] = "INVALID_HEADER_TOKEN", t[t.INVALID_CONTENT_LENGTH = 11] = "INVALID_CONTENT_LENGTH", t[t.INVALID_CHUNK_SIZE = 12] = "INVALID_CHUNK_SIZE", t[t.INVALID_STATUS = 13] = "INVALID_STATUS", t[t.INVALID_EOF_STATE = 14] = "INVALID_EOF_STATE", t[t.INVALID_TRANSFER_ENCODING = 15] = "INVALID_TRANSFER_ENCODING", t[t.CB_MESSAGE_BEGIN = 16] = "CB_MESSAGE_BEGIN", t[t.CB_HEADERS_COMPLETE = 17] = "CB_HEADERS_COMPLETE", t[t.CB_MESSAGE_COMPLETE = 18] = "CB_MESSAGE_COMPLETE", t[t.CB_CHUNK_HEADER = 19] = "CB_CHUNK_HEADER", t[t.CB_CHUNK_COMPLETE = 20] = "CB_CHUNK_COMPLETE", t[t.PAUSED = 21] = "PAUSED", t[t.PAUSED_UPGRADE = 22] = "PAUSED_UPGRADE", t[t.PAUSED_H2_UPGRADE = 23] = "PAUSED_H2_UPGRADE", t[t.USER = 24] = "USER";
        })(A.ERROR || (A.ERROR = {})), function(t) {
          t[t.BOTH = 0] = "BOTH", t[t.REQUEST = 1] = "REQUEST", t[t.RESPONSE = 2] = "RESPONSE";
        }(A.TYPE || (A.TYPE = {})), function(t) {
          t[t.CONNECTION_KEEP_ALIVE = 1] = "CONNECTION_KEEP_ALIVE", t[t.CONNECTION_CLOSE = 2] = "CONNECTION_CLOSE", t[t.CONNECTION_UPGRADE = 4] = "CONNECTION_UPGRADE", t[t.CHUNKED = 8] = "CHUNKED", t[t.UPGRADE = 16] = "UPGRADE", t[t.CONTENT_LENGTH = 32] = "CONTENT_LENGTH", t[t.SKIPBODY = 64] = "SKIPBODY", t[t.TRAILING = 128] = "TRAILING", t[t.TRANSFER_ENCODING = 512] = "TRANSFER_ENCODING";
        }(A.FLAGS || (A.FLAGS = {})), function(t) {
          t[t.HEADERS = 1] = "HEADERS", t[t.CHUNKED_LENGTH = 2] = "CHUNKED_LENGTH", t[t.KEEP_ALIVE = 4] = "KEEP_ALIVE";
        }(A.LENIENT_FLAGS || (A.LENIENT_FLAGS = {}));
        var c;
        (function(t) {
          t[t.DELETE = 0] = "DELETE", t[t.GET = 1] = "GET", t[t.HEAD = 2] = "HEAD", t[t.POST = 3] = "POST", t[t.PUT = 4] = "PUT", t[t.CONNECT = 5] = "CONNECT", t[t.OPTIONS = 6] = "OPTIONS", t[t.TRACE = 7] = "TRACE", t[t.COPY = 8] = "COPY", t[t.LOCK = 9] = "LOCK", t[t.MKCOL = 10] = "MKCOL", t[t.MOVE = 11] = "MOVE", t[t.PROPFIND = 12] = "PROPFIND", t[t.PROPPATCH = 13] = "PROPPATCH", t[t.SEARCH = 14] = "SEARCH", t[t.UNLOCK = 15] = "UNLOCK", t[t.BIND = 16] = "BIND", t[t.REBIND = 17] = "REBIND", t[t.UNBIND = 18] = "UNBIND", t[t.ACL = 19] = "ACL", t[t.REPORT = 20] = "REPORT", t[t.MKACTIVITY = 21] = "MKACTIVITY", t[t.CHECKOUT = 22] = "CHECKOUT", t[t.MERGE = 23] = "MERGE", t[t["M-SEARCH"] = 24] = "M-SEARCH", t[t.NOTIFY = 25] = "NOTIFY", t[t.SUBSCRIBE = 26] = "SUBSCRIBE", t[t.UNSUBSCRIBE = 27] = "UNSUBSCRIBE", t[t.PATCH = 28] = "PATCH", t[t.PURGE = 29] = "PURGE", t[t.MKCALENDAR = 30] = "MKCALENDAR", t[t.LINK = 31] = "LINK", t[t.UNLINK = 32] = "UNLINK", t[t.SOURCE = 33] = "SOURCE", t[t.PRI = 34] = "PRI", t[t.DESCRIBE = 35] = "DESCRIBE", t[t.ANNOUNCE = 36] = "ANNOUNCE", t[t.SETUP = 37] = "SETUP", t[t.PLAY = 38] = "PLAY", t[t.PAUSE = 39] = "PAUSE", t[t.TEARDOWN = 40] = "TEARDOWN", t[t.GET_PARAMETER = 41] = "GET_PARAMETER", t[t.SET_PARAMETER = 42] = "SET_PARAMETER", t[t.REDIRECT = 43] = "REDIRECT", t[t.RECORD = 44] = "RECORD", t[t.FLUSH = 45] = "FLUSH";
        })(c = A.METHODS || (A.METHODS = {})), A.METHODS_HTTP = [c.DELETE, c.GET, c.HEAD, c.POST, c.PUT, c.CONNECT, c.OPTIONS, c.TRACE, c.COPY, c.LOCK, c.MKCOL, c.MOVE, c.PROPFIND, c.PROPPATCH, c.SEARCH, c.UNLOCK, c.BIND, c.REBIND, c.UNBIND, c.ACL, c.REPORT, c.MKACTIVITY, c.CHECKOUT, c.MERGE, c["M-SEARCH"], c.NOTIFY, c.SUBSCRIBE, c.UNSUBSCRIBE, c.PATCH, c.PURGE, c.MKCALENDAR, c.LINK, c.UNLINK, c.PRI, c.SOURCE], A.METHODS_ICE = [c.SOURCE], A.METHODS_RTSP = [c.OPTIONS, c.DESCRIBE, c.ANNOUNCE, c.SETUP, c.PLAY, c.PAUSE, c.TEARDOWN, c.GET_PARAMETER, c.SET_PARAMETER, c.REDIRECT, c.RECORD, c.FLUSH, c.GET, c.POST], A.METHOD_MAP = p.enumToMap(c), A.H_METHOD_MAP = {}, Object.keys(A.METHOD_MAP).forEach((t) => {
          /^H/.test(t) && (A.H_METHOD_MAP[t] = A.METHOD_MAP[t]);
        }), function(t) {
          t[t.SAFE = 0] = "SAFE", t[t.SAFE_WITH_CB = 1] = "SAFE_WITH_CB", t[t.UNSAFE = 2] = "UNSAFE";
        }(A.FINISH || (A.FINISH = {})), A.ALPHA = [];
        for (let t = 65; t <= 90; t++)
          A.ALPHA.push(String.fromCharCode(t)), A.ALPHA.push(String.fromCharCode(t + 32));
        A.NUM_MAP = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9 }, A.HEX_MAP = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, A.NUM = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], A.ALPHANUM = A.ALPHA.concat(A.NUM), A.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"], A.USERINFO_CHARS = A.ALPHANUM.concat(A.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]), A.STRICT_URL_CHAR = ["!", '"', "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", ":", ";", "<", "=", ">", "@", "[", "\\", "]", "^", "_", "`", "{", "|", "}", "~"].concat(A.ALPHANUM), A.URL_CHAR = A.STRICT_URL_CHAR.concat(["	", "\f"]);
        for (let t = 128; t <= 255; t++)
          A.URL_CHAR.push(t);
        A.HEX = A.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]), A.STRICT_TOKEN = ["!", "#", "$", "%", "&", "'", "*", "+", "-", ".", "^", "_", "`", "|", "~"].concat(A.ALPHANUM), A.TOKEN = A.STRICT_TOKEN.concat([" "]), A.HEADER_CHARS = ["	"];
        for (let t = 32; t <= 255; t++)
          t !== 127 && A.HEADER_CHARS.push(t);
        A.CONNECTION_TOKEN_CHARS = A.HEADER_CHARS.filter((t) => t !== 44), A.MAJOR = A.NUM_MAP, A.MINOR = A.MAJOR;
        var E;
        (function(t) {
          t[t.GENERAL = 0] = "GENERAL", t[t.CONNECTION = 1] = "CONNECTION", t[t.CONTENT_LENGTH = 2] = "CONTENT_LENGTH", t[t.TRANSFER_ENCODING = 3] = "TRANSFER_ENCODING", t[t.UPGRADE = 4] = "UPGRADE", t[t.CONNECTION_KEEP_ALIVE = 5] = "CONNECTION_KEEP_ALIVE", t[t.CONNECTION_CLOSE = 6] = "CONNECTION_CLOSE", t[t.CONNECTION_UPGRADE = 7] = "CONNECTION_UPGRADE", t[t.TRANSFER_ENCODING_CHUNKED = 8] = "TRANSFER_ENCODING_CHUNKED";
        })(E = A.HEADER_STATE || (A.HEADER_STATE = {})), A.SPECIAL_HEADERS = { connection: E.CONNECTION, "content-length": E.CONTENT_LENGTH, "proxy-connection": E.CONNECTION, "transfer-encoding": E.TRANSFER_ENCODING, upgrade: E.UPGRADE };
      }(constants$3)), constants$3;
    }
    e(requireConstants$3, "requireConstants$3");
    var llhttpWasm;
    var hasRequiredLlhttpWasm;
    function requireLlhttpWasm() {
      if (hasRequiredLlhttpWasm)
        return llhttpWasm;
      hasRequiredLlhttpWasm = 1;
      const { Buffer: A } = require$$0__default$2;
      return llhttpWasm = A.from("AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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PgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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iQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEV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JSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxB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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB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CABB3AgLii1JbnZhbGlkIGNoYXIgaW4gdXJsIHF1ZXJ5AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fYm9keQBDb250ZW50LUxlbmd0aCBvdmVyZmxvdwBDaHVuayBzaXplIG92ZXJmbG93AFJlc3BvbnNlIG92ZXJmbG93AEludmFsaWQgbWV0aG9kIGZvciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX3Jlc2V0YCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3N0YXR1c19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3ZlcnNpb25fY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl91cmxfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXRob2RfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfZmllbGRfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fbmFtZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdmVyc2lvbgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgSFRUUCB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9yZXNldCBwYXVzZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fdmFsdWUgcGF1c2UAb25fc3RhdHVzX2NvbXBsZXRlIHBhdXNlAG9uX3ZlcnNpb25fY29tcGxldGUgcGF1c2UAb25fdXJsX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAG9uX21ldGhvZF9jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfZmllbGRfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUgcGF1c2UAVW5leHBlY3RlZCBzcGFjZSBhZnRlciBzdGFydCBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fbWV0aG9kAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABTV0lUQ0hfUFJPWFkAVVNFX1BST1hZAE1LQUNUSVZJVFkAVU5QUk9DRVNTQUJMRV9FTlRJVFkAQ09QWQBNT1ZFRF9QRVJNQU5FTlRMWQBUT09fRUFSTFkATk9USUZZAEZBSUxFRF9ERVBFTkRFTkNZAEJBRF9HQVRFV0FZAFBMQVkAUFVUAENIRUNLT1VUAEdBVEVXQVlfVElNRU9VVABSRVFVRVNUX1RJTUVPVVQATkVUV09SS19DT05ORUNUX1RJTUVPVVQAQ09OTkVDVElPTl9USU1FT1VUAExPR0lOX1RJTUVPVVQATkVUV09SS19SRUFEX1RJTUVPVVQAUE9TVABNSVNESVJFQ1RFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVABCQURfUkVRVUVTVABIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUAFJFUE9SVABJTV9BX1RFQVBPVABSRVNFVF9DT05URU5UAE5PX0NPTlRFTlQAUEFSVElBTF9DT05URU5UAEhQRV9JTlZBTElEX0NPTlNUQU5UAEhQRV9DQl9SRVNFVABHRVQASFBFX1NUUklDVABDT05GTElDVABURU1QT1JBUllfUkVESVJFQ1QAUEVSTUFORU5UX1JFRElSRUNUAENPTk5FQ1QATVVMVElfU1RBVFVTAEhQRV9JTlZBTElEX1NUQVRVUwBUT09fTUFOWV9SRVFVRVNUUwBFQVJMWV9ISU5UUwBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUwBPUFRJT05TAFNXSVRDSElOR19QUk9UT0NPTFMAVkFSSUFOVF9BTFNPX05FR09USUFURVMATVVMVElQTEVfQ0hPSUNFUwBJTlRFUk5BTF9TRVJWRVJfRVJST1IAV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SAFJBSUxHVU5fRVJST1IASURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IAU1NMX0NFUlRJRklDQVRFX0VSUk9SAElOVkFMSURfWF9GT1JXQVJERURfRk9SAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBTRUVfT1RIRVIASFBFX0NCX0NIVU5LX0hFQURFUgBNS0NBTEVOREFSAFNFVFVQAFdFQl9TRVJWRVJfSVNfRE9XTgBURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASEVVUklTVElDX0VYUElSQVRJT04ARElTQ09OTkVDVEVEX09QRVJBVElPTgBOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAFNJVEVfSVNfRlJPWkVOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBJTlZBTElEX1RPS0VOAEZPUkJJRERFTgBFTkhBTkNFX1lPVVJfQ0FMTQBIUEVfSU5WQUxJRF9VUkwAQkxPQ0tFRF9CWV9QQVJFTlRBTF9DT05UUk9MAE1LQ09MAEFDTABIUEVfSU5URVJOQUwAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBSRVRSWV9XSVRIAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABVUklfVE9PX0xPTkcAUFJPQ0VTU0lORwBNSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORwBNSVNDRUxMQU5FT1VTX1dBUk5JTkcASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUAQ09OVElOVUUASFBFX0NCX1NUQVRVU19DT01QTEVURQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfVkVSU0lPTl9DT01QTEVURQBIUEVfQ0JfVVJMX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8AAF4TAAAmEwAAMBAAAPAXAACdEwAAFRIAADkXAADwEgAAChAAAHUSAACtEgAAghMAAE8UAAB/EAAAoBUAACMUAACJEgAAixQAAE0VAADUEQAAzxQAABAYAADJFgAA3BYAAMERAADgFwAAuxQAAHQUAAB8FQAA5RQAAAgXAAAfEAAAZRUAAKMUAAAoFQAAAhUAAJkVAAAsEAAAixkAAE8PAADUDgAAahAAAM4QAAACFwAAiQ4AAG4TAAAcEwAAZhQAAFYXAADBEwAAzRMAAGwTAABoFwAAZhcAAF8XAAAiEwAAzg8AAGkOAADYDgAAYxYAAMsTAACqDgAAKBcAACYXAADFEwAAXRYAAOgRAABnEwAAZRMAAPIWAABzEwAAHRcAAPkWAADzEQAAzw4AAM4VAAAMEgAAsxEAAKURAABhEAAAMhcAALsTAEH5NQsBAQBBkDYL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB/TcLAQEAQZE4C14CAwICAgICAAACAgACAgACAgICAgICAgICAAQAAAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEH9OQsBAQBBkToLXgIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAQfA7Cw1sb3NlZWVwLWFsaXZlAEGJPAsBAQBBoDwL4AEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBiT4LAQEAQaA+C+cBAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAEGwwAALXwEBAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAEGQwgALIWVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgBBwMIACy1yYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AQfnCAAsFAQIAAQMAQZDDAAvgAQQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH5xAALBQECAAEDAEGQxQAL4AEEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cYACwQBAAABAEGRxwAL3wEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH6yAALBAEAAAIAQZDJAAtfAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAQfrKAAsEAQAAAQBBkMsACwEBAEGqywALQQIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAEH6zAALBAEAAAEAQZDNAAsBAQBBms0ACwYCAAAAAAIAQbHNAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB8M4AC5YBTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv", "base64"), llhttpWasm;
    }
    e(requireLlhttpWasm, "requireLlhttpWasm");
    var llhttp_simdWasm;
    var hasRequiredLlhttp_simdWasm;
    function requireLlhttp_simdWasm() {
      if (hasRequiredLlhttp_simdWasm)
        return llhttp_simdWasm;
      hasRequiredLlhttp_simdWasm = 1;
      const { Buffer: A } = require$$0__default$2;
      return llhttp_simdWasm = A.from("AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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PgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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iQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEV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JSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxB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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB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AAADAEGUCAsFBAAAAAUAQaQICwkGAAAABwAAAAgAQdwIC4otSW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwBB+TULAQEAQZA2C+ABAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQf03CwEBAEGROAteAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgBB/TkLAQEAQZE6C14CAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEHwOwsNbG9zZWVlcC1hbGl2ZQBBiTwLAQEAQaA8C+ABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQYk+CwEBAEGgPgvnAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZABBsMAAC18BAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQBBkMIACyFlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AQcDCAAstcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQoNClNNDQoNClRUUC9DRS9UU1AvAEH5wgALBQECAAEDAEGQwwAL4AEEAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cQACwUBAgABAwBBkMUAC+ABBAEBBQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQfnGAAsEAQAAAQBBkccAC98BAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+sgACwQBAAACAEGQyQALXwMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAEH6ygALBAEAAAEAQZDLAAsBAQBBqssAC0ECAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB+swACwQBAAABAEGQzQALAQEAQZrNAAsGAgAAAAACAEGxzQALOgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQfDOAAuWAU5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==", "base64"), llhttp_simdWasm;
    }
    e(requireLlhttp_simdWasm, "requireLlhttp_simdWasm");
    var constants$2;
    var hasRequiredConstants$2;
    function requireConstants$2() {
      if (hasRequiredConstants$2)
        return constants$2;
      hasRequiredConstants$2 = 1;
      const A = ["GET", "HEAD", "POST"], p = new Set(A), c = [101, 204, 205, 304], E = [301, 302, 303, 307, 308], t = new Set(E), B = ["1", "7", "9", "11", "13", "15", "17", "19", "20", "21", "22", "23", "25", "37", "42", "43", "53", "69", "77", "79", "87", "95", "101", "102", "103", "104", "109", "110", "111", "113", "115", "117", "119", "123", "135", "137", "139", "143", "161", "179", "389", "427", "465", "512", "513", "514", "515", "526", "530", "531", "532", "540", "548", "554", "556", "563", "587", "601", "636", "989", "990", "993", "995", "1719", "1720", "1723", "2049", "3659", "4045", "4190", "5060", "5061", "6000", "6566", "6665", "6666", "6667", "6668", "6669", "6679", "6697", "10080"], f = new Set(B), l = ["", "no-referrer", "no-referrer-when-downgrade", "same-origin", "origin", "strict-origin", "origin-when-cross-origin", "strict-origin-when-cross-origin", "unsafe-url"], Q = new Set(l), u = ["follow", "manual", "error"], n = ["GET", "HEAD", "OPTIONS", "TRACE"], r = new Set(n), o = ["navigate", "same-origin", "no-cors", "cors"], a = ["omit", "same-origin", "include"], g = ["default", "no-store", "reload", "no-cache", "force-cache", "only-if-cached"], d = ["content-encoding", "content-language", "content-location", "content-type", "content-length"], N = ["half"], M = ["CONNECT", "TRACE", "TRACK"], Y = new Set(M), J = ["audio", "audioworklet", "font", "image", "manifest", "paintworklet", "script", "style", "track", "video", "xslt", ""], V = new Set(J);
      return constants$2 = { subresource: J, forbiddenMethods: M, requestBodyHeader: d, referrerPolicy: l, requestRedirect: u, requestMode: o, requestCredentials: a, requestCache: g, redirectStatus: E, corsSafeListedMethods: A, nullBodyStatus: c, safeMethods: n, badPorts: B, requestDuplex: N, subresourceSet: V, badPortsSet: f, redirectStatusSet: t, corsSafeListedMethodsSet: p, safeMethodsSet: r, forbiddenMethodsSet: Y, referrerPolicySet: Q }, constants$2;
    }
    e(requireConstants$2, "requireConstants$2");
    var global$1;
    var hasRequiredGlobal$1;
    function requireGlobal$1() {
      if (hasRequiredGlobal$1)
        return global$1;
      hasRequiredGlobal$1 = 1;
      const A = Symbol.for("undici.globalOrigin.1");
      function p() {
        return globalThis[A];
      }
      e(p, "getGlobalOrigin");
      function c(E) {
        if (E === void 0) {
          Object.defineProperty(globalThis, A, { value: void 0, writable: true, enumerable: false, configurable: false });
          return;
        }
        const t = new URL(E);
        if (t.protocol !== "http:" && t.protocol !== "https:")
          throw new TypeError(`Only http & https urls are allowed, received ${t.protocol}`);
        Object.defineProperty(globalThis, A, { value: t, writable: true, enumerable: false, configurable: false });
      }
      return e(c, "setGlobalOrigin"), global$1 = { getGlobalOrigin: p, setGlobalOrigin: c }, global$1;
    }
    e(requireGlobal$1, "requireGlobal$1");
    var dataUrl;
    var hasRequiredDataUrl;
    function requireDataUrl() {
      if (hasRequiredDataUrl)
        return dataUrl;
      hasRequiredDataUrl = 1;
      const A = require$$0__default, p = new TextEncoder(), c = /^[!#$%&'*+\-.^_|~A-Za-z0-9]+$/, E = /[\u000A\u000D\u0009\u0020]/, t = /[\u0009\u000A\u000C\u000D\u0020]/g, B = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
      function f(i) {
        A(i.protocol === "data:");
        let F = l(i, true);
        F = F.slice(5);
        const m = { position: 0 };
        let D = u(",", F, m);
        const S = D.length;
        if (D = H(D, true, true), m.position >= F.length)
          return "failure";
        m.position++;
        const W = F.slice(S + 1);
        let q = n(W);
        if (/;(\u0020){0,}base64$/i.test(D)) {
          const P = I(q);
          if (q = d(P), q === "failure")
            return "failure";
          D = D.slice(0, -6), D = D.replace(/(\u0020)+$/, ""), D = D.slice(0, -1);
        }
        D.startsWith(";") && (D = "text/plain" + D);
        let O = g(D);
        return O === "failure" && (O = g("text/plain;charset=US-ASCII")), { mimeType: O, body: q };
      }
      e(f, "dataURLProcessor");
      function l(i, F = false) {
        if (!F)
          return i.href;
        const m = i.href, D = i.hash.length, S = D === 0 ? m : m.substring(0, m.length - D);
        return !D && m.endsWith("#") ? S.slice(0, -1) : S;
      }
      e(l, "URLSerializer");
      function Q(i, F, m) {
        let D = "";
        for (; m.position < F.length && i(F[m.position]); )
          D += F[m.position], m.position++;
        return D;
      }
      e(Q, "collectASequenceOfCodePoints");
      function u(i, F, m) {
        const D = F.indexOf(i, m.position), S = m.position;
        return D === -1 ? (m.position = F.length, F.slice(S)) : (m.position = D, F.slice(S, m.position));
      }
      e(u, "collectASequenceOfCodePointsFast");
      function n(i) {
        const F = p.encode(i);
        return a(F);
      }
      e(n, "stringPercentDecode");
      function r(i) {
        return i >= 48 && i <= 57 || i >= 65 && i <= 70 || i >= 97 && i <= 102;
      }
      e(r, "isHexCharByte");
      function o(i) {
        return i >= 48 && i <= 57 ? i - 48 : (i & 223) - 55;
      }
      e(o, "hexByteToNumber");
      function a(i) {
        const F = i.length, m = new Uint8Array(F);
        let D = 0;
        for (let S = 0; S < F; ++S) {
          const W = i[S];
          W !== 37 ? m[D++] = W : W === 37 && !(r(i[S + 1]) && r(i[S + 2])) ? m[D++] = 37 : (m[D++] = o(i[S + 1]) << 4 | o(i[S + 2]), S += 2);
        }
        return F === D ? m : m.subarray(0, D);
      }
      e(a, "percentDecode");
      function g(i) {
        i = J(i, true, true);
        const F = { position: 0 }, m = u("/", i, F);
        if (m.length === 0 || !c.test(m) || F.position > i.length)
          return "failure";
        F.position++;
        let D = u(";", i, F);
        if (D = J(D, false, true), D.length === 0 || !c.test(D))
          return "failure";
        const S = m.toLowerCase(), W = D.toLowerCase(), q = { type: S, subtype: W, parameters: /* @__PURE__ */ new Map(), essence: `${S}/${W}` };
        for (; F.position < i.length; ) {
          F.position++, Q((Z) => E.test(Z), i, F);
          let O = Q((Z) => Z !== ";" && Z !== "=", i, F);
          if (O = O.toLowerCase(), F.position < i.length) {
            if (i[F.position] === ";")
              continue;
            F.position++;
          }
          if (F.position > i.length)
            break;
          let P = null;
          if (i[F.position] === '"')
            P = N(i, F, true), u(";", i, F);
          else if (P = u(";", i, F), P = J(P, false, true), P.length === 0)
            continue;
          O.length !== 0 && c.test(O) && (P.length === 0 || B.test(P)) && !q.parameters.has(O) && q.parameters.set(O, P);
        }
        return q;
      }
      e(g, "parseMIMEType");
      function d(i) {
        i = i.replace(t, "");
        let F = i.length;
        if (F % 4 === 0 && i.charCodeAt(F - 1) === 61 && (--F, i.charCodeAt(F - 1) === 61 && --F), F % 4 === 1 || /[^+/0-9A-Za-z]/.test(i.length === F ? i : i.substring(0, F)))
          return "failure";
        const m = Buffer.from(i, "base64");
        return new Uint8Array(m.buffer, m.byteOffset, m.byteLength);
      }
      e(d, "forgivingBase64");
      function N(i, F, m) {
        const D = F.position;
        let S = "";
        for (A(i[F.position] === '"'), F.position++; S += Q((q) => q !== '"' && q !== "\\", i, F), !(F.position >= i.length); ) {
          const W = i[F.position];
          if (F.position++, W === "\\") {
            if (F.position >= i.length) {
              S += "\\";
              break;
            }
            S += i[F.position], F.position++;
          } else {
            A(W === '"');
            break;
          }
        }
        return m ? S : i.slice(D, F.position);
      }
      e(N, "collectAnHTTPQuotedString");
      function M(i) {
        A(i !== "failure");
        const { parameters: F, essence: m } = i;
        let D = m;
        for (let [S, W] of F.entries())
          D += ";", D += S, D += "=", c.test(W) || (W = W.replace(/(\\|")/g, "\\$1"), W = '"' + W, W += '"'), D += W;
        return D;
      }
      e(M, "serializeAMimeType");
      function Y(i) {
        return i === 13 || i === 10 || i === 9 || i === 32;
      }
      e(Y, "isHTTPWhiteSpace");
      function J(i, F = true, m = true) {
        return h(i, F, m, Y);
      }
      e(J, "removeHTTPWhitespace");
      function V(i) {
        return i === 13 || i === 10 || i === 9 || i === 12 || i === 32;
      }
      e(V, "isASCIIWhitespace");
      function H(i, F = true, m = true) {
        return h(i, F, m, V);
      }
      e(H, "removeASCIIWhitespace");
      function h(i, F, m, D) {
        let S = 0, W = i.length - 1;
        if (F)
          for (; S < i.length && D(i.charCodeAt(S)); )
            S++;
        if (m)
          for (; W > 0 && D(i.charCodeAt(W)); )
            W--;
        return S === 0 && W === i.length - 1 ? i : i.slice(S, W + 1);
      }
      e(h, "removeChars");
      function I(i) {
        const F = i.length;
        if (65535 > F)
          return String.fromCharCode.apply(null, i);
        let m = "", D = 0, S = 65535;
        for (; D < F; )
          D + S > F && (S = F - D), m += String.fromCharCode.apply(null, i.subarray(D, D += S));
        return m;
      }
      e(I, "isomorphicDecode");
      function k(i) {
        switch (i.essence) {
          case "application/ecmascript":
          case "application/javascript":
          case "application/x-ecmascript":
          case "application/x-javascript":
          case "text/ecmascript":
          case "text/javascript":
          case "text/javascript1.0":
          case "text/javascript1.1":
          case "text/javascript1.2":
          case "text/javascript1.3":
          case "text/javascript1.4":
          case "text/javascript1.5":
          case "text/jscript":
          case "text/livescript":
          case "text/x-ecmascript":
          case "text/x-javascript":
            return "text/javascript";
          case "application/json":
          case "text/json":
            return "application/json";
          case "image/svg+xml":
            return "image/svg+xml";
          case "text/xml":
          case "application/xml":
            return "application/xml";
        }
        return i.subtype.endsWith("+json") ? "application/json" : i.subtype.endsWith("+xml") ? "application/xml" : "";
      }
      return e(k, "minimizeSupportedMimeType"), dataUrl = { dataURLProcessor: f, URLSerializer: l, collectASequenceOfCodePoints: Q, collectASequenceOfCodePointsFast: u, stringPercentDecode: n, parseMIMEType: g, collectAnHTTPQuotedString: N, serializeAMimeType: M, removeChars: h, removeHTTPWhitespace: J, minimizeSupportedMimeType: k, HTTP_TOKEN_CODEPOINTS: c, isomorphicDecode: I }, dataUrl;
    }
    e(requireDataUrl, "requireDataUrl");
    var webidl_1;
    var hasRequiredWebidl;
    function requireWebidl() {
      if (hasRequiredWebidl)
        return webidl_1;
      hasRequiredWebidl = 1;
      const { types: A, inspect: p } = require$$0__default$3, { markAsUncloneable: c } = require$$1__default, { toUSVString: E } = requireUtil$7(), t = {};
      return t.converters = {}, t.util = {}, t.errors = {}, t.errors.exception = function(B) {
        return new TypeError(`${B.header}: ${B.message}`);
      }, t.errors.conversionFailed = function(B) {
        const f = B.types.length === 1 ? "" : " one of", l = `${B.argument} could not be converted to${f}: ${B.types.join(", ")}.`;
        return t.errors.exception({ header: B.prefix, message: l });
      }, t.errors.invalidArgument = function(B) {
        return t.errors.exception({ header: B.prefix, message: `"${B.value}" is an invalid ${B.type}.` });
      }, t.brandCheck = function(B, f, l) {
        if (l?.strict !== false) {
          if (!(B instanceof f)) {
            const Q = new TypeError("Illegal invocation");
            throw Q.code = "ERR_INVALID_THIS", Q;
          }
        } else if (B?.[Symbol.toStringTag] !== f.prototype[Symbol.toStringTag]) {
          const Q = new TypeError("Illegal invocation");
          throw Q.code = "ERR_INVALID_THIS", Q;
        }
      }, t.argumentLengthCheck = function({ length: B }, f, l) {
        if (B < f)
          throw t.errors.exception({ message: `${f} argument${f !== 1 ? "s" : ""} required, but${B ? " only" : ""} ${B} found.`, header: l });
      }, t.illegalConstructor = function() {
        throw t.errors.exception({ header: "TypeError", message: "Illegal constructor" });
      }, t.util.Type = function(B) {
        switch (typeof B) {
          case "undefined":
            return "Undefined";
          case "boolean":
            return "Boolean";
          case "string":
            return "String";
          case "symbol":
            return "Symbol";
          case "number":
            return "Number";
          case "bigint":
            return "BigInt";
          case "function":
          case "object":
            return B === null ? "Null" : "Object";
        }
      }, t.util.markAsUncloneable = c || (() => {
      }), t.util.ConvertToInt = function(B, f, l, Q) {
        let u, n;
        f === 64 ? (u = Math.pow(2, 53) - 1, l === "unsigned" ? n = 0 : n = Math.pow(-2, 53) + 1) : l === "unsigned" ? (n = 0, u = Math.pow(2, f) - 1) : (n = Math.pow(-2, f) - 1, u = Math.pow(2, f - 1) - 1);
        let r = Number(B);
        if (r === 0 && (r = 0), Q?.enforceRange === true) {
          if (Number.isNaN(r) || r === Number.POSITIVE_INFINITY || r === Number.NEGATIVE_INFINITY)
            throw t.errors.exception({ header: "Integer conversion", message: `Could not convert ${t.util.Stringify(B)} to an integer.` });
          if (r = t.util.IntegerPart(r), r < n || r > u)
            throw t.errors.exception({ header: "Integer conversion", message: `Value must be between ${n}-${u}, got ${r}.` });
          return r;
        }
        return !Number.isNaN(r) && Q?.clamp === true ? (r = Math.min(Math.max(r, n), u), Math.floor(r) % 2 === 0 ? r = Math.floor(r) : r = Math.ceil(r), r) : Number.isNaN(r) || r === 0 && Object.is(0, r) || r === Number.POSITIVE_INFINITY || r === Number.NEGATIVE_INFINITY ? 0 : (r = t.util.IntegerPart(r), r = r % Math.pow(2, f), l === "signed" && r >= Math.pow(2, f) - 1 ? r - Math.pow(2, f) : r);
      }, t.util.IntegerPart = function(B) {
        const f = Math.floor(Math.abs(B));
        return B < 0 ? -1 * f : f;
      }, t.util.Stringify = function(B) {
        switch (t.util.Type(B)) {
          case "Symbol":
            return `Symbol(${B.description})`;
          case "Object":
            return p(B);
          case "String":
            return `"${B}"`;
          default:
            return `${B}`;
        }
      }, t.sequenceConverter = function(B) {
        return (f, l, Q, u) => {
          if (t.util.Type(f) !== "Object")
            throw t.errors.exception({ header: l, message: `${Q} (${t.util.Stringify(f)}) is not iterable.` });
          const n = typeof u == "function" ? u() : f?.[Symbol.iterator]?.(), r = [];
          let o = 0;
          if (n === void 0 || typeof n.next != "function")
            throw t.errors.exception({ header: l, message: `${Q} is not iterable.` });
          for (; ; ) {
            const { done: a, value: g } = n.next();
            if (a)
              break;
            r.push(B(g, l, `${Q}[${o++}]`));
          }
          return r;
        };
      }, t.recordConverter = function(B, f) {
        return (l, Q, u) => {
          if (t.util.Type(l) !== "Object")
            throw t.errors.exception({ header: Q, message: `${u} ("${t.util.Type(l)}") is not an Object.` });
          const n = {};
          if (!A.isProxy(l)) {
            const o = [...Object.getOwnPropertyNames(l), ...Object.getOwnPropertySymbols(l)];
            for (const a of o) {
              const g = B(a, Q, u), d = f(l[a], Q, u);
              n[g] = d;
            }
            return n;
          }
          const r = Reflect.ownKeys(l);
          for (const o of r)
            if (Reflect.getOwnPropertyDescriptor(l, o)?.enumerable) {
              const g = B(o, Q, u), d = f(l[o], Q, u);
              n[g] = d;
            }
          return n;
        };
      }, t.interfaceConverter = function(B) {
        return (f, l, Q, u) => {
          if (u?.strict !== false && !(f instanceof B))
            throw t.errors.exception({ header: l, message: `Expected ${Q} ("${t.util.Stringify(f)}") to be an instance of ${B.name}.` });
          return f;
        };
      }, t.dictionaryConverter = function(B) {
        return (f, l, Q) => {
          const u = t.util.Type(f), n = {};
          if (u === "Null" || u === "Undefined")
            return n;
          if (u !== "Object")
            throw t.errors.exception({ header: l, message: `Expected ${f} to be one of: Null, Undefined, Object.` });
          for (const r of B) {
            const { key: o, defaultValue: a, required: g, converter: d } = r;
            if (g === true && !Object.hasOwn(f, o))
              throw t.errors.exception({ header: l, message: `Missing required key "${o}".` });
            let N = f[o];
            const M = Object.hasOwn(r, "defaultValue");
            if (M && N !== null && (N ??= a()), g || M || N !== void 0) {
              if (N = d(N, l, `${Q}.${o}`), r.allowedValues && !r.allowedValues.includes(N))
                throw t.errors.exception({ header: l, message: `${N} is not an accepted type. Expected one of ${r.allowedValues.join(", ")}.` });
              n[o] = N;
            }
          }
          return n;
        };
      }, t.nullableConverter = function(B) {
        return (f, l, Q) => f === null ? f : B(f, l, Q);
      }, t.converters.DOMString = function(B, f, l, Q) {
        if (B === null && Q?.legacyNullToEmptyString)
          return "";
        if (typeof B == "symbol")
          throw t.errors.exception({ header: f, message: `${l} is a symbol, which cannot be converted to a DOMString.` });
        return String(B);
      }, t.converters.ByteString = function(B, f, l) {
        const Q = t.converters.DOMString(B, f, l);
        for (let u = 0; u < Q.length; u++)
          if (Q.charCodeAt(u) > 255)
            throw new TypeError(`Cannot convert argument to a ByteString because the character at index ${u} has a value of ${Q.charCodeAt(u)} which is greater than 255.`);
        return Q;
      }, t.converters.USVString = E, t.converters.boolean = function(B) {
        return !!B;
      }, t.converters.any = function(B) {
        return B;
      }, t.converters["long long"] = function(B, f, l) {
        return t.util.ConvertToInt(B, 64, "signed", void 0, f, l);
      }, t.converters["unsigned long long"] = function(B, f, l) {
        return t.util.ConvertToInt(B, 64, "unsigned", void 0, f, l);
      }, t.converters["unsigned long"] = function(B, f, l) {
        return t.util.ConvertToInt(B, 32, "unsigned", void 0, f, l);
      }, t.converters["unsigned short"] = function(B, f, l, Q) {
        return t.util.ConvertToInt(B, 16, "unsigned", Q, f, l);
      }, t.converters.ArrayBuffer = function(B, f, l, Q) {
        if (t.util.Type(B) !== "Object" || !A.isAnyArrayBuffer(B))
          throw t.errors.conversionFailed({ prefix: f, argument: `${l} ("${t.util.Stringify(B)}")`, types: ["ArrayBuffer"] });
        if (Q?.allowShared === false && A.isSharedArrayBuffer(B))
          throw t.errors.exception({ header: "ArrayBuffer", message: "SharedArrayBuffer is not allowed." });
        if (B.resizable || B.growable)
          throw t.errors.exception({ header: "ArrayBuffer", message: "Received a resizable ArrayBuffer." });
        return B;
      }, t.converters.TypedArray = function(B, f, l, Q, u) {
        if (t.util.Type(B) !== "Object" || !A.isTypedArray(B) || B.constructor.name !== f.name)
          throw t.errors.conversionFailed({ prefix: l, argument: `${Q} ("${t.util.Stringify(B)}")`, types: [f.name] });
        if (u?.allowShared === false && A.isSharedArrayBuffer(B.buffer))
          throw t.errors.exception({ header: "ArrayBuffer", message: "SharedArrayBuffer is not allowed." });
        if (B.buffer.resizable || B.buffer.growable)
          throw t.errors.exception({ header: "ArrayBuffer", message: "Received a resizable ArrayBuffer." });
        return B;
      }, t.converters.DataView = function(B, f, l, Q) {
        if (t.util.Type(B) !== "Object" || !A.isDataView(B))
          throw t.errors.exception({ header: f, message: `${l} is not a DataView.` });
        if (Q?.allowShared === false && A.isSharedArrayBuffer(B.buffer))
          throw t.errors.exception({ header: "ArrayBuffer", message: "SharedArrayBuffer is not allowed." });
        if (B.buffer.resizable || B.buffer.growable)
          throw t.errors.exception({ header: "ArrayBuffer", message: "Received a resizable ArrayBuffer." });
        return B;
      }, t.converters.BufferSource = function(B, f, l, Q) {
        if (A.isAnyArrayBuffer(B))
          return t.converters.ArrayBuffer(B, f, l, { ...Q, allowShared: false });
        if (A.isTypedArray(B))
          return t.converters.TypedArray(B, B.constructor, f, l, { ...Q, allowShared: false });
        if (A.isDataView(B))
          return t.converters.DataView(B, f, l, { ...Q, allowShared: false });
        throw t.errors.conversionFailed({ prefix: f, argument: `${l} ("${t.util.Stringify(B)}")`, types: ["BufferSource"] });
      }, t.converters["sequence<ByteString>"] = t.sequenceConverter(t.converters.ByteString), t.converters["sequence<sequence<ByteString>>"] = t.sequenceConverter(t.converters["sequence<ByteString>"]), t.converters["record<ByteString, ByteString>"] = t.recordConverter(t.converters.ByteString, t.converters.ByteString), webidl_1 = { webidl: t }, webidl_1;
    }
    e(requireWebidl, "requireWebidl");
    var util$6;
    var hasRequiredUtil$6;
    function requireUtil$6() {
      if (hasRequiredUtil$6)
        return util$6;
      hasRequiredUtil$6 = 1;
      const { Transform: A } = Stream__default, p = zlib__default, { redirectStatusSet: c, referrerPolicySet: E, badPortsSet: t } = requireConstants$2(), { getGlobalOrigin: B } = requireGlobal$1(), { collectASequenceOfCodePoints: f, collectAnHTTPQuotedString: l, removeChars: Q, parseMIMEType: u } = requireDataUrl(), { performance: n } = require$$5__default$1, { isBlobLike: r, ReadableStreamFrom: o, isValidHTTPToken: a, normalizedMethodRecordsBase: g } = requireUtil$7(), d = require$$0__default, { isUint8Array: N } = require$$8__default$1, { webidl: M } = requireWebidl();
      let Y = [], J;
      try {
        J = require("node:crypto");
        const G = ["sha256", "sha384", "sha512"];
        Y = J.getHashes().filter((j) => G.includes(j));
      } catch {
      }
      function V(G) {
        const j = G.urlList, T = j.length;
        return T === 0 ? null : j[T - 1].toString();
      }
      e(V, "responseURL");
      function H(G, j) {
        if (!c.has(G.status))
          return null;
        let T = G.headersList.get("location", true);
        return T !== null && S(T) && (h(T) || (T = I(T)), T = new URL(T, V(G))), T && !T.hash && (T.hash = j), T;
      }
      e(H, "responseLocationURL");
      function h(G) {
        for (let j = 0; j < G.length; ++j) {
          const T = G.charCodeAt(j);
          if (T > 126 || T < 32)
            return false;
        }
        return true;
      }
      e(h, "isValidEncodedURL");
      function I(G) {
        return Buffer.from(G, "binary").toString("utf8");
      }
      e(I, "normalizeBinaryStringToUtf8");
      function k(G) {
        return G.urlList[G.urlList.length - 1];
      }
      e(k, "requestCurrentURL");
      function i(G) {
        const j = k(G);
        return FA(j) && t.has(j.port) ? "blocked" : "allowed";
      }
      e(i, "requestBadPort");
      function F(G) {
        return G instanceof Error || G?.constructor?.name === "Error" || G?.constructor?.name === "DOMException";
      }
      e(F, "isErrorLike");
      function m(G) {
        for (let j = 0; j < G.length; ++j) {
          const T = G.charCodeAt(j);
          if (!(T === 9 || T >= 32 && T <= 126 || T >= 128 && T <= 255))
            return false;
        }
        return true;
      }
      e(m, "isValidReasonPhrase");
      const D = a;
      function S(G) {
        return (G[0] === "	" || G[0] === " " || G[G.length - 1] === "	" || G[G.length - 1] === " " || G.includes(`
`) || G.includes("\r") || G.includes("\0")) === false;
      }
      e(S, "isValidHeaderValue");
      function W(G, j) {
        const { headersList: T } = j, X = (T.get("referrer-policy", true) ?? "").split(",");
        let K = "";
        if (X.length > 0)
          for (let _ = X.length; _ !== 0; _--) {
            const gA = X[_ - 1].trim();
            if (E.has(gA)) {
              K = gA;
              break;
            }
          }
        K !== "" && (G.referrerPolicy = K);
      }
      e(W, "setRequestReferrerPolicyOnRedirect");
      function q() {
        return "allowed";
      }
      e(q, "crossOriginResourcePolicyCheck");
      function O() {
        return "success";
      }
      e(O, "corsCheck");
      function P() {
        return "success";
      }
      e(P, "TAOCheck");
      function Z(G) {
        let j = null;
        j = G.mode, G.headersList.set("sec-fetch-mode", j, true);
      }
      e(Z, "appendFetchMetadata");
      function cA(G) {
        let j = G.origin;
        if (!(j === "client" || j === void 0)) {
          if (G.responseTainting === "cors" || G.mode === "websocket")
            G.headersList.append("origin", j, true);
          else if (G.method !== "GET" && G.method !== "HEAD") {
            switch (G.referrerPolicy) {
              case "no-referrer":
                j = null;
                break;
              case "no-referrer-when-downgrade":
              case "strict-origin":
              case "strict-origin-when-cross-origin":
                G.origin && wA(G.origin) && !wA(k(G)) && (j = null);
                break;
              case "same-origin":
                dA(G, k(G)) || (j = null);
                break;
            }
            G.headersList.append("origin", j, true);
          }
        }
      }
      e(cA, "appendRequestOriginHeader");
      function EA(G, j) {
        return G;
      }
      e(EA, "coarsenTime");
      function fA(G, j, T) {
        return !G?.startTime || G.startTime < j ? { domainLookupStartTime: j, domainLookupEndTime: j, connectionStartTime: j, connectionEndTime: j, secureConnectionStartTime: j, ALPNNegotiatedProtocol: G?.ALPNNegotiatedProtocol } : { domainLookupStartTime: EA(G.domainLookupStartTime), domainLookupEndTime: EA(G.domainLookupEndTime), connectionStartTime: EA(G.connectionStartTime), connectionEndTime: EA(G.connectionEndTime), secureConnectionStartTime: EA(G.secureConnectionStartTime), ALPNNegotiatedProtocol: G.ALPNNegotiatedProtocol };
      }
      e(fA, "clampAndCoarsenConnectionTimingInfo");
      function uA(G) {
        return EA(n.now());
      }
      e(uA, "coarsenedSharedCurrentTime");
      function pA(G) {
        return { startTime: G.startTime ?? 0, redirectStartTime: 0, redirectEndTime: 0, postRedirectStartTime: G.startTime ?? 0, finalServiceWorkerStartTime: 0, finalNetworkResponseStartTime: 0, finalNetworkRequestStartTime: 0, endTime: 0, encodedBodySize: 0, decodedBodySize: 0, finalConnectionTimingInfo: null };
      }
      e(pA, "createOpaqueTimingInfo");
      function RA() {
        return { referrerPolicy: "strict-origin-when-cross-origin" };
      }
      e(RA, "makePolicyContainer");
      function DA(G) {
        return { referrerPolicy: G.referrerPolicy };
      }
      e(DA, "clonePolicyContainer");
      function TA(G) {
        const j = G.referrerPolicy;
        d(j);
        let T = null;
        if (G.referrer === "client") {
          const tA = B();
          if (!tA || tA.origin === "null")
            return "no-referrer";
          T = new URL(tA);
        } else
          G.referrer instanceof URL && (T = G.referrer);
        let X = UA(T);
        const K = UA(T, true);
        X.toString().length > 4096 && (X = K);
        const _ = dA(G, X), gA = QA(X) && !QA(G.url);
        switch (j) {
          case "origin":
            return K ?? UA(T, true);
          case "unsafe-url":
            return X;
          case "same-origin":
            return _ ? K : "no-referrer";
          case "origin-when-cross-origin":
            return _ ? X : K;
          case "strict-origin-when-cross-origin": {
            const tA = k(G);
            return dA(X, tA) ? X : QA(X) && !QA(tA) ? "no-referrer" : K;
          }
          case "strict-origin":
          case "no-referrer-when-downgrade":
          default:
            return gA ? "no-referrer" : K;
        }
      }
      e(TA, "determineRequestsReferrer");
      function UA(G, j) {
        return d(G instanceof URL), G = new URL(G), G.protocol === "file:" || G.protocol === "about:" || G.protocol === "blank:" ? "no-referrer" : (G.username = "", G.password = "", G.hash = "", j && (G.pathname = "", G.search = ""), G);
      }
      e(UA, "stripURLForReferrer");
      function QA(G) {
        if (!(G instanceof URL))
          return false;
        if (G.href === "about:blank" || G.href === "about:srcdoc" || G.protocol === "data:" || G.protocol === "file:")
          return true;
        return j(G.origin);
        function j(T) {
          if (T == null || T === "null")
            return false;
          const X = new URL(T);
          return !!(X.protocol === "https:" || X.protocol === "wss:" || /^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(X.hostname) || X.hostname === "localhost" || X.hostname.includes("localhost.") || X.hostname.endsWith(".localhost"));
        }
      }
      e(QA, "isURLPotentiallyTrustworthy");
      function eA(G, j) {
        if (J === void 0)
          return true;
        const T = YA(j);
        if (T === "no metadata" || T.length === 0)
          return true;
        const X = nA(T), K = $2(T, X);
        for (const _ of K) {
          const gA = _.algo, tA = _.hash;
          let hA = J.createHash(gA).update(G).digest("base64");
          if (hA[hA.length - 1] === "=" && (hA[hA.length - 2] === "=" ? hA = hA.slice(0, -2) : hA = hA.slice(0, -1)), sA(hA, tA))
            return true;
        }
        return false;
      }
      e(eA, "bytesMatch");
      const lA = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
      function YA(G) {
        const j = [];
        let T = true;
        for (const X of G.split(" ")) {
          T = false;
          const K = lA.exec(X);
          if (K === null || K.groups === void 0 || K.groups.algo === void 0)
            continue;
          const _ = K.groups.algo.toLowerCase();
          Y.includes(_) && j.push(K.groups);
        }
        return T === true ? "no metadata" : j;
      }
      e(YA, "parseMetadata");
      function nA(G) {
        let j = G[0].algo;
        if (j[3] === "5")
          return j;
        for (let T = 1; T < G.length; ++T) {
          const X = G[T];
          if (X.algo[3] === "5") {
            j = "sha512";
            break;
          } else {
            if (j[3] === "3")
              continue;
            X.algo[3] === "3" && (j = "sha384");
          }
        }
        return j;
      }
      e(nA, "getStrongestMetadata");
      function $2(G, j) {
        if (G.length === 1)
          return G;
        let T = 0;
        for (let X = 0; X < G.length; ++X)
          G[X].algo === j && (G[T++] = G[X]);
        return G.length = T, G;
      }
      e($2, "filterMetadataListByAlgorithm");
      function sA(G, j) {
        if (G.length !== j.length)
          return false;
        for (let T = 0; T < G.length; ++T)
          if (G[T] !== j[T]) {
            if (G[T] === "+" && j[T] === "-" || G[T] === "/" && j[T] === "_")
              continue;
            return false;
          }
        return true;
      }
      e(sA, "compareBase64Mixed");
      function BA(G) {
      }
      e(BA, "tryUpgradeRequestToAPotentiallyTrustworthyURL");
      function dA(G, j) {
        return G.origin === j.origin && G.origin === "null" || G.protocol === j.protocol && G.hostname === j.hostname && G.port === j.port;
      }
      e(dA, "sameOrigin");
      function CA() {
        let G, j;
        return { promise: new Promise((X, K) => {
          G = X, j = K;
        }), resolve: G, reject: j };
      }
      e(CA, "createDeferredPromise");
      function mA(G) {
        return G.controller.state === "aborted";
      }
      e(mA, "isAborted");
      function xA(G) {
        return G.controller.state === "aborted" || G.controller.state === "terminated";
      }
      e(xA, "isCancelled");
      function bA(G) {
        return g[G.toLowerCase()] ?? G;
      }
      e(bA, "normalizeMethod");
      function WA(G) {
        const j = JSON.stringify(G);
        if (j === void 0)
          throw new TypeError("Value is not JSON serializable");
        return d(typeof j == "string"), j;
      }
      e(WA, "serializeJavascriptValueToJSONString");
      const LA = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
      function GA(G, j, T = 0, X = 1) {
        class K {
          static {
            e(this, "FastIterableIterator");
          }
          #A;
          #e;
          #n;
          constructor(gA, tA) {
            this.#A = gA, this.#e = tA, this.#n = 0;
          }
          next() {
            if (typeof this != "object" || this === null || !(#A in this))
              throw new TypeError(`'next' called on an object that does not implement interface ${G} Iterator.`);
            const gA = this.#n, tA = this.#A[j], hA = tA.length;
            if (gA >= hA)
              return { value: void 0, done: true };
            const { [T]: JA, [X]: qA } = tA[gA];
            this.#n = gA + 1;
            let VA;
            switch (this.#e) {
              case "key":
                VA = JA;
                break;
              case "value":
                VA = qA;
                break;
              case "key+value":
                VA = [JA, qA];
                break;
            }
            return { value: VA, done: false };
          }
        }
        return delete K.prototype.constructor, Object.setPrototypeOf(K.prototype, LA), Object.defineProperties(K.prototype, { [Symbol.toStringTag]: { writable: false, enumerable: false, configurable: true, value: `${G} Iterator` }, next: { writable: true, enumerable: true, configurable: true } }), function(_, gA) {
          return new K(_, gA);
        };
      }
      e(GA, "createIterator");
      function NA(G, j, T, X = 0, K = 1) {
        const _ = GA(G, T, X, K), gA = { keys: { writable: true, enumerable: true, configurable: true, value: e(function() {
          return M.brandCheck(this, j), _(this, "key");
        }, "keys") }, values: { writable: true, enumerable: true, configurable: true, value: e(function() {
          return M.brandCheck(this, j), _(this, "value");
        }, "values") }, entries: { writable: true, enumerable: true, configurable: true, value: e(function() {
          return M.brandCheck(this, j), _(this, "key+value");
        }, "entries") }, forEach: { writable: true, enumerable: true, configurable: true, value: e(function(hA, JA = globalThis) {
          if (M.brandCheck(this, j), M.argumentLengthCheck(arguments, 1, `${G}.forEach`), typeof hA != "function")
            throw new TypeError(`Failed to execute 'forEach' on '${G}': parameter 1 is not of type 'Function'.`);
          for (const { 0: qA, 1: VA } of _(this, "key+value"))
            hA.call(JA, VA, qA, this);
        }, "forEach") } };
        return Object.defineProperties(j.prototype, { ...gA, [Symbol.iterator]: { writable: true, enumerable: false, configurable: true, value: gA.entries.value } });
      }
      e(NA, "iteratorMixin");
      async function KA(G, j, T) {
        const X = j, K = T;
        let _;
        try {
          _ = G.stream.getReader();
        } catch (gA) {
          K(gA);
          return;
        }
        try {
          X(await AA(_));
        } catch (gA) {
          K(gA);
        }
      }
      e(KA, "fullyReadBody");
      function ZA(G) {
        return G instanceof ReadableStream || G[Symbol.toStringTag] === "ReadableStream" && typeof G.tee == "function";
      }
      e(ZA, "isReadableStreamLike");
      function PA(G) {
        try {
          G.close(), G.byobRequest?.respond(0);
        } catch (j) {
          if (!j.message.includes("Controller is already closed") && !j.message.includes("ReadableStream is already closed"))
            throw j;
        }
      }
      e(PA, "readableStreamClose");
      const oA = /[^\x00-\xFF]/;
      function L(G) {
        return d(!oA.test(G)), G;
      }
      e(L, "isomorphicEncode");
      async function AA(G) {
        const j = [];
        let T = 0;
        for (; ; ) {
          const { done: X, value: K } = await G.read();
          if (X)
            return Buffer.concat(j, T);
          if (!N(K))
            throw new TypeError("Received non-Uint8Array chunk");
          j.push(K), T += K.length;
        }
      }
      e(AA, "readAllBytes");
      function IA(G) {
        d("protocol" in G);
        const j = G.protocol;
        return j === "about:" || j === "blob:" || j === "data:";
      }
      e(IA, "urlIsLocal");
      function wA(G) {
        return typeof G == "string" && G[5] === ":" && G[0] === "h" && G[1] === "t" && G[2] === "t" && G[3] === "p" && G[4] === "s" || G.protocol === "https:";
      }
      e(wA, "urlHasHttpsScheme");
      function FA(G) {
        d("protocol" in G);
        const j = G.protocol;
        return j === "http:" || j === "https:";
      }
      e(FA, "urlIsHttpHttpsScheme");
      function MA(G, j) {
        const T = G;
        if (!T.startsWith("bytes"))
          return "failure";
        const X = { position: 5 };
        if (j && f((hA) => hA === "	" || hA === " ", T, X), T.charCodeAt(X.position) !== 61)
          return "failure";
        X.position++, j && f((hA) => hA === "	" || hA === " ", T, X);
        const K = f((hA) => {
          const JA = hA.charCodeAt(0);
          return JA >= 48 && JA <= 57;
        }, T, X), _ = K.length ? Number(K) : null;
        if (j && f((hA) => hA === "	" || hA === " ", T, X), T.charCodeAt(X.position) !== 45)
          return "failure";
        X.position++, j && f((hA) => hA === "	" || hA === " ", T, X);
        const gA = f((hA) => {
          const JA = hA.charCodeAt(0);
          return JA >= 48 && JA <= 57;
        }, T, X), tA = gA.length ? Number(gA) : null;
        return X.position < T.length || tA === null && _ === null || _ > tA ? "failure" : { rangeStartValue: _, rangeEndValue: tA };
      }
      e(MA, "simpleRangeHeaderValue");
      function OA(G, j, T) {
        let X = "bytes ";
        return X += L(`${G}`), X += "-", X += L(`${j}`), X += "/", X += L(`${T}`), X;
      }
      e(OA, "buildContentRange");
      class _A extends A {
        static {
          e(this, "InflateStream");
        }
        #A;
        constructor(j) {
          super(), this.#A = j;
        }
        _transform(j, T, X) {
          if (!this._inflateStream) {
            if (j.length === 0) {
              X();
              return;
            }
            this._inflateStream = (j[0] & 15) === 8 ? p.createInflate(this.#A) : p.createInflateRaw(this.#A), this._inflateStream.on("data", this.push.bind(this)), this._inflateStream.on("end", () => this.push(null)), this._inflateStream.on("error", (K) => this.destroy(K));
          }
          this._inflateStream.write(j, T, X);
        }
        _final(j) {
          this._inflateStream && (this._inflateStream.end(), this._inflateStream = null), j();
        }
      }
      function $A(G) {
        return new _A(G);
      }
      e($A, "createInflate");
      function kA(G) {
        let j = null, T = null, X = null;
        const K = iA("content-type", G);
        if (K === null)
          return "failure";
        for (const _ of K) {
          const gA = u(_);
          gA === "failure" || gA.essence === "*/*" || (X = gA, X.essence !== T ? (j = null, X.parameters.has("charset") && (j = X.parameters.get("charset")), T = X.essence) : !X.parameters.has("charset") && j !== null && X.parameters.set("charset", j));
        }
        return X ?? "failure";
      }
      e(kA, "extractMimeType");
      function z(G) {
        const j = G, T = { position: 0 }, X = [];
        let K = "";
        for (; T.position < j.length; ) {
          if (K += f((_) => _ !== '"' && _ !== ",", j, T), T.position < j.length)
            if (j.charCodeAt(T.position) === 34) {
              if (K += l(j, T), T.position < j.length)
                continue;
            } else
              d(j.charCodeAt(T.position) === 44), T.position++;
          K = Q(K, true, true, (_) => _ === 9 || _ === 32), X.push(K), K = "";
        }
        return X;
      }
      e(z, "gettingDecodingSplitting");
      function iA(G, j) {
        const T = j.get(G, true);
        return T === null ? null : z(T);
      }
      e(iA, "getDecodeSplit");
      const rA = new TextDecoder();
      function aA(G) {
        return G.length === 0 ? "" : (G[0] === 239 && G[1] === 187 && G[2] === 191 && (G = G.subarray(3)), rA.decode(G));
      }
      e(aA, "utf8DecodeBytes");
      class yA {
        static {
          e(this, "EnvironmentSettingsObjectBase");
        }
        get baseUrl() {
          return B();
        }
        get origin() {
          return this.baseUrl?.origin;
        }
        policyContainer = RA();
      }
      class SA {
        static {
          e(this, "EnvironmentSettingsObject");
        }
        settingsObject = new yA();
      }
      const vA = new SA();
      return util$6 = { isAborted: mA, isCancelled: xA, isValidEncodedURL: h, createDeferredPromise: CA, ReadableStreamFrom: o, tryUpgradeRequestToAPotentiallyTrustworthyURL: BA, clampAndCoarsenConnectionTimingInfo: fA, coarsenedSharedCurrentTime: uA, determineRequestsReferrer: TA, makePolicyContainer: RA, clonePolicyContainer: DA, appendFetchMetadata: Z, appendRequestOriginHeader: cA, TAOCheck: P, corsCheck: O, crossOriginResourcePolicyCheck: q, createOpaqueTimingInfo: pA, setRequestReferrerPolicyOnRedirect: W, isValidHTTPToken: a, requestBadPort: i, requestCurrentURL: k, responseURL: V, responseLocationURL: H, isBlobLike: r, isURLPotentiallyTrustworthy: QA, isValidReasonPhrase: m, sameOrigin: dA, normalizeMethod: bA, serializeJavascriptValueToJSONString: WA, iteratorMixin: NA, createIterator: GA, isValidHeaderName: D, isValidHeaderValue: S, isErrorLike: F, fullyReadBody: KA, bytesMatch: eA, isReadableStreamLike: ZA, readableStreamClose: PA, isomorphicEncode: L, urlIsLocal: IA, urlHasHttpsScheme: wA, urlIsHttpHttpsScheme: FA, readAllBytes: AA, simpleRangeHeaderValue: MA, buildContentRange: OA, parseMetadata: YA, createInflate: $A, extractMimeType: kA, getDecodeSplit: iA, utf8DecodeBytes: aA, environmentSettingsObject: vA }, util$6;
    }
    e(requireUtil$6, "requireUtil$6");
    var symbols$3;
    var hasRequiredSymbols$3;
    function requireSymbols$3() {
      return hasRequiredSymbols$3 || (hasRequiredSymbols$3 = 1, symbols$3 = { kUrl: Symbol("url"), kHeaders: Symbol("headers"), kSignal: Symbol("signal"), kState: Symbol("state"), kDispatcher: Symbol("dispatcher") }), symbols$3;
    }
    e(requireSymbols$3, "requireSymbols$3");
    var file;
    var hasRequiredFile;
    function requireFile() {
      if (hasRequiredFile)
        return file;
      hasRequiredFile = 1;
      const { Blob: A, File: p } = require$$0__default$2, { kState: c } = requireSymbols$3(), { webidl: E } = requireWebidl();
      class t {
        static {
          e(this, "FileLike");
        }
        constructor(l, Q, u = {}) {
          const n = Q, r = u.type, o = u.lastModified ?? Date.now();
          this[c] = { blobLike: l, name: n, type: r, lastModified: o };
        }
        stream(...l) {
          return E.brandCheck(this, t), this[c].blobLike.stream(...l);
        }
        arrayBuffer(...l) {
          return E.brandCheck(this, t), this[c].blobLike.arrayBuffer(...l);
        }
        slice(...l) {
          return E.brandCheck(this, t), this[c].blobLike.slice(...l);
        }
        text(...l) {
          return E.brandCheck(this, t), this[c].blobLike.text(...l);
        }
        get size() {
          return E.brandCheck(this, t), this[c].blobLike.size;
        }
        get type() {
          return E.brandCheck(this, t), this[c].blobLike.type;
        }
        get name() {
          return E.brandCheck(this, t), this[c].name;
        }
        get lastModified() {
          return E.brandCheck(this, t), this[c].lastModified;
        }
        get [Symbol.toStringTag]() {
          return "File";
        }
      }
      E.converters.Blob = E.interfaceConverter(A);
      function B(f) {
        return f instanceof p || f && (typeof f.stream == "function" || typeof f.arrayBuffer == "function") && f[Symbol.toStringTag] === "File";
      }
      return e(B, "isFileLike"), file = { FileLike: t, isFileLike: B }, file;
    }
    e(requireFile, "requireFile");
    var formdata;
    var hasRequiredFormdata;
    function requireFormdata() {
      if (hasRequiredFormdata)
        return formdata;
      hasRequiredFormdata = 1;
      const { isBlobLike: A, iteratorMixin: p } = requireUtil$6(), { kState: c } = requireSymbols$3(), { kEnumerableProperty: E } = requireUtil$7(), { FileLike: t, isFileLike: B } = requireFile(), { webidl: f } = requireWebidl(), { File: l } = require$$0__default$2, Q = require$$0__default$3, u = globalThis.File ?? l;
      class n {
        static {
          e(this, "FormData");
        }
        constructor(a) {
          if (f.util.markAsUncloneable(this), a !== void 0)
            throw f.errors.conversionFailed({ prefix: "FormData constructor", argument: "Argument 1", types: ["undefined"] });
          this[c] = [];
        }
        append(a, g, d = void 0) {
          f.brandCheck(this, n);
          const N = "FormData.append";
          if (f.argumentLengthCheck(arguments, 2, N), arguments.length === 3 && !A(g))
            throw new TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");
          a = f.converters.USVString(a, N, "name"), g = A(g) ? f.converters.Blob(g, N, "value", { strict: false }) : f.converters.USVString(g, N, "value"), d = arguments.length === 3 ? f.converters.USVString(d, N, "filename") : void 0;
          const M = r(a, g, d);
          this[c].push(M);
        }
        delete(a) {
          f.brandCheck(this, n);
          const g = "FormData.delete";
          f.argumentLengthCheck(arguments, 1, g), a = f.converters.USVString(a, g, "name"), this[c] = this[c].filter((d) => d.name !== a);
        }
        get(a) {
          f.brandCheck(this, n);
          const g = "FormData.get";
          f.argumentLengthCheck(arguments, 1, g), a = f.converters.USVString(a, g, "name");
          const d = this[c].findIndex((N) => N.name === a);
          return d === -1 ? null : this[c][d].value;
        }
        getAll(a) {
          f.brandCheck(this, n);
          const g = "FormData.getAll";
          return f.argumentLengthCheck(arguments, 1, g), a = f.converters.USVString(a, g, "name"), this[c].filter((d) => d.name === a).map((d) => d.value);
        }
        has(a) {
          f.brandCheck(this, n);
          const g = "FormData.has";
          return f.argumentLengthCheck(arguments, 1, g), a = f.converters.USVString(a, g, "name"), this[c].findIndex((d) => d.name === a) !== -1;
        }
        set(a, g, d = void 0) {
          f.brandCheck(this, n);
          const N = "FormData.set";
          if (f.argumentLengthCheck(arguments, 2, N), arguments.length === 3 && !A(g))
            throw new TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");
          a = f.converters.USVString(a, N, "name"), g = A(g) ? f.converters.Blob(g, N, "name", { strict: false }) : f.converters.USVString(g, N, "name"), d = arguments.length === 3 ? f.converters.USVString(d, N, "name") : void 0;
          const M = r(a, g, d), Y = this[c].findIndex((J) => J.name === a);
          Y !== -1 ? this[c] = [...this[c].slice(0, Y), M, ...this[c].slice(Y + 1).filter((J) => J.name !== a)] : this[c].push(M);
        }
        [Q.inspect.custom](a, g) {
          const d = this[c].reduce((M, Y) => (M[Y.name] ? Array.isArray(M[Y.name]) ? M[Y.name].push(Y.value) : M[Y.name] = [M[Y.name], Y.value] : M[Y.name] = Y.value, M), { __proto__: null });
          g.depth ??= a, g.colors ??= true;
          const N = Q.formatWithOptions(g, d);
          return `FormData ${N.slice(N.indexOf("]") + 2)}`;
        }
      }
      p("FormData", n, c, "name", "value"), Object.defineProperties(n.prototype, { append: E, delete: E, get: E, getAll: E, has: E, set: E, [Symbol.toStringTag]: { value: "FormData", configurable: true } });
      function r(o, a, g) {
        if (typeof a != "string") {
          if (B(a) || (a = a instanceof Blob ? new u([a], "blob", { type: a.type }) : new t(a, "blob", { type: a.type })), g !== void 0) {
            const d = { type: a.type, lastModified: a.lastModified };
            a = a instanceof l ? new u([a], g, d) : new t(a, g, d);
          }
        }
        return { name: o, value: a };
      }
      return e(r, "makeEntry"), formdata = { FormData: n, makeEntry: r }, formdata;
    }
    e(requireFormdata, "requireFormdata");
    var formdataParser;
    var hasRequiredFormdataParser;
    function requireFormdataParser() {
      if (hasRequiredFormdataParser)
        return formdataParser;
      hasRequiredFormdataParser = 1;
      const { isUSVString: A, bufferToLowerCasedHeaderName: p } = requireUtil$7(), { utf8DecodeBytes: c } = requireUtil$6(), { HTTP_TOKEN_CODEPOINTS: E, isomorphicDecode: t } = requireDataUrl(), { isFileLike: B } = requireFile(), { makeEntry: f } = requireFormdata(), l = require$$0__default, { File: Q } = require$$0__default$2, u = globalThis.File ?? Q, n = Buffer.from('form-data; name="'), r = Buffer.from("; filename"), o = Buffer.from("--"), a = Buffer.from(`--\r
`);
      function g(h) {
        for (let I = 0; I < h.length; ++I)
          if (h.charCodeAt(I) & -128)
            return false;
        return true;
      }
      e(g, "isAsciiString");
      function d(h) {
        const I = h.length;
        if (I < 27 || I > 70)
          return false;
        for (let k = 0; k < I; ++k) {
          const i = h.charCodeAt(k);
          if (!(i >= 48 && i <= 57 || i >= 65 && i <= 90 || i >= 97 && i <= 122 || i === 39 || i === 45 || i === 95))
            return false;
        }
        return true;
      }
      e(d, "validateBoundary");
      function N(h, I) {
        l(I !== "failure" && I.essence === "multipart/form-data");
        const k = I.parameters.get("boundary");
        if (k === void 0)
          return "failure";
        const i = Buffer.from(`--${k}`, "utf8"), F = [], m = { position: 0 };
        for (; h[m.position] === 13 && h[m.position + 1] === 10; )
          m.position += 2;
        let D = h.length;
        for (; h[D - 1] === 10 && h[D - 2] === 13; )
          D -= 2;
        for (D !== h.length && (h = h.subarray(0, D)); ; ) {
          if (h.subarray(m.position, m.position + i.length).equals(i))
            m.position += i.length;
          else
            return "failure";
          if (m.position === h.length - 2 && H(h, o, m) || m.position === h.length - 4 && H(h, a, m))
            return F;
          if (h[m.position] !== 13 || h[m.position + 1] !== 10)
            return "failure";
          m.position += 2;
          const S = M(h, m);
          if (S === "failure")
            return "failure";
          let { name: W, filename: q, contentType: O, encoding: P } = S;
          m.position += 2;
          let Z;
          {
            const EA = h.indexOf(i.subarray(2), m.position);
            if (EA === -1)
              return "failure";
            Z = h.subarray(m.position, EA - 4), m.position += Z.length, P === "base64" && (Z = Buffer.from(Z.toString(), "base64"));
          }
          if (h[m.position] !== 13 || h[m.position + 1] !== 10)
            return "failure";
          m.position += 2;
          let cA;
          q !== null ? (O ??= "text/plain", g(O) || (O = ""), cA = new u([Z], q, { type: O })) : cA = c(Buffer.from(Z)), l(A(W)), l(typeof cA == "string" && A(cA) || B(cA)), F.push(f(W, cA, q));
        }
      }
      e(N, "multipartFormDataParser");
      function M(h, I) {
        let k = null, i = null, F = null, m = null;
        for (; ; ) {
          if (h[I.position] === 13 && h[I.position + 1] === 10)
            return k === null ? "failure" : { name: k, filename: i, contentType: F, encoding: m };
          let D = J((S) => S !== 10 && S !== 13 && S !== 58, h, I);
          if (D = V(D, true, true, (S) => S === 9 || S === 32), !E.test(D.toString()) || h[I.position] !== 58)
            return "failure";
          switch (I.position++, J((S) => S === 32 || S === 9, h, I), p(D)) {
            case "content-disposition": {
              if (k = i = null, !H(h, n, I) || (I.position += 17, k = Y(h, I), k === null))
                return "failure";
              if (H(h, r, I)) {
                let S = I.position + r.length;
                if (h[S] === 42 && (I.position += 1, S += 1), h[S] !== 61 || h[S + 1] !== 34 || (I.position += 12, i = Y(h, I), i === null))
                  return "failure";
              }
              break;
            }
            case "content-type": {
              let S = J((W) => W !== 10 && W !== 13, h, I);
              S = V(S, false, true, (W) => W === 9 || W === 32), F = t(S);
              break;
            }
            case "content-transfer-encoding": {
              let S = J((W) => W !== 10 && W !== 13, h, I);
              S = V(S, false, true, (W) => W === 9 || W === 32), m = t(S);
              break;
            }
            default:
              J((S) => S !== 10 && S !== 13, h, I);
          }
          if (h[I.position] !== 13 && h[I.position + 1] !== 10)
            return "failure";
          I.position += 2;
        }
      }
      e(M, "parseMultipartFormDataHeaders");
      function Y(h, I) {
        l(h[I.position - 1] === 34);
        let k = J((i) => i !== 10 && i !== 13 && i !== 34, h, I);
        return h[I.position] !== 34 ? null : (I.position++, k = new TextDecoder().decode(k).replace(/%0A/ig, `
`).replace(/%0D/ig, "\r").replace(/%22/g, '"'), k);
      }
      e(Y, "parseMultipartFormDataName");
      function J(h, I, k) {
        let i = k.position;
        for (; i < I.length && h(I[i]); )
          ++i;
        return I.subarray(k.position, k.position = i);
      }
      e(J, "collectASequenceOfBytes");
      function V(h, I, k, i) {
        let F = 0, m = h.length - 1;
        if (I)
          for (; F < h.length && i(h[F]); )
            F++;
        for (; m > 0 && i(h[m]); )
          m--;
        return F === 0 && m === h.length - 1 ? h : h.subarray(F, m + 1);
      }
      e(V, "removeChars");
      function H(h, I, k) {
        if (h.length < I.length)
          return false;
        for (let i = 0; i < I.length; i++)
          if (I[i] !== h[k.position + i])
            return false;
        return true;
      }
      return e(H, "bufferStartsWith"), formdataParser = { multipartFormDataParser: N, validateBoundary: d }, formdataParser;
    }
    e(requireFormdataParser, "requireFormdataParser");
    var body;
    var hasRequiredBody;
    function requireBody() {
      if (hasRequiredBody)
        return body;
      hasRequiredBody = 1;
      const A = requireUtil$7(), { ReadableStreamFrom: p, isBlobLike: c, isReadableStreamLike: E, readableStreamClose: t, createDeferredPromise: B, fullyReadBody: f, extractMimeType: l, utf8DecodeBytes: Q } = requireUtil$6(), { FormData: u } = requireFormdata(), { kState: n } = requireSymbols$3(), { webidl: r } = requireWebidl(), { Blob: o } = require$$0__default$2, a = require$$0__default, { isErrored: g, isDisturbed: d } = Stream__default, { isArrayBuffer: N } = require$$8__default$1, { serializeAMimeType: M } = requireDataUrl(), { multipartFormDataParser: Y } = requireFormdataParser();
      let J;
      try {
        const Z = require("node:crypto");
        J = e((cA) => Z.randomInt(0, cA), "random");
      } catch {
        J = e((Z) => Math.floor(Math.random(Z)), "random");
      }
      const V = new TextEncoder();
      function H() {
      }
      e(H, "noop");
      const h = globalThis.FinalizationRegistry && process.version.indexOf("v18") !== 0;
      let I;
      h && (I = new FinalizationRegistry((Z) => {
        const cA = Z.deref();
        cA && !cA.locked && !d(cA) && !g(cA) && cA.cancel("Response object has been garbage collected").catch(H);
      }));
      function k(Z, cA = false) {
        let EA = null;
        Z instanceof ReadableStream ? EA = Z : c(Z) ? EA = Z.stream() : EA = new ReadableStream({ async pull(TA) {
          const UA = typeof uA == "string" ? V.encode(uA) : uA;
          UA.byteLength && TA.enqueue(UA), queueMicrotask(() => t(TA));
        }, start() {
        }, type: "bytes" }), a(E(EA));
        let fA = null, uA = null, pA = null, RA = null;
        if (typeof Z == "string")
          uA = Z, RA = "text/plain;charset=UTF-8";
        else if (Z instanceof URLSearchParams)
          uA = Z.toString(), RA = "application/x-www-form-urlencoded;charset=UTF-8";
        else if (N(Z))
          uA = new Uint8Array(Z.slice());
        else if (ArrayBuffer.isView(Z))
          uA = new Uint8Array(Z.buffer.slice(Z.byteOffset, Z.byteOffset + Z.byteLength));
        else if (A.isFormDataLike(Z)) {
          const TA = `----formdata-undici-0${`${J(1e11)}`.padStart(11, "0")}`, UA = `--${TA}\r
Content-Disposition: form-data`;
          const QA = e((sA) => sA.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), "escape"), eA = e((sA) => sA.replace(/\r?\n|\r/g, `\r
`), "normalizeLinefeeds"), lA = [], YA = new Uint8Array([13, 10]);
          pA = 0;
          let nA = false;
          for (const [sA, BA] of Z)
            if (typeof BA == "string") {
              const dA = V.encode(UA + `; name="${QA(eA(sA))}"\r
\r
${eA(BA)}\r
`);
              lA.push(dA), pA += dA.byteLength;
            } else {
              const dA = V.encode(`${UA}; name="${QA(eA(sA))}"` + (BA.name ? `; filename="${QA(BA.name)}"` : "") + `\r
Content-Type: ${BA.type || "application/octet-stream"}\r
\r
`);
              lA.push(dA, BA, YA), typeof BA.size == "number" ? pA += dA.byteLength + BA.size + YA.byteLength : nA = true;
            }
          const $2 = V.encode(`--${TA}--`);
          lA.push($2), pA += $2.byteLength, nA && (pA = null), uA = Z, fA = e(async function* () {
            for (const sA of lA)
              sA.stream ? yield* sA.stream() : yield sA;
          }, "action"), RA = `multipart/form-data; boundary=${TA}`;
        } else if (c(Z))
          uA = Z, pA = Z.size, Z.type && (RA = Z.type);
        else if (typeof Z[Symbol.asyncIterator] == "function") {
          if (cA)
            throw new TypeError("keepalive");
          if (A.isDisturbed(Z) || Z.locked)
            throw new TypeError("Response body object should not be disturbed or locked");
          EA = Z instanceof ReadableStream ? Z : p(Z);
        }
        if ((typeof uA == "string" || A.isBuffer(uA)) && (pA = Buffer.byteLength(uA)), fA != null) {
          let TA;
          EA = new ReadableStream({ async start() {
            TA = fA(Z)[Symbol.asyncIterator]();
          }, async pull(UA) {
            const { value: QA, done: eA } = await TA.next();
            if (eA)
              queueMicrotask(() => {
                UA.close(), UA.byobRequest?.respond(0);
              });
            else if (!g(EA)) {
              const lA = new Uint8Array(QA);
              lA.byteLength && UA.enqueue(lA);
            }
            return UA.desiredSize > 0;
          }, async cancel(UA) {
            await TA.return();
          }, type: "bytes" });
        }
        return [{ stream: EA, source: uA, length: pA }, RA];
      }
      e(k, "extractBody");
      function i(Z, cA = false) {
        return Z instanceof ReadableStream && (a(!A.isDisturbed(Z), "The body has already been consumed."), a(!Z.locked, "The stream is locked.")), k(Z, cA);
      }
      e(i, "safelyExtractBody");
      function F(Z, cA) {
        const [EA, fA] = cA.stream.tee();
        return h && I.register(Z, new WeakRef(EA)), cA.stream = EA, { stream: fA, length: cA.length, source: cA.source };
      }
      e(F, "cloneBody");
      function m(Z) {
        if (Z.aborted)
          throw new DOMException("The operation was aborted.", "AbortError");
      }
      e(m, "throwIfAborted");
      function D(Z) {
        return { blob() {
          return W(this, (EA) => {
            let fA = P(this);
            return fA === null ? fA = "" : fA && (fA = M(fA)), new o([EA], { type: fA });
          }, Z);
        }, arrayBuffer() {
          return W(this, (EA) => new Uint8Array(EA).buffer, Z);
        }, text() {
          return W(this, Q, Z);
        }, json() {
          return W(this, O, Z);
        }, formData() {
          return W(this, (EA) => {
            const fA = P(this);
            if (fA !== null)
              switch (fA.essence) {
                case "multipart/form-data": {
                  const uA = Y(EA, fA);
                  if (uA === "failure")
                    throw new TypeError("Failed to parse body as FormData.");
                  const pA = new u();
                  return pA[n] = uA, pA;
                }
                case "application/x-www-form-urlencoded": {
                  const uA = new URLSearchParams(EA.toString()), pA = new u();
                  for (const [RA, DA] of uA)
                    pA.append(RA, DA);
                  return pA;
                }
              }
            throw new TypeError('Content-Type was not one of "multipart/form-data" or "application/x-www-form-urlencoded".');
          }, Z);
        }, bytes() {
          return W(this, (EA) => new Uint8Array(EA), Z);
        } };
      }
      e(D, "bodyMixinMethods");
      function S(Z) {
        Object.assign(Z.prototype, D(Z));
      }
      e(S, "mixinBody");
      async function W(Z, cA, EA) {
        if (r.brandCheck(Z, EA), q(Z))
          throw new TypeError("Body is unusable: Body has already been read");
        m(Z[n]);
        const fA = B(), uA = e((RA) => fA.reject(RA), "errorSteps"), pA = e((RA) => {
          try {
            fA.resolve(cA(RA));
          } catch (DA) {
            uA(DA);
          }
        }, "successSteps");
        return Z[n].body == null ? (pA(Buffer.allocUnsafe(0)), fA.promise) : (await f(Z[n].body, pA, uA), fA.promise);
      }
      e(W, "consumeBody");
      function q(Z) {
        const cA = Z[n].body;
        return cA != null && (cA.stream.locked || A.isDisturbed(cA.stream));
      }
      e(q, "bodyUnusable");
      function O(Z) {
        return JSON.parse(Q(Z));
      }
      e(O, "parseJSONFromBytes");
      function P(Z) {
        const cA = Z[n].headersList, EA = l(cA);
        return EA === "failure" ? null : EA;
      }
      return e(P, "bodyMimeType"), body = { extractBody: k, safelyExtractBody: i, cloneBody: F, mixinBody: S, streamRegistry: I, hasFinalizationRegistry: h, bodyUnusable: q }, body;
    }
    e(requireBody, "requireBody");
    var clientH1;
    var hasRequiredClientH1;
    function requireClientH1() {
      if (hasRequiredClientH1)
        return clientH1;
      hasRequiredClientH1 = 1;
      const A = require$$0__default, p = requireUtil$7(), { channels: c } = requireDiagnostics(), E = requireTimers(), { RequestContentLengthMismatchError: t, ResponseContentLengthMismatchError: B, RequestAbortedError: f, HeadersTimeoutError: l, HeadersOverflowError: Q, SocketError: u, InformationalError: n, BodyTimeoutError: r, HTTPParserError: o, ResponseExceededMaxSizeError: a } = requireErrors(), { kUrl: g, kReset: d, kClient: N, kParser: M, kBlocking: Y, kRunning: J, kPending: V, kSize: H, kWriting: h, kQueue: I, kNoRef: k, kKeepAliveDefaultTimeout: i, kHostHeader: F, kPendingIdx: m, kRunningIdx: D, kError: S, kPipelining: W, kSocket: q, kKeepAliveTimeoutValue: O, kMaxHeadersSize: P, kKeepAliveMaxTimeout: Z, kKeepAliveTimeoutThreshold: cA, kHeadersTimeout: EA, kBodyTimeout: fA, kStrictContentLength: uA, kMaxRequests: pA, kCounter: RA, kMaxResponseSize: DA, kOnError: TA, kResume: UA, kHTTPContext: QA } = requireSymbols$4(), eA = requireConstants$3(), lA = Buffer.alloc(0), YA = Buffer[Symbol.species], nA = p.addListener, $2 = p.removeAllListeners;
      let sA;
      async function BA() {
        const kA = process.env.JEST_WORKER_ID ? requireLlhttpWasm() : void 0;
        let z;
        try {
          z = await WebAssembly.compile(requireLlhttp_simdWasm());
        } catch {
          z = await WebAssembly.compile(kA || requireLlhttpWasm());
        }
        return await WebAssembly.instantiate(z, { env: { wasm_on_url: e((iA, rA, aA) => 0, "wasm_on_url"), wasm_on_status: e((iA, rA, aA) => {
          A(mA.ptr === iA);
          const yA = rA - WA + xA.byteOffset;
          return mA.onStatus(new YA(xA.buffer, yA, aA)) || 0;
        }, "wasm_on_status"), wasm_on_message_begin: e((iA) => (A(mA.ptr === iA), mA.onMessageBegin() || 0), "wasm_on_message_begin"), wasm_on_header_field: e((iA, rA, aA) => {
          A(mA.ptr === iA);
          const yA = rA - WA + xA.byteOffset;
          return mA.onHeaderField(new YA(xA.buffer, yA, aA)) || 0;
        }, "wasm_on_header_field"), wasm_on_header_value: e((iA, rA, aA) => {
          A(mA.ptr === iA);
          const yA = rA - WA + xA.byteOffset;
          return mA.onHeaderValue(new YA(xA.buffer, yA, aA)) || 0;
        }, "wasm_on_header_value"), wasm_on_headers_complete: e((iA, rA, aA, yA) => (A(mA.ptr === iA), mA.onHeadersComplete(rA, !!aA, !!yA) || 0), "wasm_on_headers_complete"), wasm_on_body: e((iA, rA, aA) => {
          A(mA.ptr === iA);
          const yA = rA - WA + xA.byteOffset;
          return mA.onBody(new YA(xA.buffer, yA, aA)) || 0;
        }, "wasm_on_body"), wasm_on_message_complete: e((iA) => (A(mA.ptr === iA), mA.onMessageComplete() || 0), "wasm_on_message_complete") } });
      }
      e(BA, "lazyllhttp");
      let dA = null, CA = BA();
      CA.catch();
      let mA = null, xA = null, bA = 0, WA = null;
      const LA = 0, GA = 1, NA = 2 | GA, KA = 4 | GA, ZA = 8 | LA;
      class PA {
        static {
          e(this, "Parser");
        }
        constructor(z, iA, { exports: rA }) {
          A(Number.isFinite(z[P]) && z[P] > 0), this.llhttp = rA, this.ptr = this.llhttp.llhttp_alloc(eA.TYPE.RESPONSE), this.client = z, this.socket = iA, this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.statusCode = null, this.statusText = "", this.upgrade = false, this.headers = [], this.headersSize = 0, this.headersMaxSize = z[P], this.shouldKeepAlive = false, this.paused = false, this.resume = this.resume.bind(this), this.bytesRead = 0, this.keepAlive = "", this.contentLength = "", this.connection = "", this.maxResponseSize = z[DA];
        }
        setTimeout(z, iA) {
          z !== this.timeoutValue || iA & GA ^ this.timeoutType & GA ? (this.timeout && (E.clearTimeout(this.timeout), this.timeout = null), z && (iA & GA ? this.timeout = E.setFastTimeout(oA, z, new WeakRef(this)) : (this.timeout = setTimeout(oA, z, new WeakRef(this)), this.timeout.unref())), this.timeoutValue = z) : this.timeout && this.timeout.refresh && this.timeout.refresh(), this.timeoutType = iA;
        }
        resume() {
          this.socket.destroyed || !this.paused || (A(this.ptr != null), A(mA == null), this.llhttp.llhttp_resume(this.ptr), A(this.timeoutType === KA), this.timeout && this.timeout.refresh && this.timeout.refresh(), this.paused = false, this.execute(this.socket.read() || lA), this.readMore());
        }
        readMore() {
          for (; !this.paused && this.ptr; ) {
            const z = this.socket.read();
            if (z === null)
              break;
            this.execute(z);
          }
        }
        execute(z) {
          A(this.ptr != null), A(mA == null), A(!this.paused);
          const { socket: iA, llhttp: rA } = this;
          z.length > bA && (WA && rA.free(WA), bA = Math.ceil(z.length / 4096) * 4096, WA = rA.malloc(bA)), new Uint8Array(rA.memory.buffer, WA, bA).set(z);
          try {
            let aA;
            try {
              xA = z, mA = this, aA = rA.llhttp_execute(this.ptr, WA, z.length);
            } catch (SA) {
              throw SA;
            } finally {
              mA = null, xA = null;
            }
            const yA = rA.llhttp_get_error_pos(this.ptr) - WA;
            if (aA === eA.ERROR.PAUSED_UPGRADE)
              this.onUpgrade(z.slice(yA));
            else if (aA === eA.ERROR.PAUSED)
              this.paused = true, iA.unshift(z.slice(yA));
            else if (aA !== eA.ERROR.OK) {
              const SA = rA.llhttp_get_error_reason(this.ptr);
              let vA = "";
              if (SA) {
                const G = new Uint8Array(rA.memory.buffer, SA).indexOf(0);
                vA = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(rA.memory.buffer, SA, G).toString() + ")";
              }
              throw new o(vA, eA.ERROR[aA], z.slice(yA));
            }
          } catch (aA) {
            p.destroy(iA, aA);
          }
        }
        destroy() {
          A(this.ptr != null), A(mA == null), this.llhttp.llhttp_free(this.ptr), this.ptr = null, this.timeout && E.clearTimeout(this.timeout), this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.paused = false;
        }
        onStatus(z) {
          this.statusText = z.toString();
        }
        onMessageBegin() {
          const { socket: z, client: iA } = this;
          if (z.destroyed)
            return -1;
          const rA = iA[I][iA[D]];
          if (!rA)
            return -1;
          rA.onResponseStarted();
        }
        onHeaderField(z) {
          const iA = this.headers.length;
          iA & 1 ? this.headers[iA - 1] = Buffer.concat([this.headers[iA - 1], z]) : this.headers.push(z), this.trackHeader(z.length);
        }
        onHeaderValue(z) {
          let iA = this.headers.length;
          (iA & 1) === 1 ? (this.headers.push(z), iA += 1) : this.headers[iA - 1] = Buffer.concat([this.headers[iA - 1], z]);
          const rA = this.headers[iA - 2];
          if (rA.length === 10) {
            const aA = p.bufferToLowerCasedHeaderName(rA);
            aA === "keep-alive" ? this.keepAlive += z.toString() : aA === "connection" && (this.connection += z.toString());
          } else
            rA.length === 14 && p.bufferToLowerCasedHeaderName(rA) === "content-length" && (this.contentLength += z.toString());
          this.trackHeader(z.length);
        }
        trackHeader(z) {
          this.headersSize += z, this.headersSize >= this.headersMaxSize && p.destroy(this.socket, new Q());
        }
        onUpgrade(z) {
          const { upgrade: iA, client: rA, socket: aA, headers: yA, statusCode: SA } = this;
          A(iA), A(rA[q] === aA), A(!aA.destroyed), A(!this.paused), A((yA.length & 1) === 0);
          const vA = rA[I][rA[D]];
          A(vA), A(vA.upgrade || vA.method === "CONNECT"), this.statusCode = null, this.statusText = "", this.shouldKeepAlive = null, this.headers = [], this.headersSize = 0, aA.unshift(z), aA[M].destroy(), aA[M] = null, aA[N] = null, aA[S] = null, $2(aA), rA[q] = null, rA[QA] = null, rA[I][rA[D]++] = null, rA.emit("disconnect", rA[g], [rA], new n("upgrade"));
          try {
            vA.onUpgrade(SA, yA, aA);
          } catch (G) {
            p.destroy(aA, G);
          }
          rA[UA]();
        }
        onHeadersComplete(z, iA, rA) {
          const { client: aA, socket: yA, headers: SA, statusText: vA } = this;
          if (yA.destroyed)
            return -1;
          const G = aA[I][aA[D]];
          if (!G)
            return -1;
          if (A(!this.upgrade), A(this.statusCode < 200), z === 100)
            return p.destroy(yA, new u("bad response", p.getSocketInfo(yA))), -1;
          if (iA && !G.upgrade)
            return p.destroy(yA, new u("bad upgrade", p.getSocketInfo(yA))), -1;
          if (A(this.timeoutType === NA), this.statusCode = z, this.shouldKeepAlive = rA || G.method === "HEAD" && !yA[d] && this.connection.toLowerCase() === "keep-alive", this.statusCode >= 200) {
            const T = G.bodyTimeout != null ? G.bodyTimeout : aA[fA];
            this.setTimeout(T, KA);
          } else
            this.timeout && this.timeout.refresh && this.timeout.refresh();
          if (G.method === "CONNECT")
            return A(aA[J] === 1), this.upgrade = true, 2;
          if (iA)
            return A(aA[J] === 1), this.upgrade = true, 2;
          if (A((this.headers.length & 1) === 0), this.headers = [], this.headersSize = 0, this.shouldKeepAlive && aA[W]) {
            const T = this.keepAlive ? p.parseKeepAliveTimeout(this.keepAlive) : null;
            if (T != null) {
              const X = Math.min(T - aA[cA], aA[Z]);
              X <= 0 ? yA[d] = true : aA[O] = X;
            } else
              aA[O] = aA[i];
          } else
            yA[d] = true;
          const j = G.onHeaders(z, SA, this.resume, vA) === false;
          return G.aborted ? -1 : G.method === "HEAD" || z < 200 ? 1 : (yA[Y] && (yA[Y] = false, aA[UA]()), j ? eA.ERROR.PAUSED : 0);
        }
        onBody(z) {
          const { client: iA, socket: rA, statusCode: aA, maxResponseSize: yA } = this;
          if (rA.destroyed)
            return -1;
          const SA = iA[I][iA[D]];
          if (A(SA), A(this.timeoutType === KA), this.timeout && this.timeout.refresh && this.timeout.refresh(), A(aA >= 200), yA > -1 && this.bytesRead + z.length > yA)
            return p.destroy(rA, new a()), -1;
          if (this.bytesRead += z.length, SA.onData(z) === false)
            return eA.ERROR.PAUSED;
        }
        onMessageComplete() {
          const { client: z, socket: iA, statusCode: rA, upgrade: aA, headers: yA, contentLength: SA, bytesRead: vA, shouldKeepAlive: G } = this;
          if (iA.destroyed && (!rA || G))
            return -1;
          if (aA)
            return;
          A(rA >= 100), A((this.headers.length & 1) === 0);
          const j = z[I][z[D]];
          if (A(j), this.statusCode = null, this.statusText = "", this.bytesRead = 0, this.contentLength = "", this.keepAlive = "", this.connection = "", this.headers = [], this.headersSize = 0, !(rA < 200)) {
            if (j.method !== "HEAD" && SA && vA !== parseInt(SA, 10))
              return p.destroy(iA, new B()), -1;
            if (j.onComplete(yA), z[I][z[D]++] = null, iA[h])
              return A(z[J] === 0), p.destroy(iA, new n("reset")), eA.ERROR.PAUSED;
            if (G) {
              if (iA[d] && z[J] === 0)
                return p.destroy(iA, new n("reset")), eA.ERROR.PAUSED;
              z[W] == null || z[W] === 1 ? setImmediate(() => z[UA]()) : z[UA]();
            } else
              return p.destroy(iA, new n("reset")), eA.ERROR.PAUSED;
          }
        }
      }
      function oA(kA) {
        const { socket: z, timeoutType: iA, client: rA, paused: aA } = kA.deref();
        iA === NA ? (!z[h] || z.writableNeedDrain || rA[J] > 1) && (A(!aA, "cannot be paused while waiting for headers"), p.destroy(z, new l())) : iA === KA ? aA || p.destroy(z, new r()) : iA === ZA && (A(rA[J] === 0 && rA[O]), p.destroy(z, new n("socket idle timeout")));
      }
      e(oA, "onParserTimeout");
      async function L(kA, z) {
        kA[q] = z, dA || (dA = await CA, CA = null), z[k] = false, z[h] = false, z[d] = false, z[Y] = false, z[M] = new PA(kA, z, dA), nA(z, "error", function(rA) {
          A(rA.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
          const aA = this[M];
          if (rA.code === "ECONNRESET" && aA.statusCode && !aA.shouldKeepAlive) {
            aA.onMessageComplete();
            return;
          }
          this[S] = rA, this[N][TA](rA);
        }), nA(z, "readable", function() {
          const rA = this[M];
          rA && rA.readMore();
        }), nA(z, "end", function() {
          const rA = this[M];
          if (rA.statusCode && !rA.shouldKeepAlive) {
            rA.onMessageComplete();
            return;
          }
          p.destroy(this, new u("other side closed", p.getSocketInfo(this)));
        }), nA(z, "close", function() {
          const rA = this[N], aA = this[M];
          aA && (!this[S] && aA.statusCode && !aA.shouldKeepAlive && aA.onMessageComplete(), this[M].destroy(), this[M] = null);
          const yA = this[S] || new u("closed", p.getSocketInfo(this));
          if (rA[q] = null, rA[QA] = null, rA.destroyed) {
            A(rA[V] === 0);
            const SA = rA[I].splice(rA[D]);
            for (let vA = 0; vA < SA.length; vA++) {
              const G = SA[vA];
              p.errorRequest(rA, G, yA);
            }
          } else if (rA[J] > 0 && yA.code !== "UND_ERR_INFO") {
            const SA = rA[I][rA[D]];
            rA[I][rA[D]++] = null, p.errorRequest(rA, SA, yA);
          }
          rA[m] = rA[D], A(rA[J] === 0), rA.emit("disconnect", rA[g], [rA], yA), rA[UA]();
        });
        let iA = false;
        return z.on("close", () => {
          iA = true;
        }), { version: "h1", defaultPipelining: 1, write(...rA) {
          return wA(kA, ...rA);
        }, resume() {
          AA(kA);
        }, destroy(rA, aA) {
          iA ? queueMicrotask(aA) : z.destroy(rA).on("close", aA);
        }, get destroyed() {
          return z.destroyed;
        }, busy(rA) {
          return !!(z[h] || z[d] || z[Y] || rA && (kA[J] > 0 && !rA.idempotent || kA[J] > 0 && (rA.upgrade || rA.method === "CONNECT") || kA[J] > 0 && p.bodyLength(rA.body) !== 0 && (p.isStream(rA.body) || p.isAsyncIterable(rA.body) || p.isFormDataLike(rA.body))));
        } };
      }
      e(L, "connectH1");
      function AA(kA) {
        const z = kA[q];
        if (z && !z.destroyed) {
          if (kA[H] === 0 ? !z[k] && z.unref && (z.unref(), z[k] = true) : z[k] && z.ref && (z.ref(), z[k] = false), kA[H] === 0)
            z[M].timeoutType !== ZA && z[M].setTimeout(kA[O], ZA);
          else if (kA[J] > 0 && z[M].statusCode < 200 && z[M].timeoutType !== NA) {
            const iA = kA[I][kA[D]], rA = iA.headersTimeout != null ? iA.headersTimeout : kA[EA];
            z[M].setTimeout(rA, NA);
          }
        }
      }
      e(AA, "resumeH1");
      function IA(kA) {
        return kA !== "GET" && kA !== "HEAD" && kA !== "OPTIONS" && kA !== "TRACE" && kA !== "CONNECT";
      }
      e(IA, "shouldSendContentLength");
      function wA(kA, z) {
        const { method: iA, path: rA, host: aA, upgrade: yA, blocking: SA, reset: vA } = z;
        let { body: G, headers: j, contentLength: T } = z;
        const X = iA === "PUT" || iA === "POST" || iA === "PATCH" || iA === "QUERY" || iA === "PROPFIND" || iA === "PROPPATCH";
        if (p.isFormDataLike(G)) {
          sA || (sA = requireBody().extractBody);
          const [hA, JA] = sA(G);
          z.contentType == null && j.push("content-type", JA), G = hA.stream, T = hA.length;
        } else
          p.isBlobLike(G) && z.contentType == null && G.type && j.push("content-type", G.type);
        G && typeof G.read == "function" && G.read(0);
        const K = p.bodyLength(G);
        if (T = K ?? T, T === null && (T = z.contentLength), T === 0 && !X && (T = null), IA(iA) && T > 0 && z.contentLength !== null && z.contentLength !== T) {
          if (kA[uA])
            return p.errorRequest(kA, z, new t()), false;
          process.emitWarning(new t());
        }
        const _ = kA[q], gA = e((hA) => {
          z.aborted || z.completed || (p.errorRequest(kA, z, hA || new f()), p.destroy(G), p.destroy(_, new n("aborted")));
        }, "abort");
        try {
          z.onConnect(gA);
        } catch (hA) {
          p.errorRequest(kA, z, hA);
        }
        if (z.aborted)
          return false;
        iA === "HEAD" && (_[d] = true), (yA || iA === "CONNECT") && (_[d] = true), vA != null && (_[d] = vA), kA[pA] && _[RA]++ >= kA[pA] && (_[d] = true), SA && (_[Y] = true);
        let tA = `${iA} ${rA} HTTP/1.1\r
`;
        if (typeof aA == "string" ? tA += `host: ${aA}\r
` : tA += kA[F], yA ? tA += `connection: upgrade\r
upgrade: ${yA}\r
` : kA[W] && !_[d] ? tA += `connection: keep-alive\r
` : tA += `connection: close\r
`, Array.isArray(j))
          for (let hA = 0; hA < j.length; hA += 2) {
            const JA = j[hA + 0], qA = j[hA + 1];
            if (Array.isArray(qA))
              for (let VA = 0; VA < qA.length; VA++)
                tA += `${JA}: ${qA[VA]}\r
`;
            else
              tA += `${JA}: ${qA}\r
`;
          }
        return c.sendHeaders.hasSubscribers && c.sendHeaders.publish({ request: z, headers: tA, socket: _ }), !G || K === 0 ? MA(gA, null, kA, z, _, T, tA, X) : p.isBuffer(G) ? MA(gA, G, kA, z, _, T, tA, X) : p.isBlobLike(G) ? typeof G.stream == "function" ? _A(gA, G.stream(), kA, z, _, T, tA, X) : OA(gA, G, kA, z, _, T, tA, X) : p.isStream(G) ? FA(gA, G, kA, z, _, T, tA, X) : p.isIterable(G) ? _A(gA, G, kA, z, _, T, tA, X) : A(false), true;
      }
      e(wA, "writeH1");
      function FA(kA, z, iA, rA, aA, yA, SA, vA) {
        A(yA !== 0 || iA[J] === 0, "stream body cannot be pipelined");
        let G = false;
        const j = new $A({ abort: kA, socket: aA, request: rA, contentLength: yA, client: iA, expectsPayload: vA, header: SA }), T = e(function(gA) {
          if (!G)
            try {
              !j.write(gA) && this.pause && this.pause();
            } catch (tA) {
              p.destroy(this, tA);
            }
        }, "onData"), X = e(function() {
          G || z.resume && z.resume();
        }, "onDrain"), K = e(function() {
          if (queueMicrotask(() => {
            z.removeListener("error", _);
          }), !G) {
            const gA = new f();
            queueMicrotask(() => _(gA));
          }
        }, "onClose"), _ = e(function(gA) {
          if (!G) {
            if (G = true, A(aA.destroyed || aA[h] && iA[J] <= 1), aA.off("drain", X).off("error", _), z.removeListener("data", T).removeListener("end", _).removeListener("close", K), !gA)
              try {
                j.end();
              } catch (tA) {
                gA = tA;
              }
            j.destroy(gA), gA && (gA.code !== "UND_ERR_INFO" || gA.message !== "reset") ? p.destroy(z, gA) : p.destroy(z);
          }
        }, "onFinished");
        z.on("data", T).on("end", _).on("error", _).on("close", K), z.resume && z.resume(), aA.on("drain", X).on("error", _), z.errorEmitted ?? z.errored ? setImmediate(() => _(z.errored)) : (z.endEmitted ?? z.readableEnded) && setImmediate(() => _(null)), (z.closeEmitted ?? z.closed) && setImmediate(K);
      }
      e(FA, "writeStream");
      function MA(kA, z, iA, rA, aA, yA, SA, vA) {
        try {
          z ? p.isBuffer(z) && (A(yA === z.byteLength, "buffer body must have content length"), aA.cork(), aA.write(`${SA}content-length: ${yA}\r
\r
`, "latin1"), aA.write(z), aA.uncork(), rA.onBodySent(z), !vA && rA.reset !== false && (aA[d] = true)) : yA === 0 ? aA.write(`${SA}content-length: 0\r
\r
`, "latin1") : (A(yA === null, "no body must not have content length"), aA.write(`${SA}\r
`, "latin1")), rA.onRequestSent(), iA[UA]();
        } catch (G) {
          kA(G);
        }
      }
      e(MA, "writeBuffer");
      async function OA(kA, z, iA, rA, aA, yA, SA, vA) {
        A(yA === z.size, "blob body must have content length");
        try {
          if (yA != null && yA !== z.size)
            throw new t();
          const G = Buffer.from(await z.arrayBuffer());
          aA.cork(), aA.write(`${SA}content-length: ${yA}\r
\r
`, "latin1"), aA.write(G), aA.uncork(), rA.onBodySent(G), rA.onRequestSent(), !vA && rA.reset !== false && (aA[d] = true), iA[UA]();
        } catch (G) {
          kA(G);
        }
      }
      e(OA, "writeBlob");
      async function _A(kA, z, iA, rA, aA, yA, SA, vA) {
        A(yA !== 0 || iA[J] === 0, "iterator body cannot be pipelined");
        let G = null;
        function j() {
          if (G) {
            const K = G;
            G = null, K();
          }
        }
        e(j, "onDrain");
        const T = e(() => new Promise((K, _) => {
          A(G === null), aA[S] ? _(aA[S]) : G = K;
        }), "waitForDrain");
        aA.on("close", j).on("drain", j);
        const X = new $A({ abort: kA, socket: aA, request: rA, contentLength: yA, client: iA, expectsPayload: vA, header: SA });
        try {
          for await (const K of z) {
            if (aA[S])
              throw aA[S];
            X.write(K) || await T();
          }
          X.end();
        } catch (K) {
          X.destroy(K);
        } finally {
          aA.off("close", j).off("drain", j);
        }
      }
      e(_A, "writeIterable");
      class $A {
        static {
          e(this, "AsyncWriter");
        }
        constructor({ abort: z, socket: iA, request: rA, contentLength: aA, client: yA, expectsPayload: SA, header: vA }) {
          this.socket = iA, this.request = rA, this.contentLength = aA, this.client = yA, this.bytesWritten = 0, this.expectsPayload = SA, this.header = vA, this.abort = z, iA[h] = true;
        }
        write(z) {
          const { socket: iA, request: rA, contentLength: aA, client: yA, bytesWritten: SA, expectsPayload: vA, header: G } = this;
          if (iA[S])
            throw iA[S];
          if (iA.destroyed)
            return false;
          const j = Buffer.byteLength(z);
          if (!j)
            return true;
          if (aA !== null && SA + j > aA) {
            if (yA[uA])
              throw new t();
            process.emitWarning(new t());
          }
          iA.cork(), SA === 0 && (!vA && rA.reset !== false && (iA[d] = true), aA === null ? iA.write(`${G}transfer-encoding: chunked\r
`, "latin1") : iA.write(`${G}content-length: ${aA}\r
\r
`, "latin1")), aA === null && iA.write(`\r
${j.toString(16)}\r
`, "latin1"), this.bytesWritten += j;
          const T = iA.write(z);
          return iA.uncork(), rA.onBodySent(z), T || iA[M].timeout && iA[M].timeoutType === NA && iA[M].timeout.refresh && iA[M].timeout.refresh(), T;
        }
        end() {
          const { socket: z, contentLength: iA, client: rA, bytesWritten: aA, expectsPayload: yA, header: SA, request: vA } = this;
          if (vA.onRequestSent(), z[h] = false, z[S])
            throw z[S];
          if (!z.destroyed) {
            if (aA === 0 ? yA ? z.write(`${SA}content-length: 0\r
\r
`, "latin1") : z.write(`${SA}\r
`, "latin1") : iA === null && z.write(`\r
0\r
\r
`, "latin1"), iA !== null && aA !== iA) {
              if (rA[uA])
                throw new t();
              process.emitWarning(new t());
            }
            z[M].timeout && z[M].timeoutType === NA && z[M].timeout.refresh && z[M].timeout.refresh(), rA[UA]();
          }
        }
        destroy(z) {
          const { socket: iA, client: rA, abort: aA } = this;
          iA[h] = false, z && (A(rA[J] <= 1, "pipeline should only contain this request"), aA(z));
        }
      }
      return clientH1 = L, clientH1;
    }
    e(requireClientH1, "requireClientH1");
    var clientH2;
    var hasRequiredClientH2;
    function requireClientH2() {
      if (hasRequiredClientH2)
        return clientH2;
      hasRequiredClientH2 = 1;
      const A = require$$0__default, { pipeline: p } = Stream__default, c = requireUtil$7(), { RequestContentLengthMismatchError: E, RequestAbortedError: t, SocketError: B, InformationalError: f } = requireErrors(), { kUrl: l, kReset: Q, kClient: u, kRunning: n, kPending: r, kQueue: o, kPendingIdx: a, kRunningIdx: g, kError: d, kSocket: N, kStrictContentLength: M, kOnError: Y, kMaxConcurrentStreams: J, kHTTP2Session: V, kResume: H, kSize: h, kHTTPContext: I } = requireSymbols$4(), k = Symbol("open streams");
      let i, F = false, m;
      try {
        m = require("node:http2");
      } catch {
        m = { constants: {} };
      }
      const { constants: { HTTP2_HEADER_AUTHORITY: D, HTTP2_HEADER_METHOD: S, HTTP2_HEADER_PATH: W, HTTP2_HEADER_SCHEME: q, HTTP2_HEADER_CONTENT_LENGTH: O, HTTP2_HEADER_EXPECT: P, HTTP2_HEADER_STATUS: Z } } = m;
      function cA(nA) {
        const $2 = [];
        for (const [sA, BA] of Object.entries(nA))
          if (Array.isArray(BA))
            for (const dA of BA)
              $2.push(Buffer.from(sA), Buffer.from(dA));
          else
            $2.push(Buffer.from(sA), Buffer.from(BA));
        return $2;
      }
      e(cA, "parseH2Headers");
      async function EA(nA, $2) {
        nA[N] = $2, F || (F = true, process.emitWarning("H2 support is experimental, expect them to change at any time.", { code: "UNDICI-H2" }));
        const sA = m.connect(nA[l], { createConnection: e(() => $2, "createConnection"), peerMaxConcurrentStreams: nA[J] });
        sA[k] = 0, sA[u] = nA, sA[N] = $2, c.addListener(sA, "error", uA), c.addListener(sA, "frameError", pA), c.addListener(sA, "end", RA), c.addListener(sA, "goaway", DA), c.addListener(sA, "close", function() {
          const { [u]: dA } = this, { [N]: CA } = dA, mA = this[N][d] || this[d] || new B("closed", c.getSocketInfo(CA));
          if (dA[V] = null, dA.destroyed) {
            A(dA[r] === 0);
            const xA = dA[o].splice(dA[g]);
            for (let bA = 0; bA < xA.length; bA++) {
              const WA = xA[bA];
              c.errorRequest(dA, WA, mA);
            }
          }
        }), sA.unref(), nA[V] = sA, $2[V] = sA, c.addListener($2, "error", function(dA) {
          A(dA.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), this[d] = dA, this[u][Y](dA);
        }), c.addListener($2, "end", function() {
          c.destroy(this, new B("other side closed", c.getSocketInfo(this)));
        }), c.addListener($2, "close", function() {
          const dA = this[d] || new B("closed", c.getSocketInfo(this));
          nA[N] = null, this[V] != null && this[V].destroy(dA), nA[a] = nA[g], A(nA[n] === 0), nA.emit("disconnect", nA[l], [nA], dA), nA[H]();
        });
        let BA = false;
        return $2.on("close", () => {
          BA = true;
        }), { version: "h2", defaultPipelining: 1 / 0, write(...dA) {
          return UA(nA, ...dA);
        }, resume() {
          fA(nA);
        }, destroy(dA, CA) {
          BA ? queueMicrotask(CA) : $2.destroy(dA).on("close", CA);
        }, get destroyed() {
          return $2.destroyed;
        }, busy() {
          return false;
        } };
      }
      e(EA, "connectH2");
      function fA(nA) {
        const $2 = nA[N];
        $2?.destroyed === false && (nA[h] === 0 && nA[J] === 0 ? ($2.unref(), nA[V].unref()) : ($2.ref(), nA[V].ref()));
      }
      e(fA, "resumeH2");
      function uA(nA) {
        A(nA.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), this[N][d] = nA, this[u][Y](nA);
      }
      e(uA, "onHttp2SessionError");
      function pA(nA, $2, sA) {
        if (sA === 0) {
          const BA = new f(`HTTP/2: "frameError" received - type ${nA}, code ${$2}`);
          this[N][d] = BA, this[u][Y](BA);
        }
      }
      e(pA, "onHttp2FrameError");
      function RA() {
        const nA = new B("other side closed", c.getSocketInfo(this[N]));
        this.destroy(nA), c.destroy(this[N], nA);
      }
      e(RA, "onHttp2SessionEnd");
      function DA(nA) {
        const $2 = this[d] || new B(`HTTP/2: "GOAWAY" frame received with code ${nA}`, c.getSocketInfo(this)), sA = this[u];
        if (sA[N] = null, sA[I] = null, this[V] != null && (this[V].destroy($2), this[V] = null), c.destroy(this[N], $2), sA[g] < sA[o].length) {
          const BA = sA[o][sA[g]];
          sA[o][sA[g]++] = null, c.errorRequest(sA, BA, $2), sA[a] = sA[g];
        }
        A(sA[n] === 0), sA.emit("disconnect", sA[l], [sA], $2), sA[H]();
      }
      e(DA, "onHTTP2GoAway");
      function TA(nA) {
        return nA !== "GET" && nA !== "HEAD" && nA !== "OPTIONS" && nA !== "TRACE" && nA !== "CONNECT";
      }
      e(TA, "shouldSendContentLength");
      function UA(nA, $2) {
        const sA = nA[V], { method: BA, path: dA, host: CA, upgrade: mA, expectContinue: xA, signal: bA, headers: WA } = $2;
        let { body: LA } = $2;
        if (mA)
          return c.errorRequest(nA, $2, new Error("Upgrade not supported for H2")), false;
        const GA = {};
        for (let wA = 0; wA < WA.length; wA += 2) {
          const FA = WA[wA + 0], MA = WA[wA + 1];
          if (Array.isArray(MA))
            for (let OA = 0; OA < MA.length; OA++)
              GA[FA] ? GA[FA] += `,${MA[OA]}` : GA[FA] = MA[OA];
          else
            GA[FA] = MA;
        }
        let NA;
        const { hostname: KA, port: ZA } = nA[l];
        GA[D] = CA || `${KA}${ZA ? `:${ZA}` : ""}`, GA[S] = BA;
        const PA = e((wA) => {
          $2.aborted || $2.completed || (wA = wA || new t(), c.errorRequest(nA, $2, wA), NA != null && c.destroy(NA, wA), c.destroy(LA, wA), nA[o][nA[g]++] = null, nA[H]());
        }, "abort");
        try {
          $2.onConnect(PA);
        } catch (wA) {
          c.errorRequest(nA, $2, wA);
        }
        if ($2.aborted)
          return false;
        if (BA === "CONNECT")
          return sA.ref(), NA = sA.request(GA, { endStream: false, signal: bA }), NA.id && !NA.pending ? ($2.onUpgrade(null, null, NA), ++sA[k], nA[o][nA[g]++] = null) : NA.once("ready", () => {
            $2.onUpgrade(null, null, NA), ++sA[k], nA[o][nA[g]++] = null;
          }), NA.once("close", () => {
            sA[k] -= 1, sA[k] === 0 && sA.unref();
          }), true;
        GA[W] = dA, GA[q] = "https";
        const oA = BA === "PUT" || BA === "POST" || BA === "PATCH";
        LA && typeof LA.read == "function" && LA.read(0);
        let L = c.bodyLength(LA);
        if (c.isFormDataLike(LA)) {
          i ??= requireBody().extractBody;
          const [wA, FA] = i(LA);
          GA["content-type"] = FA, LA = wA.stream, L = wA.length;
        }
        if (L == null && (L = $2.contentLength), (L === 0 || !oA) && (L = null), TA(BA) && L > 0 && $2.contentLength != null && $2.contentLength !== L) {
          if (nA[M])
            return c.errorRequest(nA, $2, new E()), false;
          process.emitWarning(new E());
        }
        L != null && (A(LA, "no body must not have content length"), GA[O] = `${L}`), sA.ref();
        const AA = BA === "GET" || BA === "HEAD" || LA === null;
        return xA ? (GA[P] = "100-continue", NA = sA.request(GA, { endStream: AA, signal: bA }), NA.once("continue", IA)) : (NA = sA.request(GA, { endStream: AA, signal: bA }), IA()), ++sA[k], NA.once("response", (wA) => {
          const { [Z]: FA, ...MA } = wA;
          if ($2.onResponseStarted(), $2.aborted) {
            const OA = new t();
            c.errorRequest(nA, $2, OA), c.destroy(NA, OA);
            return;
          }
          $2.onHeaders(Number(FA), cA(MA), NA.resume.bind(NA), "") === false && NA.pause(), NA.on("data", (OA) => {
            $2.onData(OA) === false && NA.pause();
          });
        }), NA.once("end", () => {
          (NA.state?.state == null || NA.state.state < 6) && $2.onComplete([]), sA[k] === 0 && sA.unref(), PA(new f("HTTP/2: stream half-closed (remote)")), nA[o][nA[g]++] = null, nA[a] = nA[g], nA[H]();
        }), NA.once("close", () => {
          sA[k] -= 1, sA[k] === 0 && sA.unref();
        }), NA.once("error", function(wA) {
          PA(wA);
        }), NA.once("frameError", (wA, FA) => {
          PA(new f(`HTTP/2: "frameError" received - type ${wA}, code ${FA}`));
        }), true;
        function IA() {
          !LA || L === 0 ? QA(PA, NA, null, nA, $2, nA[N], L, oA) : c.isBuffer(LA) ? QA(PA, NA, LA, nA, $2, nA[N], L, oA) : c.isBlobLike(LA) ? typeof LA.stream == "function" ? YA(PA, NA, LA.stream(), nA, $2, nA[N], L, oA) : lA(PA, NA, LA, nA, $2, nA[N], L, oA) : c.isStream(LA) ? eA(PA, nA[N], oA, NA, LA, nA, $2, L) : c.isIterable(LA) ? YA(PA, NA, LA, nA, $2, nA[N], L, oA) : A(false);
        }
        e(IA, "writeBodyH2");
      }
      e(UA, "writeH2");
      function QA(nA, $2, sA, BA, dA, CA, mA, xA) {
        try {
          sA != null && c.isBuffer(sA) && (A(mA === sA.byteLength, "buffer body must have content length"), $2.cork(), $2.write(sA), $2.uncork(), $2.end(), dA.onBodySent(sA)), xA || (CA[Q] = true), dA.onRequestSent(), BA[H]();
        } catch (bA) {
          nA(bA);
        }
      }
      e(QA, "writeBuffer");
      function eA(nA, $2, sA, BA, dA, CA, mA, xA) {
        A(xA !== 0 || CA[n] === 0, "stream body cannot be pipelined");
        const bA = p(dA, BA, (LA) => {
          LA ? (c.destroy(bA, LA), nA(LA)) : (c.removeAllListeners(bA), mA.onRequestSent(), sA || ($2[Q] = true), CA[H]());
        });
        c.addListener(bA, "data", WA);
        function WA(LA) {
          mA.onBodySent(LA);
        }
        e(WA, "onPipeData");
      }
      e(eA, "writeStream");
      async function lA(nA, $2, sA, BA, dA, CA, mA, xA) {
        A(mA === sA.size, "blob body must have content length");
        try {
          if (mA != null && mA !== sA.size)
            throw new E();
          const bA = Buffer.from(await sA.arrayBuffer());
          $2.cork(), $2.write(bA), $2.uncork(), $2.end(), dA.onBodySent(bA), dA.onRequestSent(), xA || (CA[Q] = true), BA[H]();
        } catch (bA) {
          nA(bA);
        }
      }
      e(lA, "writeBlob");
      async function YA(nA, $2, sA, BA, dA, CA, mA, xA) {
        A(mA !== 0 || BA[n] === 0, "iterator body cannot be pipelined");
        let bA = null;
        function WA() {
          if (bA) {
            const GA = bA;
            bA = null, GA();
          }
        }
        e(WA, "onDrain");
        const LA = e(() => new Promise((GA, NA) => {
          A(bA === null), CA[d] ? NA(CA[d]) : bA = GA;
        }), "waitForDrain");
        $2.on("close", WA).on("drain", WA);
        try {
          for await (const GA of sA) {
            if (CA[d])
              throw CA[d];
            const NA = $2.write(GA);
            dA.onBodySent(GA), NA || await LA();
          }
          $2.end(), dA.onRequestSent(), xA || (CA[Q] = true), BA[H]();
        } catch (GA) {
          nA(GA);
        } finally {
          $2.off("close", WA).off("drain", WA);
        }
      }
      return e(YA, "writeIterable"), clientH2 = EA, clientH2;
    }
    e(requireClientH2, "requireClientH2");
    var redirectHandler;
    var hasRequiredRedirectHandler;
    function requireRedirectHandler() {
      if (hasRequiredRedirectHandler)
        return redirectHandler;
      hasRequiredRedirectHandler = 1;
      const A = requireUtil$7(), { kBodyUsed: p } = requireSymbols$4(), c = require$$0__default, { InvalidArgumentError: E } = requireErrors(), t = require$$8__default, B = [300, 301, 302, 303, 307, 308], f = Symbol("body");
      class l {
        static {
          e(this, "BodyAsyncIterable");
        }
        constructor(a) {
          this[f] = a, this[p] = false;
        }
        async *[Symbol.asyncIterator]() {
          c(!this[p], "disturbed"), this[p] = true, yield* this[f];
        }
      }
      class Q {
        static {
          e(this, "RedirectHandler");
        }
        constructor(a, g, d, N) {
          if (g != null && (!Number.isInteger(g) || g < 0))
            throw new E("maxRedirections must be a positive number");
          A.validateHandler(N, d.method, d.upgrade), this.dispatch = a, this.location = null, this.abort = null, this.opts = { ...d, maxRedirections: 0 }, this.maxRedirections = g, this.handler = N, this.history = [], this.redirectionLimitReached = false, A.isStream(this.opts.body) ? (A.bodyLength(this.opts.body) === 0 && this.opts.body.on("data", function() {
            c(false);
          }), typeof this.opts.body.readableDidRead != "boolean" && (this.opts.body[p] = false, t.prototype.on.call(this.opts.body, "data", function() {
            this[p] = true;
          }))) : this.opts.body && typeof this.opts.body.pipeTo == "function" ? this.opts.body = new l(this.opts.body) : this.opts.body && typeof this.opts.body != "string" && !ArrayBuffer.isView(this.opts.body) && A.isIterable(this.opts.body) && (this.opts.body = new l(this.opts.body));
        }
        onConnect(a) {
          this.abort = a, this.handler.onConnect(a, { history: this.history });
        }
        onUpgrade(a, g, d) {
          this.handler.onUpgrade(a, g, d);
        }
        onError(a) {
          this.handler.onError(a);
        }
        onHeaders(a, g, d, N) {
          if (this.location = this.history.length >= this.maxRedirections || A.isDisturbed(this.opts.body) ? null : u(a, g), this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {
            this.request && this.request.abort(new Error("max redirects")), this.redirectionLimitReached = true, this.abort(new Error("max redirects"));
            return;
          }
          if (this.opts.origin && this.history.push(new URL(this.opts.path, this.opts.origin)), !this.location)
            return this.handler.onHeaders(a, g, d, N);
          const { origin: M, pathname: Y, search: J } = A.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin))), V = J ? `${Y}${J}` : Y;
          this.opts.headers = r(this.opts.headers, a === 303, this.opts.origin !== M), this.opts.path = V, this.opts.origin = M, this.opts.maxRedirections = 0, this.opts.query = null, a === 303 && this.opts.method !== "HEAD" && (this.opts.method = "GET", this.opts.body = null);
        }
        onData(a) {
          if (!this.location)
            return this.handler.onData(a);
        }
        onComplete(a) {
          this.location ? (this.location = null, this.abort = null, this.dispatch(this.opts, this)) : this.handler.onComplete(a);
        }
        onBodySent(a) {
          this.handler.onBodySent && this.handler.onBodySent(a);
        }
      }
      function u(o, a) {
        if (B.indexOf(o) === -1)
          return null;
        for (let g = 0; g < a.length; g += 2)
          if (a[g].length === 8 && A.headerNameToString(a[g]) === "location")
            return a[g + 1];
      }
      e(u, "parseLocation");
      function n(o, a, g) {
        if (o.length === 4)
          return A.headerNameToString(o) === "host";
        if (a && A.headerNameToString(o).startsWith("content-"))
          return true;
        if (g && (o.length === 13 || o.length === 6 || o.length === 19)) {
          const d = A.headerNameToString(o);
          return d === "authorization" || d === "cookie" || d === "proxy-authorization";
        }
        return false;
      }
      e(n, "shouldRemoveHeader");
      function r(o, a, g) {
        const d = [];
        if (Array.isArray(o))
          for (let N = 0; N < o.length; N += 2)
            n(o[N], a, g) || d.push(o[N], o[N + 1]);
        else if (o && typeof o == "object")
          for (const N of Object.keys(o))
            n(N, a, g) || d.push(N, o[N]);
        else
          c(o == null, "headers must be an object or an array");
        return d;
      }
      return e(r, "cleanRequestHeaders"), redirectHandler = Q, redirectHandler;
    }
    e(requireRedirectHandler, "requireRedirectHandler");
    var redirectInterceptor;
    var hasRequiredRedirectInterceptor;
    function requireRedirectInterceptor() {
      if (hasRequiredRedirectInterceptor)
        return redirectInterceptor;
      hasRequiredRedirectInterceptor = 1;
      const A = requireRedirectHandler();
      function p({ maxRedirections: c }) {
        return (E) => e(function(B, f) {
          const { maxRedirections: l = c } = B;
          if (!l)
            return E(B, f);
          const Q = new A(E, l, B, f);
          return B = { ...B, maxRedirections: 0 }, E(B, Q);
        }, "Intercept");
      }
      return e(p, "createRedirectInterceptor"), redirectInterceptor = p, redirectInterceptor;
    }
    e(requireRedirectInterceptor, "requireRedirectInterceptor");
    var client;
    var hasRequiredClient;
    function requireClient() {
      if (hasRequiredClient)
        return client;
      hasRequiredClient = 1;
      const A = require$$0__default, p = require$$0__default$1, c = http__default, E = requireUtil$7(), { channels: t } = requireDiagnostics(), B = requireRequest$1(), f = requireDispatcherBase(), { InvalidArgumentError: l, InformationalError: Q, ClientDestroyedError: u } = requireErrors(), n = requireConnect(), { kUrl: r, kServerName: o, kClient: a, kBusy: g, kConnect: d, kResuming: N, kRunning: M, kPending: Y, kSize: J, kQueue: V, kConnected: H, kConnecting: h, kNeedDrain: I, kKeepAliveDefaultTimeout: k, kHostHeader: i, kPendingIdx: F, kRunningIdx: m, kError: D, kPipelining: S, kKeepAliveTimeoutValue: W, kMaxHeadersSize: q, kKeepAliveMaxTimeout: O, kKeepAliveTimeoutThreshold: P, kHeadersTimeout: Z, kBodyTimeout: cA, kStrictContentLength: EA, kConnector: fA, kMaxRedirections: uA, kMaxRequests: pA, kCounter: RA, kClose: DA, kDestroy: TA, kDispatch: UA, kInterceptors: QA, kLocalAddress: eA, kMaxResponseSize: lA, kOnError: YA, kHTTPContext: nA, kMaxConcurrentStreams: $2, kResume: sA } = requireSymbols$4(), BA = requireClientH1(), dA = requireClientH2();
      let CA = false;
      const mA = Symbol("kClosedResolve"), xA = e(() => {
      }, "noop");
      function bA(oA) {
        return oA[S] ?? oA[nA]?.defaultPipelining ?? 1;
      }
      e(bA, "getPipelining");
      class WA extends f {
        static {
          e(this, "Client");
        }
        constructor(L, { interceptors: AA, maxHeaderSize: IA, headersTimeout: wA, socketTimeout: FA, requestTimeout: MA, connectTimeout: OA, bodyTimeout: _A, idleTimeout: $A, keepAlive: kA, keepAliveTimeout: z, maxKeepAliveTimeout: iA, keepAliveMaxTimeout: rA, keepAliveTimeoutThreshold: aA, socketPath: yA, pipelining: SA, tls: vA, strictContentLength: G, maxCachedSessions: j, maxRedirections: T, connect: X, maxRequestsPerClient: K, localAddress: _, maxResponseSize: gA, autoSelectFamily: tA, autoSelectFamilyAttemptTimeout: hA, maxConcurrentStreams: JA, allowH2: qA } = {}) {
          if (super(), kA !== void 0)
            throw new l("unsupported keepAlive, use pipelining=0 instead");
          if (FA !== void 0)
            throw new l("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
          if (MA !== void 0)
            throw new l("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
          if ($A !== void 0)
            throw new l("unsupported idleTimeout, use keepAliveTimeout instead");
          if (iA !== void 0)
            throw new l("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
          if (IA != null && !Number.isFinite(IA))
            throw new l("invalid maxHeaderSize");
          if (yA != null && typeof yA != "string")
            throw new l("invalid socketPath");
          if (OA != null && (!Number.isFinite(OA) || OA < 0))
            throw new l("invalid connectTimeout");
          if (z != null && (!Number.isFinite(z) || z <= 0))
            throw new l("invalid keepAliveTimeout");
          if (rA != null && (!Number.isFinite(rA) || rA <= 0))
            throw new l("invalid keepAliveMaxTimeout");
          if (aA != null && !Number.isFinite(aA))
            throw new l("invalid keepAliveTimeoutThreshold");
          if (wA != null && (!Number.isInteger(wA) || wA < 0))
            throw new l("headersTimeout must be a positive integer or zero");
          if (_A != null && (!Number.isInteger(_A) || _A < 0))
            throw new l("bodyTimeout must be a positive integer or zero");
          if (X != null && typeof X != "function" && typeof X != "object")
            throw new l("connect must be a function or an object");
          if (T != null && (!Number.isInteger(T) || T < 0))
            throw new l("maxRedirections must be a positive number");
          if (K != null && (!Number.isInteger(K) || K < 0))
            throw new l("maxRequestsPerClient must be a positive number");
          if (_ != null && (typeof _ != "string" || p.isIP(_) === 0))
            throw new l("localAddress must be valid string IP address");
          if (gA != null && (!Number.isInteger(gA) || gA < -1))
            throw new l("maxResponseSize must be a positive number");
          if (hA != null && (!Number.isInteger(hA) || hA < -1))
            throw new l("autoSelectFamilyAttemptTimeout must be a positive number");
          if (qA != null && typeof qA != "boolean")
            throw new l("allowH2 must be a valid boolean value");
          if (JA != null && (typeof JA != "number" || JA < 1))
            throw new l("maxConcurrentStreams must be a positive integer, greater than 0");
          typeof X != "function" && (X = n({ ...vA, maxCachedSessions: j, allowH2: qA, socketPath: yA, timeout: OA, ...tA ? { autoSelectFamily: tA, autoSelectFamilyAttemptTimeout: hA } : void 0, ...X })), AA?.Client && Array.isArray(AA.Client) ? (this[QA] = AA.Client, CA || (CA = true, process.emitWarning("Client.Options#interceptor is deprecated. Use Dispatcher#compose instead.", { code: "UNDICI-CLIENT-INTERCEPTOR-DEPRECATED" }))) : this[QA] = [LA({ maxRedirections: T })], this[r] = E.parseOrigin(L), this[fA] = X, this[S] = SA ?? 1, this[q] = IA || c.maxHeaderSize, this[k] = z ?? 4e3, this[O] = rA ?? 6e5, this[P] = aA ?? 2e3, this[W] = this[k], this[o] = null, this[eA] = _ ?? null, this[N] = 0, this[I] = 0, this[i] = `host: ${this[r].hostname}${this[r].port ? `:${this[r].port}` : ""}\r
`, this[cA] = _A ?? 3e5, this[Z] = wA ?? 3e5, this[EA] = G ?? true, this[uA] = T, this[pA] = K, this[mA] = null, this[lA] = gA > -1 ? gA : -1, this[$2] = JA ?? 100, this[nA] = null, this[V] = [], this[m] = 0, this[F] = 0, this[sA] = (VA) => ZA(this, VA), this[YA] = (VA) => GA(this, VA);
        }
        get pipelining() {
          return this[S];
        }
        set pipelining(L) {
          this[S] = L, this[sA](true);
        }
        get [Y]() {
          return this[V].length - this[F];
        }
        get [M]() {
          return this[F] - this[m];
        }
        get [J]() {
          return this[V].length - this[m];
        }
        get [H]() {
          return !!this[nA] && !this[h] && !this[nA].destroyed;
        }
        get [g]() {
          return !!(this[nA]?.busy(null) || this[J] >= (bA(this) || 1) || this[Y] > 0);
        }
        [d](L) {
          NA(this), this.once("connect", L);
        }
        [UA](L, AA) {
          const IA = L.origin || this[r].origin, wA = new B(IA, L, AA);
          return this[V].push(wA), this[N] || (E.bodyLength(wA.body) == null && E.isIterable(wA.body) ? (this[N] = 1, queueMicrotask(() => ZA(this))) : this[sA](true)), this[N] && this[I] !== 2 && this[g] && (this[I] = 2), this[I] < 2;
        }
        async [DA]() {
          return new Promise((L) => {
            this[J] ? this[mA] = L : L(null);
          });
        }
        async [TA](L) {
          return new Promise((AA) => {
            const IA = this[V].splice(this[F]);
            for (let FA = 0; FA < IA.length; FA++) {
              const MA = IA[FA];
              E.errorRequest(this, MA, L);
            }
            const wA = e(() => {
              this[mA] && (this[mA](), this[mA] = null), AA(null);
            }, "callback");
            this[nA] ? (this[nA].destroy(L, wA), this[nA] = null) : queueMicrotask(wA), this[sA]();
          });
        }
      }
      const LA = requireRedirectInterceptor();
      function GA(oA, L) {
        if (oA[M] === 0 && L.code !== "UND_ERR_INFO" && L.code !== "UND_ERR_SOCKET") {
          A(oA[F] === oA[m]);
          const AA = oA[V].splice(oA[m]);
          for (let IA = 0; IA < AA.length; IA++) {
            const wA = AA[IA];
            E.errorRequest(oA, wA, L);
          }
          A(oA[J] === 0);
        }
      }
      e(GA, "onError");
      async function NA(oA) {
        A(!oA[h]), A(!oA[nA]);
        let { host: L, hostname: AA, protocol: IA, port: wA } = oA[r];
        if (AA[0] === "[") {
          const FA = AA.indexOf("]");
          A(FA !== -1);
          const MA = AA.substring(1, FA);
          A(p.isIP(MA)), AA = MA;
        }
        oA[h] = true, t.beforeConnect.hasSubscribers && t.beforeConnect.publish({ connectParams: { host: L, hostname: AA, protocol: IA, port: wA, version: oA[nA]?.version, servername: oA[o], localAddress: oA[eA] }, connector: oA[fA] });
        try {
          const FA = await new Promise((MA, OA) => {
            oA[fA]({ host: L, hostname: AA, protocol: IA, port: wA, servername: oA[o], localAddress: oA[eA] }, (_A, $A) => {
              _A ? OA(_A) : MA($A);
            });
          });
          if (oA.destroyed) {
            E.destroy(FA.on("error", xA), new u());
            return;
          }
          A(FA);
          try {
            oA[nA] = FA.alpnProtocol === "h2" ? await dA(oA, FA) : await BA(oA, FA);
          } catch (MA) {
            throw FA.destroy().on("error", xA), MA;
          }
          oA[h] = false, FA[RA] = 0, FA[pA] = oA[pA], FA[a] = oA, FA[D] = null, t.connected.hasSubscribers && t.connected.publish({ connectParams: { host: L, hostname: AA, protocol: IA, port: wA, version: oA[nA]?.version, servername: oA[o], localAddress: oA[eA] }, connector: oA[fA], socket: FA }), oA.emit("connect", oA[r], [oA]);
        } catch (FA) {
          if (oA.destroyed)
            return;
          if (oA[h] = false, t.connectError.hasSubscribers && t.connectError.publish({ connectParams: { host: L, hostname: AA, protocol: IA, port: wA, version: oA[nA]?.version, servername: oA[o], localAddress: oA[eA] }, connector: oA[fA], error: FA }), FA.code === "ERR_TLS_CERT_ALTNAME_INVALID")
            for (A(oA[M] === 0); oA[Y] > 0 && oA[V][oA[F]].servername === oA[o]; ) {
              const MA = oA[V][oA[F]++];
              E.errorRequest(oA, MA, FA);
            }
          else
            GA(oA, FA);
          oA.emit("connectionError", oA[r], [oA], FA);
        }
        oA[sA]();
      }
      e(NA, "connect");
      function KA(oA) {
        oA[I] = 0, oA.emit("drain", oA[r], [oA]);
      }
      e(KA, "emitDrain");
      function ZA(oA, L) {
        oA[N] !== 2 && (oA[N] = 2, PA(oA, L), oA[N] = 0, oA[m] > 256 && (oA[V].splice(0, oA[m]), oA[F] -= oA[m], oA[m] = 0));
      }
      e(ZA, "resume");
      function PA(oA, L) {
        for (; ; ) {
          if (oA.destroyed) {
            A(oA[Y] === 0);
            return;
          }
          if (oA[mA] && !oA[J]) {
            oA[mA](), oA[mA] = null;
            return;
          }
          if (oA[nA] && oA[nA].resume(), oA[g])
            oA[I] = 2;
          else if (oA[I] === 2) {
            L ? (oA[I] = 1, queueMicrotask(() => KA(oA))) : KA(oA);
            continue;
          }
          if (oA[Y] === 0 || oA[M] >= (bA(oA) || 1))
            return;
          const AA = oA[V][oA[F]];
          if (oA[r].protocol === "https:" && oA[o] !== AA.servername) {
            if (oA[M] > 0)
              return;
            oA[o] = AA.servername, oA[nA]?.destroy(new Q("servername changed"), () => {
              oA[nA] = null, ZA(oA);
            });
          }
          if (oA[h])
            return;
          if (!oA[nA]) {
            NA(oA);
            return;
          }
          if (oA[nA].destroyed || oA[nA].busy(AA))
            return;
          !AA.aborted && oA[nA].write(AA) ? oA[F]++ : oA[V].splice(oA[F], 1);
        }
      }
      return e(PA, "_resume"), client = WA, client;
    }
    e(requireClient, "requireClient");
    var fixedQueue;
    var hasRequiredFixedQueue;
    function requireFixedQueue() {
      if (hasRequiredFixedQueue)
        return fixedQueue;
      hasRequiredFixedQueue = 1;
      const A = 2048, p = A - 1;
      class c {
        static {
          e(this, "FixedCircularBuffer");
        }
        constructor() {
          this.bottom = 0, this.top = 0, this.list = new Array(A), this.next = null;
        }
        isEmpty() {
          return this.top === this.bottom;
        }
        isFull() {
          return (this.top + 1 & p) === this.bottom;
        }
        push(t) {
          this.list[this.top] = t, this.top = this.top + 1 & p;
        }
        shift() {
          const t = this.list[this.bottom];
          return t === void 0 ? null : (this.list[this.bottom] = void 0, this.bottom = this.bottom + 1 & p, t);
        }
      }
      return fixedQueue = class {
        static {
          e(this, "FixedQueue");
        }
        constructor() {
          this.head = this.tail = new c();
        }
        isEmpty() {
          return this.head.isEmpty();
        }
        push(t) {
          this.head.isFull() && (this.head = this.head.next = new c()), this.head.push(t);
        }
        shift() {
          const t = this.tail, B = t.shift();
          return t.isEmpty() && t.next !== null && (this.tail = t.next), B;
        }
      }, fixedQueue;
    }
    e(requireFixedQueue, "requireFixedQueue");
    var poolStats;
    var hasRequiredPoolStats;
    function requirePoolStats() {
      if (hasRequiredPoolStats)
        return poolStats;
      hasRequiredPoolStats = 1;
      const { kFree: A, kConnected: p, kPending: c, kQueued: E, kRunning: t, kSize: B } = requireSymbols$4(), f = Symbol("pool");
      class l {
        static {
          e(this, "PoolStats");
        }
        constructor(u) {
          this[f] = u;
        }
        get connected() {
          return this[f][p];
        }
        get free() {
          return this[f][A];
        }
        get pending() {
          return this[f][c];
        }
        get queued() {
          return this[f][E];
        }
        get running() {
          return this[f][t];
        }
        get size() {
          return this[f][B];
        }
      }
      return poolStats = l, poolStats;
    }
    e(requirePoolStats, "requirePoolStats");
    var poolBase;
    var hasRequiredPoolBase;
    function requirePoolBase() {
      if (hasRequiredPoolBase)
        return poolBase;
      hasRequiredPoolBase = 1;
      const A = requireDispatcherBase(), p = requireFixedQueue(), { kConnected: c, kSize: E, kRunning: t, kPending: B, kQueued: f, kBusy: l, kFree: Q, kUrl: u, kClose: n, kDestroy: r, kDispatch: o } = requireSymbols$4(), a = requirePoolStats(), g = Symbol("clients"), d = Symbol("needDrain"), N = Symbol("queue"), M = Symbol("closed resolve"), Y = Symbol("onDrain"), J = Symbol("onConnect"), V = Symbol("onDisconnect"), H = Symbol("onConnectionError"), h = Symbol("get dispatcher"), I = Symbol("add client"), k = Symbol("remove client"), i = Symbol("stats");
      class F extends A {
        static {
          e(this, "PoolBase");
        }
        constructor() {
          super(), this[N] = new p(), this[g] = [], this[f] = 0;
          const D = this;
          this[Y] = e(function(W, q) {
            const O = D[N];
            let P = false;
            for (; !P; ) {
              const Z = O.shift();
              if (!Z)
                break;
              D[f]--, P = !this.dispatch(Z.opts, Z.handler);
            }
            this[d] = P, !this[d] && D[d] && (D[d] = false, D.emit("drain", W, [D, ...q])), D[M] && O.isEmpty() && Promise.all(D[g].map((Z) => Z.close())).then(D[M]);
          }, "onDrain"), this[J] = (S, W) => {
            D.emit("connect", S, [D, ...W]);
          }, this[V] = (S, W, q) => {
            D.emit("disconnect", S, [D, ...W], q);
          }, this[H] = (S, W, q) => {
            D.emit("connectionError", S, [D, ...W], q);
          }, this[i] = new a(this);
        }
        get [l]() {
          return this[d];
        }
        get [c]() {
          return this[g].filter((D) => D[c]).length;
        }
        get [Q]() {
          return this[g].filter((D) => D[c] && !D[d]).length;
        }
        get [B]() {
          let D = this[f];
          for (const { [B]: S } of this[g])
            D += S;
          return D;
        }
        get [t]() {
          let D = 0;
          for (const { [t]: S } of this[g])
            D += S;
          return D;
        }
        get [E]() {
          let D = this[f];
          for (const { [E]: S } of this[g])
            D += S;
          return D;
        }
        get stats() {
          return this[i];
        }
        async [n]() {
          this[N].isEmpty() ? await Promise.all(this[g].map((D) => D.close())) : await new Promise((D) => {
            this[M] = D;
          });
        }
        async [r](D) {
          for (; ; ) {
            const S = this[N].shift();
            if (!S)
              break;
            S.handler.onError(D);
          }
          await Promise.all(this[g].map((S) => S.destroy(D)));
        }
        [o](D, S) {
          const W = this[h]();
          return W ? W.dispatch(D, S) || (W[d] = true, this[d] = !this[h]()) : (this[d] = true, this[N].push({ opts: D, handler: S }), this[f]++), !this[d];
        }
        [I](D) {
          return D.on("drain", this[Y]).on("connect", this[J]).on("disconnect", this[V]).on("connectionError", this[H]), this[g].push(D), this[d] && queueMicrotask(() => {
            this[d] && this[Y](D[u], [this, D]);
          }), this;
        }
        [k](D) {
          D.close(() => {
            const S = this[g].indexOf(D);
            S !== -1 && this[g].splice(S, 1);
          }), this[d] = this[g].some((S) => !S[d] && S.closed !== true && S.destroyed !== true);
        }
      }
      return poolBase = { PoolBase: F, kClients: g, kNeedDrain: d, kAddClient: I, kRemoveClient: k, kGetDispatcher: h }, poolBase;
    }
    e(requirePoolBase, "requirePoolBase");
    var pool;
    var hasRequiredPool;
    function requirePool() {
      if (hasRequiredPool)
        return pool;
      hasRequiredPool = 1;
      const { PoolBase: A, kClients: p, kNeedDrain: c, kAddClient: E, kGetDispatcher: t } = requirePoolBase(), B = requireClient(), { InvalidArgumentError: f } = requireErrors(), l = requireUtil$7(), { kUrl: Q, kInterceptors: u } = requireSymbols$4(), n = requireConnect(), r = Symbol("options"), o = Symbol("connections"), a = Symbol("factory");
      function g(N, M) {
        return new B(N, M);
      }
      e(g, "defaultFactory");
      class d extends A {
        static {
          e(this, "Pool");
        }
        constructor(M, { connections: Y, factory: J = g, connect: V, connectTimeout: H, tls: h, maxCachedSessions: I, socketPath: k, autoSelectFamily: i, autoSelectFamilyAttemptTimeout: F, allowH2: m, ...D } = {}) {
          if (super(), Y != null && (!Number.isFinite(Y) || Y < 0))
            throw new f("invalid connections");
          if (typeof J != "function")
            throw new f("factory must be a function.");
          if (V != null && typeof V != "function" && typeof V != "object")
            throw new f("connect must be a function or an object");
          typeof V != "function" && (V = n({ ...h, maxCachedSessions: I, allowH2: m, socketPath: k, timeout: H, ...i ? { autoSelectFamily: i, autoSelectFamilyAttemptTimeout: F } : void 0, ...V })), this[u] = D.interceptors?.Pool && Array.isArray(D.interceptors.Pool) ? D.interceptors.Pool : [], this[o] = Y || null, this[Q] = l.parseOrigin(M), this[r] = { ...l.deepClone(D), connect: V, allowH2: m }, this[r].interceptors = D.interceptors ? { ...D.interceptors } : void 0, this[a] = J;
        }
        [t]() {
          for (const M of this[p])
            if (!M[c])
              return M;
          if (!this[o] || this[p].length < this[o]) {
            const M = this[a](this[Q], this[r]);
            return this[E](M), M;
          }
        }
      }
      return pool = d, pool;
    }
    e(requirePool, "requirePool");
    var balancedPool;
    var hasRequiredBalancedPool;
    function requireBalancedPool() {
      if (hasRequiredBalancedPool)
        return balancedPool;
      hasRequiredBalancedPool = 1;
      const { BalancedPoolMissingUpstreamError: A, InvalidArgumentError: p } = requireErrors(), { PoolBase: c, kClients: E, kNeedDrain: t, kAddClient: B, kRemoveClient: f, kGetDispatcher: l } = requirePoolBase(), Q = requirePool(), { kUrl: u, kInterceptors: n } = requireSymbols$4(), { parseOrigin: r } = requireUtil$7(), o = Symbol("factory"), a = Symbol("options"), g = Symbol("kGreatestCommonDivisor"), d = Symbol("kCurrentWeight"), N = Symbol("kIndex"), M = Symbol("kWeight"), Y = Symbol("kMaxWeightPerServer"), J = Symbol("kErrorPenalty");
      function V(I, k) {
        if (I === 0)
          return k;
        for (; k !== 0; ) {
          const i = k;
          k = I % k, I = i;
        }
        return I;
      }
      e(V, "getGreatestCommonDivisor");
      function H(I, k) {
        return new Q(I, k);
      }
      e(H, "defaultFactory");
      class h extends c {
        static {
          e(this, "BalancedPool");
        }
        constructor(k = [], { factory: i = H, ...F } = {}) {
          if (super(), this[a] = F, this[N] = -1, this[d] = 0, this[Y] = this[a].maxWeightPerServer || 100, this[J] = this[a].errorPenalty || 15, Array.isArray(k) || (k = [k]), typeof i != "function")
            throw new p("factory must be a function.");
          this[n] = F.interceptors?.BalancedPool && Array.isArray(F.interceptors.BalancedPool) ? F.interceptors.BalancedPool : [], this[o] = i;
          for (const m of k)
            this.addUpstream(m);
          this._updateBalancedPoolStats();
        }
        addUpstream(k) {
          const i = r(k).origin;
          if (this[E].find((m) => m[u].origin === i && m.closed !== true && m.destroyed !== true))
            return this;
          const F = this[o](i, Object.assign({}, this[a]));
          this[B](F), F.on("connect", () => {
            F[M] = Math.min(this[Y], F[M] + this[J]);
          }), F.on("connectionError", () => {
            F[M] = Math.max(1, F[M] - this[J]), this._updateBalancedPoolStats();
          }), F.on("disconnect", (...m) => {
            const D = m[2];
            D && D.code === "UND_ERR_SOCKET" && (F[M] = Math.max(1, F[M] - this[J]), this._updateBalancedPoolStats());
          });
          for (const m of this[E])
            m[M] = this[Y];
          return this._updateBalancedPoolStats(), this;
        }
        _updateBalancedPoolStats() {
          let k = 0;
          for (let i = 0; i < this[E].length; i++)
            k = V(this[E][i][M], k);
          this[g] = k;
        }
        removeUpstream(k) {
          const i = r(k).origin, F = this[E].find((m) => m[u].origin === i && m.closed !== true && m.destroyed !== true);
          return F && this[f](F), this;
        }
        get upstreams() {
          return this[E].filter((k) => k.closed !== true && k.destroyed !== true).map((k) => k[u].origin);
        }
        [l]() {
          if (this[E].length === 0)
            throw new A();
          if (!this[E].find((D) => !D[t] && D.closed !== true && D.destroyed !== true) || this[E].map((D) => D[t]).reduce((D, S) => D && S, true))
            return;
          let F = 0, m = this[E].findIndex((D) => !D[t]);
          for (; F++ < this[E].length; ) {
            this[N] = (this[N] + 1) % this[E].length;
            const D = this[E][this[N]];
            if (D[M] > this[E][m][M] && !D[t] && (m = this[N]), this[N] === 0 && (this[d] = this[d] - this[g], this[d] <= 0 && (this[d] = this[Y])), D[M] >= this[d] && !D[t])
              return D;
          }
          return this[d] = this[E][m][M], this[N] = m, this[E][m];
        }
      }
      return balancedPool = h, balancedPool;
    }
    e(requireBalancedPool, "requireBalancedPool");
    var agent;
    var hasRequiredAgent;
    function requireAgent() {
      if (hasRequiredAgent)
        return agent;
      hasRequiredAgent = 1;
      const { InvalidArgumentError: A } = requireErrors(), { kClients: p, kRunning: c, kClose: E, kDestroy: t, kDispatch: B, kInterceptors: f } = requireSymbols$4(), l = requireDispatcherBase(), Q = requirePool(), u = requireClient(), n = requireUtil$7(), r = requireRedirectInterceptor(), o = Symbol("onConnect"), a = Symbol("onDisconnect"), g = Symbol("onConnectionError"), d = Symbol("maxRedirections"), N = Symbol("onDrain"), M = Symbol("factory"), Y = Symbol("options");
      function J(H, h) {
        return h && h.connections === 1 ? new u(H, h) : new Q(H, h);
      }
      e(J, "defaultFactory");
      class V extends l {
        static {
          e(this, "Agent");
        }
        constructor({ factory: h = J, maxRedirections: I = 0, connect: k, ...i } = {}) {
          if (super(), typeof h != "function")
            throw new A("factory must be a function.");
          if (k != null && typeof k != "function" && typeof k != "object")
            throw new A("connect must be a function or an object");
          if (!Number.isInteger(I) || I < 0)
            throw new A("maxRedirections must be a positive number");
          k && typeof k != "function" && (k = { ...k }), this[f] = i.interceptors?.Agent && Array.isArray(i.interceptors.Agent) ? i.interceptors.Agent : [r({ maxRedirections: I })], this[Y] = { ...n.deepClone(i), connect: k }, this[Y].interceptors = i.interceptors ? { ...i.interceptors } : void 0, this[d] = I, this[M] = h, this[p] = /* @__PURE__ */ new Map(), this[N] = (F, m) => {
            this.emit("drain", F, [this, ...m]);
          }, this[o] = (F, m) => {
            this.emit("connect", F, [this, ...m]);
          }, this[a] = (F, m, D) => {
            this.emit("disconnect", F, [this, ...m], D);
          }, this[g] = (F, m, D) => {
            this.emit("connectionError", F, [this, ...m], D);
          };
        }
        get [c]() {
          let h = 0;
          for (const I of this[p].values())
            h += I[c];
          return h;
        }
        [B](h, I) {
          let k;
          if (h.origin && (typeof h.origin == "string" || h.origin instanceof URL))
            k = String(h.origin);
          else
            throw new A("opts.origin must be a non-empty string or URL.");
          let i = this[p].get(k);
          return i || (i = this[M](h.origin, this[Y]).on("drain", this[N]).on("connect", this[o]).on("disconnect", this[a]).on("connectionError", this[g]), this[p].set(k, i)), i.dispatch(h, I);
        }
        async [E]() {
          const h = [];
          for (const I of this[p].values())
            h.push(I.close());
          this[p].clear(), await Promise.all(h);
        }
        async [t](h) {
          const I = [];
          for (const k of this[p].values())
            I.push(k.destroy(h));
          this[p].clear(), await Promise.all(I);
        }
      }
      return agent = V, agent;
    }
    e(requireAgent, "requireAgent");
    var proxyAgent;
    var hasRequiredProxyAgent;
    function requireProxyAgent() {
      if (hasRequiredProxyAgent)
        return proxyAgent;
      hasRequiredProxyAgent = 1;
      const { kProxy: A, kClose: p, kDestroy: c, kInterceptors: E } = requireSymbols$4(), { URL: t } = require$$1__default$1, B = requireAgent(), f = requirePool(), l = requireDispatcherBase(), { InvalidArgumentError: Q, RequestAbortedError: u, SecureProxyConnectionError: n } = requireErrors(), r = requireConnect(), o = Symbol("proxy agent"), a = Symbol("proxy client"), g = Symbol("proxy headers"), d = Symbol("request tls settings"), N = Symbol("proxy tls settings"), M = Symbol("connect endpoint function");
      function Y(k) {
        return k === "https:" ? 443 : 80;
      }
      e(Y, "defaultProtocolPort");
      function J(k, i) {
        return new f(k, i);
      }
      e(J, "defaultFactory");
      const V = e(() => {
      }, "noop");
      class H extends l {
        static {
          e(this, "ProxyAgent");
        }
        constructor(i) {
          if (super(), !i || typeof i == "object" && !(i instanceof t) && !i.uri)
            throw new Q("Proxy uri is mandatory");
          const { clientFactory: F = J } = i;
          if (typeof F != "function")
            throw new Q("Proxy opts.clientFactory must be a function.");
          const m = this.#A(i), { href: D, origin: S, port: W, protocol: q, username: O, password: P, hostname: Z } = m;
          if (this[A] = { uri: D, protocol: q }, this[E] = i.interceptors?.ProxyAgent && Array.isArray(i.interceptors.ProxyAgent) ? i.interceptors.ProxyAgent : [], this[d] = i.requestTls, this[N] = i.proxyTls, this[g] = i.headers || {}, i.auth && i.token)
            throw new Q("opts.auth cannot be used in combination with opts.token");
          i.auth ? this[g]["proxy-authorization"] = `Basic ${i.auth}` : i.token ? this[g]["proxy-authorization"] = i.token : O && P && (this[g]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(O)}:${decodeURIComponent(P)}`).toString("base64")}`);
          const cA = r({ ...i.proxyTls });
          this[M] = r({ ...i.requestTls }), this[a] = F(m, { connect: cA }), this[o] = new B({ ...i, connect: e(async (EA, fA) => {
            let uA = EA.host;
            EA.port || (uA += `:${Y(EA.protocol)}`);
            try {
              const { socket: pA, statusCode: RA } = await this[a].connect({ origin: S, port: W, path: uA, signal: EA.signal, headers: { ...this[g], host: EA.host }, servername: this[N]?.servername || Z });
              if (RA !== 200 && (pA.on("error", V).destroy(), fA(new u(`Proxy response (${RA}) !== 200 when HTTP Tunneling`))), EA.protocol !== "https:") {
                fA(null, pA);
                return;
              }
              let DA;
              this[d] ? DA = this[d].servername : DA = EA.servername, this[M]({ ...EA, servername: DA, httpSocket: pA }, fA);
            } catch (pA) {
              pA.code === "ERR_TLS_CERT_ALTNAME_INVALID" ? fA(new n(pA)) : fA(pA);
            }
          }, "connect") });
        }
        dispatch(i, F) {
          const m = h(i.headers);
          if (I(m), m && !("host" in m) && !("Host" in m)) {
            const { host: D } = new t(i.origin);
            m.host = D;
          }
          return this[o].dispatch({ ...i, headers: m }, F);
        }
        #A(i) {
          return typeof i == "string" ? new t(i) : i instanceof t ? i : new t(i.uri);
        }
        async [p]() {
          await this[o].close(), await this[a].close();
        }
        async [c]() {
          await this[o].destroy(), await this[a].destroy();
        }
      }
      function h(k) {
        if (Array.isArray(k)) {
          const i = {};
          for (let F = 0; F < k.length; F += 2)
            i[k[F]] = k[F + 1];
          return i;
        }
        return k;
      }
      e(h, "buildHeaders");
      function I(k) {
        if (k && Object.keys(k).find((F) => F.toLowerCase() === "proxy-authorization"))
          throw new Q("Proxy-Authorization should be sent in ProxyAgent constructor");
      }
      return e(I, "throwIfProxyAuthIsSent"), proxyAgent = H, proxyAgent;
    }
    e(requireProxyAgent, "requireProxyAgent");
    var envHttpProxyAgent;
    var hasRequiredEnvHttpProxyAgent;
    function requireEnvHttpProxyAgent() {
      if (hasRequiredEnvHttpProxyAgent)
        return envHttpProxyAgent;
      hasRequiredEnvHttpProxyAgent = 1;
      const A = requireDispatcherBase(), { kClose: p, kDestroy: c, kClosed: E, kDestroyed: t, kDispatch: B, kNoProxyAgent: f, kHttpProxyAgent: l, kHttpsProxyAgent: Q } = requireSymbols$4(), u = requireProxyAgent(), n = requireAgent(), r = { "http:": 80, "https:": 443 };
      let o = false;
      class a extends A {
        static {
          e(this, "EnvHttpProxyAgent");
        }
        #A = null;
        #e = null;
        #n = null;
        constructor(d = {}) {
          super(), this.#n = d, o || (o = true, process.emitWarning("EnvHttpProxyAgent is experimental, expect them to change at any time.", { code: "UNDICI-EHPA" }));
          const { httpProxy: N, httpsProxy: M, noProxy: Y, ...J } = d;
          this[f] = new n(J);
          const V = N ?? process.env.http_proxy ?? process.env.HTTP_PROXY;
          V ? this[l] = new u({ ...J, uri: V }) : this[l] = this[f];
          const H = M ?? process.env.https_proxy ?? process.env.HTTPS_PROXY;
          H ? this[Q] = new u({ ...J, uri: H }) : this[Q] = this[l], this.#s();
        }
        [B](d, N) {
          const M = new URL(d.origin);
          return this.#r(M).dispatch(d, N);
        }
        async [p]() {
          await this[f].close(), this[l][E] || await this[l].close(), this[Q][E] || await this[Q].close();
        }
        async [c](d) {
          await this[f].destroy(d), this[l][t] || await this[l].destroy(d), this[Q][t] || await this[Q].destroy(d);
        }
        #r(d) {
          let { protocol: N, host: M, port: Y } = d;
          return M = M.replace(/:\d*$/, "").toLowerCase(), Y = Number.parseInt(Y, 10) || r[N] || 0, this.#t(M, Y) ? N === "https:" ? this[Q] : this[l] : this[f];
        }
        #t(d, N) {
          if (this.#o && this.#s(), this.#e.length === 0)
            return true;
          if (this.#A === "*")
            return false;
          for (let M = 0; M < this.#e.length; M++) {
            const Y = this.#e[M];
            if (!(Y.port && Y.port !== N)) {
              if (/^[.*]/.test(Y.hostname)) {
                if (d.endsWith(Y.hostname.replace(/^\*/, "")))
                  return false;
              } else if (d === Y.hostname)
                return false;
            }
          }
          return true;
        }
        #s() {
          const d = this.#n.noProxy ?? this.#i, N = d.split(/[,\s]/), M = [];
          for (let Y = 0; Y < N.length; Y++) {
            const J = N[Y];
            if (!J)
              continue;
            const V = J.match(/^(.+):(\d+)$/);
            M.push({ hostname: (V ? V[1] : J).toLowerCase(), port: V ? Number.parseInt(V[2], 10) : 0 });
          }
          this.#A = d, this.#e = M;
        }
        get #o() {
          return this.#n.noProxy !== void 0 ? false : this.#A !== this.#i;
        }
        get #i() {
          return process.env.no_proxy ?? process.env.NO_PROXY ?? "";
        }
      }
      return envHttpProxyAgent = a, envHttpProxyAgent;
    }
    e(requireEnvHttpProxyAgent, "requireEnvHttpProxyAgent");
    var retryHandler;
    var hasRequiredRetryHandler;
    function requireRetryHandler() {
      if (hasRequiredRetryHandler)
        return retryHandler;
      hasRequiredRetryHandler = 1;
      const A = require$$0__default, { kRetryHandlerDefaultRetry: p } = requireSymbols$4(), { RequestRetryError: c } = requireErrors(), { isDisturbed: E, parseHeaders: t, parseRangeHeader: B, wrapRequestBody: f } = requireUtil$7();
      function l(u) {
        const n = Date.now();
        return new Date(u).getTime() - n;
      }
      e(l, "calculateRetryAfterHeader");
      class Q {
        static {
          e(this, "RetryHandler");
        }
        constructor(n, r) {
          const { retryOptions: o, ...a } = n, { retry: g, maxRetries: d, maxTimeout: N, minTimeout: M, timeoutFactor: Y, methods: J, errorCodes: V, retryAfter: H, statusCodes: h } = o ?? {};
          this.dispatch = r.dispatch, this.handler = r.handler, this.opts = { ...a, body: f(n.body) }, this.abort = null, this.aborted = false, this.retryOpts = { retry: g ?? Q[p], retryAfter: H ?? true, maxTimeout: N ?? 30 * 1e3, minTimeout: M ?? 500, timeoutFactor: Y ?? 2, maxRetries: d ?? 5, methods: J ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"], statusCodes: h ?? [500, 502, 503, 504, 429], errorCodes: V ?? ["ECONNRESET", "ECONNREFUSED", "ENOTFOUND", "ENETDOWN", "ENETUNREACH", "EHOSTDOWN", "EHOSTUNREACH", "EPIPE", "UND_ERR_SOCKET"] }, this.retryCount = 0, this.retryCountCheckpoint = 0, this.start = 0, this.end = null, this.etag = null, this.resume = null, this.handler.onConnect((I) => {
            this.aborted = true, this.abort ? this.abort(I) : this.reason = I;
          });
        }
        onRequestSent() {
          this.handler.onRequestSent && this.handler.onRequestSent();
        }
        onUpgrade(n, r, o) {
          this.handler.onUpgrade && this.handler.onUpgrade(n, r, o);
        }
        onConnect(n) {
          this.aborted ? n(this.reason) : this.abort = n;
        }
        onBodySent(n) {
          if (this.handler.onBodySent)
            return this.handler.onBodySent(n);
        }
        static [p](n, { state: r, opts: o }, a) {
          const { statusCode: g, code: d, headers: N } = n, { method: M, retryOptions: Y } = o, { maxRetries: J, minTimeout: V, maxTimeout: H, timeoutFactor: h, statusCodes: I, errorCodes: k, methods: i } = Y, { counter: F } = r;
          if (d && d !== "UND_ERR_REQ_RETRY" && !k.includes(d)) {
            a(n);
            return;
          }
          if (Array.isArray(i) && !i.includes(M)) {
            a(n);
            return;
          }
          if (g != null && Array.isArray(I) && !I.includes(g)) {
            a(n);
            return;
          }
          if (F > J) {
            a(n);
            return;
          }
          let m = N?.["retry-after"];
          m && (m = Number(m), m = Number.isNaN(m) ? l(m) : m * 1e3);
          const D = m > 0 ? Math.min(m, H) : Math.min(V * h ** (F - 1), H);
          setTimeout(() => a(null), D);
        }
        onHeaders(n, r, o, a) {
          const g = t(r);
          if (this.retryCount += 1, n >= 300)
            return this.retryOpts.statusCodes.includes(n) === false ? this.handler.onHeaders(n, r, o, a) : (this.abort(new c("Request failed", n, { headers: g, data: { count: this.retryCount } })), false);
          if (this.resume != null) {
            if (this.resume = null, n !== 206 && (this.start > 0 || n !== 200))
              return this.abort(new c("server does not support the range header and the payload was partially consumed", n, { headers: g, data: { count: this.retryCount } })), false;
            const N = B(g["content-range"]);
            if (!N)
              return this.abort(new c("Content-Range mismatch", n, { headers: g, data: { count: this.retryCount } })), false;
            if (this.etag != null && this.etag !== g.etag)
              return this.abort(new c("ETag mismatch", n, { headers: g, data: { count: this.retryCount } })), false;
            const { start: M, size: Y, end: J = Y - 1 } = N;
            return A(this.start === M, "content-range mismatch"), A(this.end == null || this.end === J, "content-range mismatch"), this.resume = o, true;
          }
          if (this.end == null) {
            if (n === 206) {
              const N = B(g["content-range"]);
              if (N == null)
                return this.handler.onHeaders(n, r, o, a);
              const { start: M, size: Y, end: J = Y - 1 } = N;
              A(M != null && Number.isFinite(M), "content-range mismatch"), A(J != null && Number.isFinite(J), "invalid content-length"), this.start = M, this.end = J;
            }
            if (this.end == null) {
              const N = g["content-length"];
              this.end = N != null ? Number(N) - 1 : null;
            }
            return A(Number.isFinite(this.start)), A(this.end == null || Number.isFinite(this.end), "invalid content-length"), this.resume = o, this.etag = g.etag != null ? g.etag : null, this.etag != null && this.etag.startsWith("W/") && (this.etag = null), this.handler.onHeaders(n, r, o, a);
          }
          const d = new c("Request failed", n, { headers: g, data: { count: this.retryCount } });
          return this.abort(d), false;
        }
        onData(n) {
          return this.start += n.length, this.handler.onData(n);
        }
        onComplete(n) {
          return this.retryCount = 0, this.handler.onComplete(n);
        }
        onError(n) {
          if (this.aborted || E(this.opts.body))
            return this.handler.onError(n);
          this.retryCount - this.retryCountCheckpoint > 0 ? this.retryCount = this.retryCountCheckpoint + (this.retryCount - this.retryCountCheckpoint) : this.retryCount += 1, this.retryOpts.retry(n, { state: { counter: this.retryCount }, opts: { retryOptions: this.retryOpts, ...this.opts } }, r.bind(this));
          function r(o) {
            if (o != null || this.aborted || E(this.opts.body))
              return this.handler.onError(o);
            if (this.start !== 0) {
              const a = { range: `bytes=${this.start}-${this.end ?? ""}` };
              this.etag != null && (a["if-match"] = this.etag), this.opts = { ...this.opts, headers: { ...this.opts.headers, ...a } };
            }
            try {
              this.retryCountCheckpoint = this.retryCount, this.dispatch(this.opts, this);
            } catch (a) {
              this.handler.onError(a);
            }
          }
          e(r, "onRetry");
        }
      }
      return retryHandler = Q, retryHandler;
    }
    e(requireRetryHandler, "requireRetryHandler");
    var retryAgent;
    var hasRequiredRetryAgent;
    function requireRetryAgent() {
      if (hasRequiredRetryAgent)
        return retryAgent;
      hasRequiredRetryAgent = 1;
      const A = requireDispatcher(), p = requireRetryHandler();
      class c extends A {
        static {
          e(this, "RetryAgent");
        }
        #A = null;
        #e = null;
        constructor(t, B = {}) {
          super(B), this.#A = t, this.#e = B;
        }
        dispatch(t, B) {
          const f = new p({ ...t, retryOptions: this.#e }, { dispatch: this.#A.dispatch.bind(this.#A), handler: B });
          return this.#A.dispatch(t, f);
        }
        close() {
          return this.#A.close();
        }
        destroy() {
          return this.#A.destroy();
        }
      }
      return retryAgent = c, retryAgent;
    }
    e(requireRetryAgent, "requireRetryAgent");
    var api = {};
    var apiRequest = { exports: {} };
    var readable;
    var hasRequiredReadable;
    function requireReadable() {
      if (hasRequiredReadable)
        return readable;
      hasRequiredReadable = 1;
      const A = require$$0__default, { Readable: p } = Stream__default, { RequestAbortedError: c, NotSupportedError: E, InvalidArgumentError: t, AbortError: B } = requireErrors(), f = requireUtil$7(), { ReadableStreamFrom: l } = requireUtil$7(), Q = Symbol("kConsume"), u = Symbol("kReading"), n = Symbol("kBody"), r = Symbol("kAbort"), o = Symbol("kContentType"), a = Symbol("kContentLength"), g = e(() => {
      }, "noop");
      class d extends p {
        static {
          e(this, "BodyReadable");
        }
        constructor({ resume: F, abort: m, contentType: D = "", contentLength: S, highWaterMark: W = 64 * 1024 }) {
          super({ autoDestroy: true, read: F, highWaterMark: W }), this._readableState.dataEmitted = false, this[r] = m, this[Q] = null, this[n] = null, this[o] = D, this[a] = S, this[u] = false;
        }
        destroy(F) {
          return !F && !this._readableState.endEmitted && (F = new c()), F && this[r](), super.destroy(F);
        }
        _destroy(F, m) {
          this[u] ? m(F) : setImmediate(() => {
            m(F);
          });
        }
        on(F, ...m) {
          return (F === "data" || F === "readable") && (this[u] = true), super.on(F, ...m);
        }
        addListener(F, ...m) {
          return this.on(F, ...m);
        }
        off(F, ...m) {
          const D = super.off(F, ...m);
          return (F === "data" || F === "readable") && (this[u] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0), D;
        }
        removeListener(F, ...m) {
          return this.off(F, ...m);
        }
        push(F) {
          return this[Q] && F !== null ? (I(this[Q], F), this[u] ? super.push(F) : true) : super.push(F);
        }
        async text() {
          return Y(this, "text");
        }
        async json() {
          return Y(this, "json");
        }
        async blob() {
          return Y(this, "blob");
        }
        async bytes() {
          return Y(this, "bytes");
        }
        async arrayBuffer() {
          return Y(this, "arrayBuffer");
        }
        async formData() {
          throw new E();
        }
        get bodyUsed() {
          return f.isDisturbed(this);
        }
        get body() {
          return this[n] || (this[n] = l(this), this[Q] && (this[n].getReader(), A(this[n].locked))), this[n];
        }
        async dump(F) {
          let m = Number.isFinite(F?.limit) ? F.limit : 131072;
          const D = F?.signal;
          if (D != null && (typeof D != "object" || !("aborted" in D)))
            throw new t("signal must be an AbortSignal");
          return D?.throwIfAborted(), this._readableState.closeEmitted ? null : await new Promise((S, W) => {
            this[a] > m && this.destroy(new B());
            const q = e(() => {
              this.destroy(D.reason ?? new B());
            }, "onAbort");
            D?.addEventListener("abort", q), this.on("close", function() {
              D?.removeEventListener("abort", q), D?.aborted ? W(D.reason ?? new B()) : S(null);
            }).on("error", g).on("data", function(O) {
              m -= O.length, m <= 0 && this.destroy();
            }).resume();
          });
        }
      }
      function N(i) {
        return i[n] && i[n].locked === true || i[Q];
      }
      e(N, "isLocked");
      function M(i) {
        return f.isDisturbed(i) || N(i);
      }
      e(M, "isUnusable");
      async function Y(i, F) {
        return A(!i[Q]), new Promise((m, D) => {
          if (M(i)) {
            const S = i._readableState;
            S.destroyed && S.closeEmitted === false ? i.on("error", (W) => {
              D(W);
            }).on("close", () => {
              D(new TypeError("unusable"));
            }) : D(S.errored ?? new TypeError("unusable"));
          } else
            queueMicrotask(() => {
              i[Q] = { type: F, stream: i, resolve: m, reject: D, length: 0, body: [] }, i.on("error", function(S) {
                k(this[Q], S);
              }).on("close", function() {
                this[Q].body !== null && k(this[Q], new c());
              }), J(i[Q]);
            });
        });
      }
      e(Y, "consume");
      function J(i) {
        if (i.body === null)
          return;
        const { _readableState: F } = i.stream;
        if (F.bufferIndex) {
          const m = F.bufferIndex, D = F.buffer.length;
          for (let S = m; S < D; S++)
            I(i, F.buffer[S]);
        } else
          for (const m of F.buffer)
            I(i, m);
        for (F.endEmitted ? h(this[Q]) : i.stream.on("end", function() {
          h(this[Q]);
        }), i.stream.resume(); i.stream.read() != null; )
          ;
      }
      e(J, "consumeStart");
      function V(i, F) {
        if (i.length === 0 || F === 0)
          return "";
        const m = i.length === 1 ? i[0] : Buffer.concat(i, F), D = m.length, S = D > 2 && m[0] === 239 && m[1] === 187 && m[2] === 191 ? 3 : 0;
        return m.utf8Slice(S, D);
      }
      e(V, "chunksDecode");
      function H(i, F) {
        if (i.length === 0 || F === 0)
          return new Uint8Array(0);
        if (i.length === 1)
          return new Uint8Array(i[0]);
        const m = new Uint8Array(Buffer.allocUnsafeSlow(F).buffer);
        let D = 0;
        for (let S = 0; S < i.length; ++S) {
          const W = i[S];
          m.set(W, D), D += W.length;
        }
        return m;
      }
      e(H, "chunksConcat");
      function h(i) {
        const { type: F, body: m, resolve: D, stream: S, length: W } = i;
        try {
          F === "text" ? D(V(m, W)) : F === "json" ? D(JSON.parse(V(m, W))) : F === "arrayBuffer" ? D(H(m, W).buffer) : F === "blob" ? D(new Blob(m, { type: S[o] })) : F === "bytes" && D(H(m, W)), k(i);
        } catch (q) {
          S.destroy(q);
        }
      }
      e(h, "consumeEnd");
      function I(i, F) {
        i.length += F.length, i.body.push(F);
      }
      e(I, "consumePush");
      function k(i, F) {
        i.body !== null && (F ? i.reject(F) : i.resolve(), i.type = null, i.stream = null, i.resolve = null, i.reject = null, i.length = 0, i.body = null);
      }
      return e(k, "consumeFinish"), readable = { Readable: d, chunksDecode: V }, readable;
    }
    e(requireReadable, "requireReadable");
    var util$5;
    var hasRequiredUtil$5;
    function requireUtil$5() {
      if (hasRequiredUtil$5)
        return util$5;
      hasRequiredUtil$5 = 1;
      const A = require$$0__default, { ResponseStatusCodeError: p } = requireErrors(), { chunksDecode: c } = requireReadable(), E = 128 * 1024;
      async function t({ callback: l, body: Q, contentType: u, statusCode: n, statusMessage: r, headers: o }) {
        A(Q);
        let a = [], g = 0;
        try {
          for await (const Y of Q)
            if (a.push(Y), g += Y.length, g > E) {
              a = [], g = 0;
              break;
            }
        } catch {
          a = [], g = 0;
        }
        const d = `Response status code ${n}${r ? `: ${r}` : ""}`;
        if (n === 204 || !u || !g) {
          queueMicrotask(() => l(new p(d, n, o)));
          return;
        }
        const N = Error.stackTraceLimit;
        Error.stackTraceLimit = 0;
        let M;
        try {
          B(u) ? M = JSON.parse(c(a, g)) : f(u) && (M = c(a, g));
        } catch {
        } finally {
          Error.stackTraceLimit = N;
        }
        queueMicrotask(() => l(new p(d, n, o, M)));
      }
      e(t, "getResolveErrorBodyCallback");
      const B = e((l) => l.length > 15 && l[11] === "/" && l[0] === "a" && l[1] === "p" && l[2] === "p" && l[3] === "l" && l[4] === "i" && l[5] === "c" && l[6] === "a" && l[7] === "t" && l[8] === "i" && l[9] === "o" && l[10] === "n" && l[12] === "j" && l[13] === "s" && l[14] === "o" && l[15] === "n", "isContentTypeApplicationJson"), f = e((l) => l.length > 4 && l[4] === "/" && l[0] === "t" && l[1] === "e" && l[2] === "x" && l[3] === "t", "isContentTypeText");
      return util$5 = { getResolveErrorBodyCallback: t, isContentTypeApplicationJson: B, isContentTypeText: f }, util$5;
    }
    e(requireUtil$5, "requireUtil$5");
    var hasRequiredApiRequest;
    function requireApiRequest() {
      if (hasRequiredApiRequest)
        return apiRequest.exports;
      hasRequiredApiRequest = 1;
      const A = require$$0__default, { Readable: p } = requireReadable(), { InvalidArgumentError: c, RequestAbortedError: E } = requireErrors(), t = requireUtil$7(), { getResolveErrorBodyCallback: B } = requireUtil$5(), { AsyncResource: f } = require$$5__default$2;
      class l extends f {
        static {
          e(this, "RequestHandler");
        }
        constructor(n, r) {
          if (!n || typeof n != "object")
            throw new c("invalid opts");
          const { signal: o, method: a, opaque: g, body: d, onInfo: N, responseHeaders: M, throwOnError: Y, highWaterMark: J } = n;
          try {
            if (typeof r != "function")
              throw new c("invalid callback");
            if (J && (typeof J != "number" || J < 0))
              throw new c("invalid highWaterMark");
            if (o && typeof o.on != "function" && typeof o.addEventListener != "function")
              throw new c("signal must be an EventEmitter or EventTarget");
            if (a === "CONNECT")
              throw new c("invalid method");
            if (N && typeof N != "function")
              throw new c("invalid onInfo callback");
            super("UNDICI_REQUEST");
          } catch (V) {
            throw t.isStream(d) && t.destroy(d.on("error", t.nop), V), V;
          }
          this.method = a, this.responseHeaders = M || null, this.opaque = g || null, this.callback = r, this.res = null, this.abort = null, this.body = d, this.trailers = {}, this.context = null, this.onInfo = N || null, this.throwOnError = Y, this.highWaterMark = J, this.signal = o, this.reason = null, this.removeAbortListener = null, t.isStream(d) && d.on("error", (V) => {
            this.onError(V);
          }), this.signal && (this.signal.aborted ? this.reason = this.signal.reason ?? new E() : this.removeAbortListener = t.addAbortListener(this.signal, () => {
            this.reason = this.signal.reason ?? new E(), this.res ? t.destroy(this.res.on("error", t.nop), this.reason) : this.abort && this.abort(this.reason), this.removeAbortListener && (this.res?.off("close", this.removeAbortListener), this.removeAbortListener(), this.removeAbortListener = null);
          }));
        }
        onConnect(n, r) {
          if (this.reason) {
            n(this.reason);
            return;
          }
          A(this.callback), this.abort = n, this.context = r;
        }
        onHeaders(n, r, o, a) {
          const { callback: g, opaque: d, abort: N, context: M, responseHeaders: Y, highWaterMark: J } = this, V = Y === "raw" ? t.parseRawHeaders(r) : t.parseHeaders(r);
          if (n < 200) {
            this.onInfo && this.onInfo({ statusCode: n, headers: V });
            return;
          }
          const H = Y === "raw" ? t.parseHeaders(r) : V, h = H["content-type"], I = H["content-length"], k = new p({ resume: o, abort: N, contentType: h, contentLength: this.method !== "HEAD" && I ? Number(I) : null, highWaterMark: J });
          this.removeAbortListener && k.on("close", this.removeAbortListener), this.callback = null, this.res = k, g !== null && (this.throwOnError && n >= 400 ? this.runInAsyncScope(B, null, { callback: g, body: k, contentType: h, statusCode: n, statusMessage: a, headers: V }) : this.runInAsyncScope(g, null, null, { statusCode: n, headers: V, trailers: this.trailers, opaque: d, body: k, context: M }));
        }
        onData(n) {
          return this.res.push(n);
        }
        onComplete(n) {
          t.parseHeaders(n, this.trailers), this.res.push(null);
        }
        onError(n) {
          const { res: r, callback: o, body: a, opaque: g } = this;
          o && (this.callback = null, queueMicrotask(() => {
            this.runInAsyncScope(o, null, n, { opaque: g });
          })), r && (this.res = null, queueMicrotask(() => {
            t.destroy(r, n);
          })), a && (this.body = null, t.destroy(a, n)), this.removeAbortListener && (r?.off("close", this.removeAbortListener), this.removeAbortListener(), this.removeAbortListener = null);
        }
      }
      function Q(u, n) {
        if (n === void 0)
          return new Promise((r, o) => {
            Q.call(this, u, (a, g) => a ? o(a) : r(g));
          });
        try {
          this.dispatch(u, new l(u, n));
        } catch (r) {
          if (typeof n != "function")
            throw r;
          const o = u?.opaque;
          queueMicrotask(() => n(r, { opaque: o }));
        }
      }
      return e(Q, "request"), apiRequest.exports = Q, apiRequest.exports.RequestHandler = l, apiRequest.exports;
    }
    e(requireApiRequest, "requireApiRequest");
    var abortSignal;
    var hasRequiredAbortSignal;
    function requireAbortSignal() {
      if (hasRequiredAbortSignal)
        return abortSignal;
      hasRequiredAbortSignal = 1;
      const { addAbortListener: A } = requireUtil$7(), { RequestAbortedError: p } = requireErrors(), c = Symbol("kListener"), E = Symbol("kSignal");
      function t(l) {
        l.abort ? l.abort(l[E]?.reason) : l.reason = l[E]?.reason ?? new p(), f(l);
      }
      e(t, "abort");
      function B(l, Q) {
        if (l.reason = null, l[E] = null, l[c] = null, !!Q) {
          if (Q.aborted) {
            t(l);
            return;
          }
          l[E] = Q, l[c] = () => {
            t(l);
          }, A(l[E], l[c]);
        }
      }
      e(B, "addSignal");
      function f(l) {
        l[E] && ("removeEventListener" in l[E] ? l[E].removeEventListener("abort", l[c]) : l[E].removeListener("abort", l[c]), l[E] = null, l[c] = null);
      }
      return e(f, "removeSignal"), abortSignal = { addSignal: B, removeSignal: f }, abortSignal;
    }
    e(requireAbortSignal, "requireAbortSignal");
    var apiStream;
    var hasRequiredApiStream;
    function requireApiStream() {
      if (hasRequiredApiStream)
        return apiStream;
      hasRequiredApiStream = 1;
      const A = require$$0__default, { finished: p, PassThrough: c } = Stream__default, { InvalidArgumentError: E, InvalidReturnValueError: t } = requireErrors(), B = requireUtil$7(), { getResolveErrorBodyCallback: f } = requireUtil$5(), { AsyncResource: l } = require$$5__default$2, { addSignal: Q, removeSignal: u } = requireAbortSignal();
      class n extends l {
        static {
          e(this, "StreamHandler");
        }
        constructor(a, g, d) {
          if (!a || typeof a != "object")
            throw new E("invalid opts");
          const { signal: N, method: M, opaque: Y, body: J, onInfo: V, responseHeaders: H, throwOnError: h } = a;
          try {
            if (typeof d != "function")
              throw new E("invalid callback");
            if (typeof g != "function")
              throw new E("invalid factory");
            if (N && typeof N.on != "function" && typeof N.addEventListener != "function")
              throw new E("signal must be an EventEmitter or EventTarget");
            if (M === "CONNECT")
              throw new E("invalid method");
            if (V && typeof V != "function")
              throw new E("invalid onInfo callback");
            super("UNDICI_STREAM");
          } catch (I) {
            throw B.isStream(J) && B.destroy(J.on("error", B.nop), I), I;
          }
          this.responseHeaders = H || null, this.opaque = Y || null, this.factory = g, this.callback = d, this.res = null, this.abort = null, this.context = null, this.trailers = null, this.body = J, this.onInfo = V || null, this.throwOnError = h || false, B.isStream(J) && J.on("error", (I) => {
            this.onError(I);
          }), Q(this, N);
        }
        onConnect(a, g) {
          if (this.reason) {
            a(this.reason);
            return;
          }
          A(this.callback), this.abort = a, this.context = g;
        }
        onHeaders(a, g, d, N) {
          const { factory: M, opaque: Y, context: J, callback: V, responseHeaders: H } = this, h = H === "raw" ? B.parseRawHeaders(g) : B.parseHeaders(g);
          if (a < 200) {
            this.onInfo && this.onInfo({ statusCode: a, headers: h });
            return;
          }
          this.factory = null;
          let I;
          if (this.throwOnError && a >= 400) {
            const F = (H === "raw" ? B.parseHeaders(g) : h)["content-type"];
            I = new c(), this.callback = null, this.runInAsyncScope(f, null, { callback: V, body: I, contentType: F, statusCode: a, statusMessage: N, headers: h });
          } else {
            if (M === null)
              return;
            if (I = this.runInAsyncScope(M, null, { statusCode: a, headers: h, opaque: Y, context: J }), !I || typeof I.write != "function" || typeof I.end != "function" || typeof I.on != "function")
              throw new t("expected Writable");
            p(I, { readable: false }, (i) => {
              const { callback: F, res: m, opaque: D, trailers: S, abort: W } = this;
              this.res = null, (i || !m.readable) && B.destroy(m, i), this.callback = null, this.runInAsyncScope(F, null, i || null, { opaque: D, trailers: S }), i && W();
            });
          }
          return I.on("drain", d), this.res = I, (I.writableNeedDrain !== void 0 ? I.writableNeedDrain : I._writableState?.needDrain) !== true;
        }
        onData(a) {
          const { res: g } = this;
          return g ? g.write(a) : true;
        }
        onComplete(a) {
          const { res: g } = this;
          u(this), g && (this.trailers = B.parseHeaders(a), g.end());
        }
        onError(a) {
          const { res: g, callback: d, opaque: N, body: M } = this;
          u(this), this.factory = null, g ? (this.res = null, B.destroy(g, a)) : d && (this.callback = null, queueMicrotask(() => {
            this.runInAsyncScope(d, null, a, { opaque: N });
          })), M && (this.body = null, B.destroy(M, a));
        }
      }
      function r(o, a, g) {
        if (g === void 0)
          return new Promise((d, N) => {
            r.call(this, o, a, (M, Y) => M ? N(M) : d(Y));
          });
        try {
          this.dispatch(o, new n(o, a, g));
        } catch (d) {
          if (typeof g != "function")
            throw d;
          const N = o?.opaque;
          queueMicrotask(() => g(d, { opaque: N }));
        }
      }
      return e(r, "stream"), apiStream = r, apiStream;
    }
    e(requireApiStream, "requireApiStream");
    var apiPipeline;
    var hasRequiredApiPipeline;
    function requireApiPipeline() {
      if (hasRequiredApiPipeline)
        return apiPipeline;
      hasRequiredApiPipeline = 1;
      const { Readable: A, Duplex: p, PassThrough: c } = Stream__default, { InvalidArgumentError: E, InvalidReturnValueError: t, RequestAbortedError: B } = requireErrors(), f = requireUtil$7(), { AsyncResource: l } = require$$5__default$2, { addSignal: Q, removeSignal: u } = requireAbortSignal(), n = require$$0__default, r = Symbol("resume");
      class o extends A {
        static {
          e(this, "PipelineRequest");
        }
        constructor() {
          super({ autoDestroy: true }), this[r] = null;
        }
        _read() {
          const { [r]: M } = this;
          M && (this[r] = null, M());
        }
        _destroy(M, Y) {
          this._read(), Y(M);
        }
      }
      class a extends A {
        static {
          e(this, "PipelineResponse");
        }
        constructor(M) {
          super({ autoDestroy: true }), this[r] = M;
        }
        _read() {
          this[r]();
        }
        _destroy(M, Y) {
          !M && !this._readableState.endEmitted && (M = new B()), Y(M);
        }
      }
      class g extends l {
        static {
          e(this, "PipelineHandler");
        }
        constructor(M, Y) {
          if (!M || typeof M != "object")
            throw new E("invalid opts");
          if (typeof Y != "function")
            throw new E("invalid handler");
          const { signal: J, method: V, opaque: H, onInfo: h, responseHeaders: I } = M;
          if (J && typeof J.on != "function" && typeof J.addEventListener != "function")
            throw new E("signal must be an EventEmitter or EventTarget");
          if (V === "CONNECT")
            throw new E("invalid method");
          if (h && typeof h != "function")
            throw new E("invalid onInfo callback");
          super("UNDICI_PIPELINE"), this.opaque = H || null, this.responseHeaders = I || null, this.handler = Y, this.abort = null, this.context = null, this.onInfo = h || null, this.req = new o().on("error", f.nop), this.ret = new p({ readableObjectMode: M.objectMode, autoDestroy: true, read: e(() => {
            const { body: k } = this;
            k?.resume && k.resume();
          }, "read"), write: e((k, i, F) => {
            const { req: m } = this;
            m.push(k, i) || m._readableState.destroyed ? F() : m[r] = F;
          }, "write"), destroy: e((k, i) => {
            const { body: F, req: m, res: D, ret: S, abort: W } = this;
            !k && !S._readableState.endEmitted && (k = new B()), W && k && W(), f.destroy(F, k), f.destroy(m, k), f.destroy(D, k), u(this), i(k);
          }, "destroy") }).on("prefinish", () => {
            const { req: k } = this;
            k.push(null);
          }), this.res = null, Q(this, J);
        }
        onConnect(M, Y) {
          const { ret: J, res: V } = this;
          if (this.reason) {
            M(this.reason);
            return;
          }
          n(!V, "pipeline cannot be retried"), n(!J.destroyed), this.abort = M, this.context = Y;
        }
        onHeaders(M, Y, J) {
          const { opaque: V, handler: H, context: h } = this;
          if (M < 200) {
            if (this.onInfo) {
              const k = this.responseHeaders === "raw" ? f.parseRawHeaders(Y) : f.parseHeaders(Y);
              this.onInfo({ statusCode: M, headers: k });
            }
            return;
          }
          this.res = new a(J);
          let I;
          try {
            this.handler = null;
            const k = this.responseHeaders === "raw" ? f.parseRawHeaders(Y) : f.parseHeaders(Y);
            I = this.runInAsyncScope(H, null, { statusCode: M, headers: k, opaque: V, body: this.res, context: h });
          } catch (k) {
            throw this.res.on("error", f.nop), k;
          }
          if (!I || typeof I.on != "function")
            throw new t("expected Readable");
          I.on("data", (k) => {
            const { ret: i, body: F } = this;
            !i.push(k) && F.pause && F.pause();
          }).on("error", (k) => {
            const { ret: i } = this;
            f.destroy(i, k);
          }).on("end", () => {
            const { ret: k } = this;
            k.push(null);
          }).on("close", () => {
            const { ret: k } = this;
            k._readableState.ended || f.destroy(k, new B());
          }), this.body = I;
        }
        onData(M) {
          const { res: Y } = this;
          return Y.push(M);
        }
        onComplete(M) {
          const { res: Y } = this;
          Y.push(null);
        }
        onError(M) {
          const { ret: Y } = this;
          this.handler = null, f.destroy(Y, M);
        }
      }
      function d(N, M) {
        try {
          const Y = new g(N, M);
          return this.dispatch({ ...N, body: Y.req }, Y), Y.ret;
        } catch (Y) {
          return new c().destroy(Y);
        }
      }
      return e(d, "pipeline"), apiPipeline = d, apiPipeline;
    }
    e(requireApiPipeline, "requireApiPipeline");
    var apiUpgrade;
    var hasRequiredApiUpgrade;
    function requireApiUpgrade() {
      if (hasRequiredApiUpgrade)
        return apiUpgrade;
      hasRequiredApiUpgrade = 1;
      const { InvalidArgumentError: A, SocketError: p } = requireErrors(), { AsyncResource: c } = require$$5__default$2, E = requireUtil$7(), { addSignal: t, removeSignal: B } = requireAbortSignal(), f = require$$0__default;
      class l extends c {
        static {
          e(this, "UpgradeHandler");
        }
        constructor(n, r) {
          if (!n || typeof n != "object")
            throw new A("invalid opts");
          if (typeof r != "function")
            throw new A("invalid callback");
          const { signal: o, opaque: a, responseHeaders: g } = n;
          if (o && typeof o.on != "function" && typeof o.addEventListener != "function")
            throw new A("signal must be an EventEmitter or EventTarget");
          super("UNDICI_UPGRADE"), this.responseHeaders = g || null, this.opaque = a || null, this.callback = r, this.abort = null, this.context = null, t(this, o);
        }
        onConnect(n, r) {
          if (this.reason) {
            n(this.reason);
            return;
          }
          f(this.callback), this.abort = n, this.context = null;
        }
        onHeaders() {
          throw new p("bad upgrade", null);
        }
        onUpgrade(n, r, o) {
          f(n === 101);
          const { callback: a, opaque: g, context: d } = this;
          B(this), this.callback = null;
          const N = this.responseHeaders === "raw" ? E.parseRawHeaders(r) : E.parseHeaders(r);
          this.runInAsyncScope(a, null, null, { headers: N, socket: o, opaque: g, context: d });
        }
        onError(n) {
          const { callback: r, opaque: o } = this;
          B(this), r && (this.callback = null, queueMicrotask(() => {
            this.runInAsyncScope(r, null, n, { opaque: o });
          }));
        }
      }
      function Q(u, n) {
        if (n === void 0)
          return new Promise((r, o) => {
            Q.call(this, u, (a, g) => a ? o(a) : r(g));
          });
        try {
          const r = new l(u, n);
          this.dispatch({ ...u, method: u.method || "GET", upgrade: u.protocol || "Websocket" }, r);
        } catch (r) {
          if (typeof n != "function")
            throw r;
          const o = u?.opaque;
          queueMicrotask(() => n(r, { opaque: o }));
        }
      }
      return e(Q, "upgrade"), apiUpgrade = Q, apiUpgrade;
    }
    e(requireApiUpgrade, "requireApiUpgrade");
    var apiConnect;
    var hasRequiredApiConnect;
    function requireApiConnect() {
      if (hasRequiredApiConnect)
        return apiConnect;
      hasRequiredApiConnect = 1;
      const A = require$$0__default, { AsyncResource: p } = require$$5__default$2, { InvalidArgumentError: c, SocketError: E } = requireErrors(), t = requireUtil$7(), { addSignal: B, removeSignal: f } = requireAbortSignal();
      class l extends p {
        static {
          e(this, "ConnectHandler");
        }
        constructor(n, r) {
          if (!n || typeof n != "object")
            throw new c("invalid opts");
          if (typeof r != "function")
            throw new c("invalid callback");
          const { signal: o, opaque: a, responseHeaders: g } = n;
          if (o && typeof o.on != "function" && typeof o.addEventListener != "function")
            throw new c("signal must be an EventEmitter or EventTarget");
          super("UNDICI_CONNECT"), this.opaque = a || null, this.responseHeaders = g || null, this.callback = r, this.abort = null, B(this, o);
        }
        onConnect(n, r) {
          if (this.reason) {
            n(this.reason);
            return;
          }
          A(this.callback), this.abort = n, this.context = r;
        }
        onHeaders() {
          throw new E("bad connect", null);
        }
        onUpgrade(n, r, o) {
          const { callback: a, opaque: g, context: d } = this;
          f(this), this.callback = null;
          let N = r;
          N != null && (N = this.responseHeaders === "raw" ? t.parseRawHeaders(r) : t.parseHeaders(r)), this.runInAsyncScope(a, null, null, { statusCode: n, headers: N, socket: o, opaque: g, context: d });
        }
        onError(n) {
          const { callback: r, opaque: o } = this;
          f(this), r && (this.callback = null, queueMicrotask(() => {
            this.runInAsyncScope(r, null, n, { opaque: o });
          }));
        }
      }
      function Q(u, n) {
        if (n === void 0)
          return new Promise((r, o) => {
            Q.call(this, u, (a, g) => a ? o(a) : r(g));
          });
        try {
          const r = new l(u, n);
          this.dispatch({ ...u, method: "CONNECT" }, r);
        } catch (r) {
          if (typeof n != "function")
            throw r;
          const o = u?.opaque;
          queueMicrotask(() => n(r, { opaque: o }));
        }
      }
      return e(Q, "connect"), apiConnect = Q, apiConnect;
    }
    e(requireApiConnect, "requireApiConnect");
    var hasRequiredApi;
    function requireApi() {
      return hasRequiredApi || (hasRequiredApi = 1, api.request = requireApiRequest(), api.stream = requireApiStream(), api.pipeline = requireApiPipeline(), api.upgrade = requireApiUpgrade(), api.connect = requireApiConnect()), api;
    }
    e(requireApi, "requireApi");
    var mockErrors;
    var hasRequiredMockErrors;
    function requireMockErrors() {
      if (hasRequiredMockErrors)
        return mockErrors;
      hasRequiredMockErrors = 1;
      const { UndiciError: A } = requireErrors();
      class p extends A {
        static {
          e(this, "MockNotMatchedError");
        }
        constructor(E) {
          super(E), Error.captureStackTrace(this, p), this.name = "MockNotMatchedError", this.message = E || "The request does not match any registered mock dispatches", this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
        }
      }
      return mockErrors = { MockNotMatchedError: p }, mockErrors;
    }
    e(requireMockErrors, "requireMockErrors");
    var mockSymbols;
    var hasRequiredMockSymbols;
    function requireMockSymbols() {
      return hasRequiredMockSymbols || (hasRequiredMockSymbols = 1, mockSymbols = { kAgent: Symbol("agent"), kOptions: Symbol("options"), kFactory: Symbol("factory"), kDispatches: Symbol("dispatches"), kDispatchKey: Symbol("dispatch key"), kDefaultHeaders: Symbol("default headers"), kDefaultTrailers: Symbol("default trailers"), kContentLength: Symbol("content length"), kMockAgent: Symbol("mock agent"), kMockAgentSet: Symbol("mock agent set"), kMockAgentGet: Symbol("mock agent get"), kMockDispatch: Symbol("mock dispatch"), kClose: Symbol("close"), kOriginalClose: Symbol("original agent close"), kOrigin: Symbol("origin"), kIsMockActive: Symbol("is mock active"), kNetConnect: Symbol("net connect"), kGetNetConnect: Symbol("get net connect"), kConnected: Symbol("connected") }), mockSymbols;
    }
    e(requireMockSymbols, "requireMockSymbols");
    var mockUtils;
    var hasRequiredMockUtils;
    function requireMockUtils() {
      if (hasRequiredMockUtils)
        return mockUtils;
      hasRequiredMockUtils = 1;
      const { MockNotMatchedError: A } = requireMockErrors(), { kDispatches: p, kMockAgent: c, kOriginalDispatch: E, kOrigin: t, kGetNetConnect: B } = requireMockSymbols(), { buildURL: f } = requireUtil$7(), { STATUS_CODES: l } = http__default, { types: { isPromise: Q } } = require$$0__default$3;
      function u(D, S) {
        return typeof D == "string" ? D === S : D instanceof RegExp ? D.test(S) : typeof D == "function" ? D(S) === true : false;
      }
      e(u, "matchValue");
      function n(D) {
        return Object.fromEntries(Object.entries(D).map(([S, W]) => [S.toLocaleLowerCase(), W]));
      }
      e(n, "lowerCaseEntries");
      function r(D, S) {
        if (Array.isArray(D)) {
          for (let W = 0; W < D.length; W += 2)
            if (D[W].toLocaleLowerCase() === S.toLocaleLowerCase())
              return D[W + 1];
          return;
        } else
          return typeof D.get == "function" ? D.get(S) : n(D)[S.toLocaleLowerCase()];
      }
      e(r, "getHeaderByName");
      function o(D) {
        const S = D.slice(), W = [];
        for (let q = 0; q < S.length; q += 2)
          W.push([S[q], S[q + 1]]);
        return Object.fromEntries(W);
      }
      e(o, "buildHeadersFromArray");
      function a(D, S) {
        if (typeof D.headers == "function")
          return Array.isArray(S) && (S = o(S)), D.headers(S ? n(S) : {});
        if (typeof D.headers > "u")
          return true;
        if (typeof S != "object" || typeof D.headers != "object")
          return false;
        for (const [W, q] of Object.entries(D.headers)) {
          const O = r(S, W);
          if (!u(q, O))
            return false;
        }
        return true;
      }
      e(a, "matchHeaders");
      function g(D) {
        if (typeof D != "string")
          return D;
        const S = D.split("?");
        if (S.length !== 2)
          return D;
        const W = new URLSearchParams(S.pop());
        return W.sort(), [...S, W.toString()].join("?");
      }
      e(g, "safeUrl");
      function d(D, { path: S, method: W, body: q, headers: O }) {
        const P = u(D.path, S), Z = u(D.method, W), cA = typeof D.body < "u" ? u(D.body, q) : true, EA = a(D, O);
        return P && Z && cA && EA;
      }
      e(d, "matchKey");
      function N(D) {
        return Buffer.isBuffer(D) || D instanceof Uint8Array || D instanceof ArrayBuffer ? D : typeof D == "object" ? JSON.stringify(D) : D.toString();
      }
      e(N, "getResponseData");
      function M(D, S) {
        const W = S.query ? f(S.path, S.query) : S.path, q = typeof W == "string" ? g(W) : W;
        let O = D.filter(({ consumed: P }) => !P).filter(({ path: P }) => u(g(P), q));
        if (O.length === 0)
          throw new A(`Mock dispatch not matched for path '${q}'`);
        if (O = O.filter(({ method: P }) => u(P, S.method)), O.length === 0)
          throw new A(`Mock dispatch not matched for method '${S.method}' on path '${q}'`);
        if (O = O.filter(({ body: P }) => typeof P < "u" ? u(P, S.body) : true), O.length === 0)
          throw new A(`Mock dispatch not matched for body '${S.body}' on path '${q}'`);
        if (O = O.filter((P) => a(P, S.headers)), O.length === 0) {
          const P = typeof S.headers == "object" ? JSON.stringify(S.headers) : S.headers;
          throw new A(`Mock dispatch not matched for headers '${P}' on path '${q}'`);
        }
        return O[0];
      }
      e(M, "getMockDispatch");
      function Y(D, S, W) {
        const q = { timesInvoked: 0, times: 1, persist: false, consumed: false }, O = typeof W == "function" ? { callback: W } : { ...W }, P = { ...q, ...S, pending: true, data: { error: null, ...O } };
        return D.push(P), P;
      }
      e(Y, "addMockDispatch");
      function J(D, S) {
        const W = D.findIndex((q) => q.consumed ? d(q, S) : false);
        W !== -1 && D.splice(W, 1);
      }
      e(J, "deleteMockDispatch");
      function V(D) {
        const { path: S, method: W, body: q, headers: O, query: P } = D;
        return { path: S, method: W, body: q, headers: O, query: P };
      }
      e(V, "buildKey");
      function H(D) {
        const S = Object.keys(D), W = [];
        for (let q = 0; q < S.length; ++q) {
          const O = S[q], P = D[O], Z = Buffer.from(`${O}`);
          if (Array.isArray(P))
            for (let cA = 0; cA < P.length; ++cA)
              W.push(Z, Buffer.from(`${P[cA]}`));
          else
            W.push(Z, Buffer.from(`${P}`));
        }
        return W;
      }
      e(H, "generateKeyValues");
      function h(D) {
        return l[D] || "unknown";
      }
      e(h, "getStatusText");
      async function I(D) {
        const S = [];
        for await (const W of D)
          S.push(W);
        return Buffer.concat(S).toString("utf8");
      }
      e(I, "getResponse");
      function k(D, S) {
        const W = V(D), q = M(this[p], W);
        q.timesInvoked++, q.data.callback && (q.data = { ...q.data, ...q.data.callback(D) });
        const { data: { statusCode: O, data: P, headers: Z, trailers: cA, error: EA }, delay: fA, persist: uA } = q, { timesInvoked: pA, times: RA } = q;
        if (q.consumed = !uA && pA >= RA, q.pending = pA < RA, EA !== null)
          return J(this[p], W), S.onError(EA), true;
        typeof fA == "number" && fA > 0 ? setTimeout(() => {
          DA(this[p]);
        }, fA) : DA(this[p]);
        function DA(UA, QA = P) {
          const eA = Array.isArray(D.headers) ? o(D.headers) : D.headers, lA = typeof QA == "function" ? QA({ ...D, headers: eA }) : QA;
          if (Q(lA)) {
            lA.then((sA) => DA(UA, sA));
            return;
          }
          const YA = N(lA), nA = H(Z), $2 = H(cA);
          S.onConnect?.((sA) => S.onError(sA), null), S.onHeaders?.(O, nA, TA, h(O)), S.onData?.(Buffer.from(YA)), S.onComplete?.($2), J(UA, W);
        }
        e(DA, "handleReply");
        function TA() {
        }
        return e(TA, "resume"), true;
      }
      e(k, "mockDispatch");
      function i() {
        const D = this[c], S = this[t], W = this[E];
        return e(function(O, P) {
          if (D.isMockActive)
            try {
              k.call(this, O, P);
            } catch (Z) {
              if (Z instanceof A) {
                const cA = D[B]();
                if (cA === false)
                  throw new A(`${Z.message}: subsequent request to origin ${S} was not allowed (net.connect disabled)`);
                if (F(cA, S))
                  W.call(this, O, P);
                else
                  throw new A(`${Z.message}: subsequent request to origin ${S} was not allowed (net.connect is not enabled for this origin)`);
              } else
                throw Z;
            }
          else
            W.call(this, O, P);
        }, "dispatch");
      }
      e(i, "buildMockDispatch");
      function F(D, S) {
        const W = new URL(S);
        return D === true ? true : !!(Array.isArray(D) && D.some((q) => u(q, W.host)));
      }
      e(F, "checkNetConnect");
      function m(D) {
        if (D) {
          const { agent: S, ...W } = D;
          return W;
        }
      }
      return e(m, "buildMockOptions"), mockUtils = { getResponseData: N, getMockDispatch: M, addMockDispatch: Y, deleteMockDispatch: J, buildKey: V, generateKeyValues: H, matchValue: u, getResponse: I, getStatusText: h, mockDispatch: k, buildMockDispatch: i, checkNetConnect: F, buildMockOptions: m, getHeaderByName: r, buildHeadersFromArray: o }, mockUtils;
    }
    e(requireMockUtils, "requireMockUtils");
    var mockInterceptor = {};
    var hasRequiredMockInterceptor;
    function requireMockInterceptor() {
      if (hasRequiredMockInterceptor)
        return mockInterceptor;
      hasRequiredMockInterceptor = 1;
      const { getResponseData: A, buildKey: p, addMockDispatch: c } = requireMockUtils(), { kDispatches: E, kDispatchKey: t, kDefaultHeaders: B, kDefaultTrailers: f, kContentLength: l, kMockDispatch: Q } = requireMockSymbols(), { InvalidArgumentError: u } = requireErrors(), { buildURL: n } = requireUtil$7();
      class r {
        static {
          e(this, "MockScope");
        }
        constructor(g) {
          this[Q] = g;
        }
        delay(g) {
          if (typeof g != "number" || !Number.isInteger(g) || g <= 0)
            throw new u("waitInMs must be a valid integer > 0");
          return this[Q].delay = g, this;
        }
        persist() {
          return this[Q].persist = true, this;
        }
        times(g) {
          if (typeof g != "number" || !Number.isInteger(g) || g <= 0)
            throw new u("repeatTimes must be a valid integer > 0");
          return this[Q].times = g, this;
        }
      }
      class o {
        static {
          e(this, "MockInterceptor");
        }
        constructor(g, d) {
          if (typeof g != "object")
            throw new u("opts must be an object");
          if (typeof g.path > "u")
            throw new u("opts.path must be defined");
          if (typeof g.method > "u" && (g.method = "GET"), typeof g.path == "string")
            if (g.query)
              g.path = n(g.path, g.query);
            else {
              const N = new URL(g.path, "data://");
              g.path = N.pathname + N.search;
            }
          typeof g.method == "string" && (g.method = g.method.toUpperCase()), this[t] = p(g), this[E] = d, this[B] = {}, this[f] = {}, this[l] = false;
        }
        createMockScopeDispatchData({ statusCode: g, data: d, responseOptions: N }) {
          const M = A(d), Y = this[l] ? { "content-length": M.length } : {}, J = { ...this[B], ...Y, ...N.headers }, V = { ...this[f], ...N.trailers };
          return { statusCode: g, data: d, headers: J, trailers: V };
        }
        validateReplyParameters(g) {
          if (typeof g.statusCode > "u")
            throw new u("statusCode must be defined");
          if (typeof g.responseOptions != "object" || g.responseOptions === null)
            throw new u("responseOptions must be an object");
        }
        reply(g) {
          if (typeof g == "function") {
            const Y = e((V) => {
              const H = g(V);
              if (typeof H != "object" || H === null)
                throw new u("reply options callback must return an object");
              const h = { data: "", responseOptions: {}, ...H };
              return this.validateReplyParameters(h), { ...this.createMockScopeDispatchData(h) };
            }, "wrappedDefaultsCallback"), J = c(this[E], this[t], Y);
            return new r(J);
          }
          const d = { statusCode: g, data: arguments[1] === void 0 ? "" : arguments[1], responseOptions: arguments[2] === void 0 ? {} : arguments[2] };
          this.validateReplyParameters(d);
          const N = this.createMockScopeDispatchData(d), M = c(this[E], this[t], N);
          return new r(M);
        }
        replyWithError(g) {
          if (typeof g > "u")
            throw new u("error must be defined");
          const d = c(this[E], this[t], { error: g });
          return new r(d);
        }
        defaultReplyHeaders(g) {
          if (typeof g > "u")
            throw new u("headers must be defined");
          return this[B] = g, this;
        }
        defaultReplyTrailers(g) {
          if (typeof g > "u")
            throw new u("trailers must be defined");
          return this[f] = g, this;
        }
        replyContentLength() {
          return this[l] = true, this;
        }
      }
      return mockInterceptor.MockInterceptor = o, mockInterceptor.MockScope = r, mockInterceptor;
    }
    e(requireMockInterceptor, "requireMockInterceptor");
    var mockClient;
    var hasRequiredMockClient;
    function requireMockClient() {
      if (hasRequiredMockClient)
        return mockClient;
      hasRequiredMockClient = 1;
      const { promisify: A } = require$$0__default$3, p = requireClient(), { buildMockDispatch: c } = requireMockUtils(), { kDispatches: E, kMockAgent: t, kClose: B, kOriginalClose: f, kOrigin: l, kOriginalDispatch: Q, kConnected: u } = requireMockSymbols(), { MockInterceptor: n } = requireMockInterceptor(), r = requireSymbols$4(), { InvalidArgumentError: o } = requireErrors();
      class a extends p {
        static {
          e(this, "MockClient");
        }
        constructor(d, N) {
          if (super(d, N), !N || !N.agent || typeof N.agent.dispatch != "function")
            throw new o("Argument opts.agent must implement Agent");
          this[t] = N.agent, this[l] = d, this[E] = [], this[u] = 1, this[Q] = this.dispatch, this[f] = this.close.bind(this), this.dispatch = c.call(this), this.close = this[B];
        }
        get [r.kConnected]() {
          return this[u];
        }
        intercept(d) {
          return new n(d, this[E]);
        }
        async [B]() {
          await A(this[f])(), this[u] = 0, this[t][r.kClients].delete(this[l]);
        }
      }
      return mockClient = a, mockClient;
    }
    e(requireMockClient, "requireMockClient");
    var mockPool;
    var hasRequiredMockPool;
    function requireMockPool() {
      if (hasRequiredMockPool)
        return mockPool;
      hasRequiredMockPool = 1;
      const { promisify: A } = require$$0__default$3, p = requirePool(), { buildMockDispatch: c } = requireMockUtils(), { kDispatches: E, kMockAgent: t, kClose: B, kOriginalClose: f, kOrigin: l, kOriginalDispatch: Q, kConnected: u } = requireMockSymbols(), { MockInterceptor: n } = requireMockInterceptor(), r = requireSymbols$4(), { InvalidArgumentError: o } = requireErrors();
      class a extends p {
        static {
          e(this, "MockPool");
        }
        constructor(d, N) {
          if (super(d, N), !N || !N.agent || typeof N.agent.dispatch != "function")
            throw new o("Argument opts.agent must implement Agent");
          this[t] = N.agent, this[l] = d, this[E] = [], this[u] = 1, this[Q] = this.dispatch, this[f] = this.close.bind(this), this.dispatch = c.call(this), this.close = this[B];
        }
        get [r.kConnected]() {
          return this[u];
        }
        intercept(d) {
          return new n(d, this[E]);
        }
        async [B]() {
          await A(this[f])(), this[u] = 0, this[t][r.kClients].delete(this[l]);
        }
      }
      return mockPool = a, mockPool;
    }
    e(requireMockPool, "requireMockPool");
    var pluralizer;
    var hasRequiredPluralizer;
    function requirePluralizer() {
      if (hasRequiredPluralizer)
        return pluralizer;
      hasRequiredPluralizer = 1;
      const A = { pronoun: "it", is: "is", was: "was", this: "this" }, p = { pronoun: "they", is: "are", was: "were", this: "these" };
      return pluralizer = class {
        static {
          e(this, "Pluralizer");
        }
        constructor(E, t) {
          this.singular = E, this.plural = t;
        }
        pluralize(E) {
          const t = E === 1, B = t ? A : p, f = t ? this.singular : this.plural;
          return { ...B, count: E, noun: f };
        }
      }, pluralizer;
    }
    e(requirePluralizer, "requirePluralizer");
    var pendingInterceptorsFormatter;
    var hasRequiredPendingInterceptorsFormatter;
    function requirePendingInterceptorsFormatter() {
      if (hasRequiredPendingInterceptorsFormatter)
        return pendingInterceptorsFormatter;
      hasRequiredPendingInterceptorsFormatter = 1;
      const { Transform: A } = Stream__default, { Console: p } = require$$1__default$2, c = process.versions.icu ? "\u2705" : "Y ", E = process.versions.icu ? "\u274C" : "N ";
      return pendingInterceptorsFormatter = class {
        static {
          e(this, "PendingInterceptorsFormatter");
        }
        constructor({ disableColors: B } = {}) {
          this.transform = new A({ transform(f, l, Q) {
            Q(null, f);
          } }), this.logger = new p({ stdout: this.transform, inspectOptions: { colors: !B && !process.env.CI } });
        }
        format(B) {
          const f = B.map(({ method: l, path: Q, data: { statusCode: u }, persist: n, times: r, timesInvoked: o, origin: a }) => ({ Method: l, Origin: a, Path: Q, "Status code": u, Persistent: n ? c : E, Invocations: o, Remaining: n ? 1 / 0 : r - o }));
          return this.logger.table(f), this.transform.read().toString();
        }
      }, pendingInterceptorsFormatter;
    }
    e(requirePendingInterceptorsFormatter, "requirePendingInterceptorsFormatter");
    var mockAgent;
    var hasRequiredMockAgent;
    function requireMockAgent() {
      if (hasRequiredMockAgent)
        return mockAgent;
      hasRequiredMockAgent = 1;
      const { kClients: A } = requireSymbols$4(), p = requireAgent(), { kAgent: c, kMockAgentSet: E, kMockAgentGet: t, kDispatches: B, kIsMockActive: f, kNetConnect: l, kGetNetConnect: Q, kOptions: u, kFactory: n } = requireMockSymbols(), r = requireMockClient(), o = requireMockPool(), { matchValue: a, buildMockOptions: g } = requireMockUtils(), { InvalidArgumentError: d, UndiciError: N } = requireErrors(), M = requireDispatcher(), Y = requirePluralizer(), J = requirePendingInterceptorsFormatter();
      class V extends M {
        static {
          e(this, "MockAgent");
        }
        constructor(h) {
          if (super(h), this[l] = true, this[f] = true, h?.agent && typeof h.agent.dispatch != "function")
            throw new d("Argument opts.agent must implement Agent");
          const I = h?.agent ? h.agent : new p(h);
          this[c] = I, this[A] = I[A], this[u] = g(h);
        }
        get(h) {
          let I = this[t](h);
          return I || (I = this[n](h), this[E](h, I)), I;
        }
        dispatch(h, I) {
          return this.get(h.origin), this[c].dispatch(h, I);
        }
        async close() {
          await this[c].close(), this[A].clear();
        }
        deactivate() {
          this[f] = false;
        }
        activate() {
          this[f] = true;
        }
        enableNetConnect(h) {
          if (typeof h == "string" || typeof h == "function" || h instanceof RegExp)
            Array.isArray(this[l]) ? this[l].push(h) : this[l] = [h];
          else if (typeof h > "u")
            this[l] = true;
          else
            throw new d("Unsupported matcher. Must be one of String|Function|RegExp.");
        }
        disableNetConnect() {
          this[l] = false;
        }
        get isMockActive() {
          return this[f];
        }
        [E](h, I) {
          this[A].set(h, I);
        }
        [n](h) {
          const I = Object.assign({ agent: this }, this[u]);
          return this[u] && this[u].connections === 1 ? new r(h, I) : new o(h, I);
        }
        [t](h) {
          const I = this[A].get(h);
          if (I)
            return I;
          if (typeof h != "string") {
            const k = this[n]("http://localhost:9999");
            return this[E](h, k), k;
          }
          for (const [k, i] of Array.from(this[A]))
            if (i && typeof k != "string" && a(k, h)) {
              const F = this[n](h);
              return this[E](h, F), F[B] = i[B], F;
            }
        }
        [Q]() {
          return this[l];
        }
        pendingInterceptors() {
          const h = this[A];
          return Array.from(h.entries()).flatMap(([I, k]) => k[B].map((i) => ({ ...i, origin: I }))).filter(({ pending: I }) => I);
        }
        assertNoPendingInterceptors({ pendingInterceptorsFormatter: h = new J() } = {}) {
          const I = this.pendingInterceptors();
          if (I.length === 0)
            return;
          const k = new Y("interceptor", "interceptors").pluralize(I.length);
          throw new N(`
${k.count} ${k.noun} ${k.is} pending:

${h.format(I)}
`.trim());
        }
      }
      return mockAgent = V, mockAgent;
    }
    e(requireMockAgent, "requireMockAgent");
    var global3;
    var hasRequiredGlobal;
    function requireGlobal() {
      if (hasRequiredGlobal)
        return global3;
      hasRequiredGlobal = 1;
      const A = Symbol.for("undici.globalDispatcher.1"), { InvalidArgumentError: p } = requireErrors(), c = requireAgent();
      t() === void 0 && E(new c());
      function E(B) {
        if (!B || typeof B.dispatch != "function")
          throw new p("Argument agent must implement Agent");
        Object.defineProperty(globalThis, A, { value: B, writable: true, enumerable: false, configurable: false });
      }
      e(E, "setGlobalDispatcher");
      function t() {
        return globalThis[A];
      }
      return e(t, "getGlobalDispatcher"), global3 = { setGlobalDispatcher: E, getGlobalDispatcher: t }, global3;
    }
    e(requireGlobal, "requireGlobal");
    var decoratorHandler;
    var hasRequiredDecoratorHandler;
    function requireDecoratorHandler() {
      return hasRequiredDecoratorHandler || (hasRequiredDecoratorHandler = 1, decoratorHandler = class {
        static {
          e(this, "DecoratorHandler");
        }
        #A;
        constructor(p) {
          if (typeof p != "object" || p === null)
            throw new TypeError("handler must be an object");
          this.#A = p;
        }
        onConnect(...p) {
          return this.#A.onConnect?.(...p);
        }
        onError(...p) {
          return this.#A.onError?.(...p);
        }
        onUpgrade(...p) {
          return this.#A.onUpgrade?.(...p);
        }
        onResponseStarted(...p) {
          return this.#A.onResponseStarted?.(...p);
        }
        onHeaders(...p) {
          return this.#A.onHeaders?.(...p);
        }
        onData(...p) {
          return this.#A.onData?.(...p);
        }
        onComplete(...p) {
          return this.#A.onComplete?.(...p);
        }
        onBodySent(...p) {
          return this.#A.onBodySent?.(...p);
        }
      }), decoratorHandler;
    }
    e(requireDecoratorHandler, "requireDecoratorHandler");
    var redirect;
    var hasRequiredRedirect;
    function requireRedirect() {
      if (hasRequiredRedirect)
        return redirect;
      hasRequiredRedirect = 1;
      const A = requireRedirectHandler();
      return redirect = e((p) => {
        const c = p?.maxRedirections;
        return (E) => e(function(B, f) {
          const { maxRedirections: l = c, ...Q } = B;
          if (!l)
            return E(B, f);
          const u = new A(E, l, B, f);
          return E(Q, u);
        }, "redirectInterceptor");
      }, "redirect"), redirect;
    }
    e(requireRedirect, "requireRedirect");
    var retry;
    var hasRequiredRetry;
    function requireRetry() {
      if (hasRequiredRetry)
        return retry;
      hasRequiredRetry = 1;
      const A = requireRetryHandler();
      return retry = e((p) => (c) => e(function(t, B) {
        return c(t, new A({ ...t, retryOptions: { ...p, ...t.retryOptions } }, { handler: B, dispatch: c }));
      }, "retryInterceptor"), "retry"), retry;
    }
    e(requireRetry, "requireRetry");
    var dump;
    var hasRequiredDump;
    function requireDump() {
      if (hasRequiredDump)
        return dump;
      hasRequiredDump = 1;
      const A = requireUtil$7(), { InvalidArgumentError: p, RequestAbortedError: c } = requireErrors(), E = requireDecoratorHandler();
      class t extends E {
        static {
          e(this, "DumpHandler");
        }
        #A = 1024 * 1024;
        #e = null;
        #n = false;
        #r = false;
        #t = 0;
        #s = null;
        #o = null;
        constructor({ maxSize: l }, Q) {
          if (super(Q), l != null && (!Number.isFinite(l) || l < 1))
            throw new p("maxSize must be a number greater than 0");
          this.#A = l ?? this.#A, this.#o = Q;
        }
        onConnect(l) {
          this.#e = l, this.#o.onConnect(this.#i.bind(this));
        }
        #i(l) {
          this.#r = true, this.#s = l;
        }
        onHeaders(l, Q, u, n) {
          const o = A.parseHeaders(Q)["content-length"];
          if (o != null && o > this.#A)
            throw new c(`Response size (${o}) larger than maxSize (${this.#A})`);
          return this.#r ? true : this.#o.onHeaders(l, Q, u, n);
        }
        onError(l) {
          this.#n || (l = this.#s ?? l, this.#o.onError(l));
        }
        onData(l) {
          return this.#t = this.#t + l.length, this.#t >= this.#A && (this.#n = true, this.#r ? this.#o.onError(this.#s) : this.#o.onComplete([])), true;
        }
        onComplete(l) {
          if (!this.#n) {
            if (this.#r) {
              this.#o.onError(this.reason);
              return;
            }
            this.#o.onComplete(l);
          }
        }
      }
      function B({ maxSize: f } = { maxSize: 1024 * 1024 }) {
        return (l) => e(function(u, n) {
          const { dumpMaxSize: r = f } = u, o = new t({ maxSize: r }, n);
          return l(u, o);
        }, "Intercept");
      }
      return e(B, "createDumpInterceptor"), dump = B, dump;
    }
    e(requireDump, "requireDump");
    var dns;
    var hasRequiredDns;
    function requireDns() {
      if (hasRequiredDns)
        return dns;
      hasRequiredDns = 1;
      const { isIP: A } = require$$0__default$1, { lookup: p } = require$$1__default$3, c = requireDecoratorHandler(), { InvalidArgumentError: E, InformationalError: t } = requireErrors(), B = Math.pow(2, 31) - 1;
      class f {
        static {
          e(this, "DNSInstance");
        }
        #A = 0;
        #e = 0;
        #n = /* @__PURE__ */ new Map();
        dualStack = true;
        affinity = null;
        lookup = null;
        pick = null;
        constructor(u) {
          this.#A = u.maxTTL, this.#e = u.maxItems, this.dualStack = u.dualStack, this.affinity = u.affinity, this.lookup = u.lookup ?? this.#r, this.pick = u.pick ?? this.#t;
        }
        get full() {
          return this.#n.size === this.#e;
        }
        runLookup(u, n, r) {
          const o = this.#n.get(u.hostname);
          if (o == null && this.full) {
            r(null, u.origin);
            return;
          }
          const a = { affinity: this.affinity, dualStack: this.dualStack, lookup: this.lookup, pick: this.pick, ...n.dns, maxTTL: this.#A, maxItems: this.#e };
          if (o == null)
            this.lookup(u, a, (g, d) => {
              if (g || d == null || d.length === 0) {
                r(g ?? new t("No DNS entries found"));
                return;
              }
              this.setRecords(u, d);
              const N = this.#n.get(u.hostname), M = this.pick(u, N, a.affinity);
              let Y;
              typeof M.port == "number" ? Y = `:${M.port}` : u.port !== "" ? Y = `:${u.port}` : Y = "", r(null, `${u.protocol}//${M.family === 6 ? `[${M.address}]` : M.address}${Y}`);
            });
          else {
            const g = this.pick(u, o, a.affinity);
            if (g == null) {
              this.#n.delete(u.hostname), this.runLookup(u, n, r);
              return;
            }
            let d;
            typeof g.port == "number" ? d = `:${g.port}` : u.port !== "" ? d = `:${u.port}` : d = "", r(null, `${u.protocol}//${g.family === 6 ? `[${g.address}]` : g.address}${d}`);
          }
        }
        #r(u, n, r) {
          p(u.hostname, { all: true, family: this.dualStack === false ? this.affinity : 0, order: "ipv4first" }, (o, a) => {
            if (o)
              return r(o);
            const g = /* @__PURE__ */ new Map();
            for (const d of a)
              g.set(`${d.address}:${d.family}`, d);
            r(null, g.values());
          });
        }
        #t(u, n, r) {
          let o = null;
          const { records: a, offset: g } = n;
          let d;
          if (this.dualStack ? (r == null && (g == null || g === B ? (n.offset = 0, r = 4) : (n.offset++, r = (n.offset & 1) === 1 ? 6 : 4)), a[r] != null && a[r].ips.length > 0 ? d = a[r] : d = a[r === 4 ? 6 : 4]) : d = a[r], d == null || d.ips.length === 0)
            return o;
          d.offset == null || d.offset === B ? d.offset = 0 : d.offset++;
          const N = d.offset % d.ips.length;
          return o = d.ips[N] ?? null, o == null ? o : Date.now() - o.timestamp > o.ttl ? (d.ips.splice(N, 1), this.pick(u, n, r)) : o;
        }
        setRecords(u, n) {
          const r = Date.now(), o = { records: { 4: null, 6: null } };
          for (const a of n) {
            a.timestamp = r, typeof a.ttl == "number" ? a.ttl = Math.min(a.ttl, this.#A) : a.ttl = this.#A;
            const g = o.records[a.family] ?? { ips: [] };
            g.ips.push(a), o.records[a.family] = g;
          }
          this.#n.set(u.hostname, o);
        }
        getHandler(u, n) {
          return new l(this, u, n);
        }
      }
      class l extends c {
        static {
          e(this, "DNSDispatchHandler");
        }
        #A = null;
        #e = null;
        #n = null;
        #r = null;
        #t = null;
        constructor(u, { origin: n, handler: r, dispatch: o }, a) {
          super(r), this.#t = n, this.#r = r, this.#e = { ...a }, this.#A = u, this.#n = o;
        }
        onError(u) {
          switch (u.code) {
            case "ETIMEDOUT":
            case "ECONNREFUSED": {
              if (this.#A.dualStack) {
                this.#A.runLookup(this.#t, this.#e, (n, r) => {
                  if (n)
                    return this.#r.onError(n);
                  const o = { ...this.#e, origin: r };
                  this.#n(o, this);
                });
                return;
              }
              this.#r.onError(u);
              return;
            }
            case "ENOTFOUND":
              this.#A.deleteRecord(this.#t);
            default:
              this.#r.onError(u);
              break;
          }
        }
      }
      return dns = e((Q) => {
        if (Q?.maxTTL != null && (typeof Q?.maxTTL != "number" || Q?.maxTTL < 0))
          throw new E("Invalid maxTTL. Must be a positive number");
        if (Q?.maxItems != null && (typeof Q?.maxItems != "number" || Q?.maxItems < 1))
          throw new E("Invalid maxItems. Must be a positive number and greater than zero");
        if (Q?.affinity != null && Q?.affinity !== 4 && Q?.affinity !== 6)
          throw new E("Invalid affinity. Must be either 4 or 6");
        if (Q?.dualStack != null && typeof Q?.dualStack != "boolean")
          throw new E("Invalid dualStack. Must be a boolean");
        if (Q?.lookup != null && typeof Q?.lookup != "function")
          throw new E("Invalid lookup. Must be a function");
        if (Q?.pick != null && typeof Q?.pick != "function")
          throw new E("Invalid pick. Must be a function");
        const u = Q?.dualStack ?? true;
        let n;
        u ? n = Q?.affinity ?? null : n = Q?.affinity ?? 4;
        const r = { maxTTL: Q?.maxTTL ?? 1e4, lookup: Q?.lookup ?? null, pick: Q?.pick ?? null, dualStack: u, affinity: n, maxItems: Q?.maxItems ?? 1 / 0 }, o = new f(r);
        return (a) => e(function(d, N) {
          const M = d.origin.constructor === URL ? d.origin : new URL(d.origin);
          return A(M.hostname) !== 0 ? a(d, N) : (o.runLookup(M, d, (Y, J) => {
            if (Y)
              return N.onError(Y);
            let V = null;
            V = { ...d, servername: M.hostname, origin: J, headers: { host: M.hostname, ...d.headers } }, a(V, o.getHandler({ origin: M, dispatch: a, handler: N }, d));
          }), true);
        }, "dnsInterceptor");
      }, "dns"), dns;
    }
    e(requireDns, "requireDns");
    var headers;
    var hasRequiredHeaders;
    function requireHeaders() {
      if (hasRequiredHeaders)
        return headers;
      hasRequiredHeaders = 1;
      const { kConstruct: A } = requireSymbols$4(), { kEnumerableProperty: p } = requireUtil$7(), { iteratorMixin: c, isValidHeaderName: E, isValidHeaderValue: t } = requireUtil$6(), { webidl: B } = requireWebidl(), f = require$$0__default, l = require$$0__default$3, Q = Symbol("headers map"), u = Symbol("headers map sorted");
      function n(H) {
        return H === 10 || H === 13 || H === 9 || H === 32;
      }
      e(n, "isHTTPWhiteSpaceCharCode");
      function r(H) {
        let h = 0, I = H.length;
        for (; I > h && n(H.charCodeAt(I - 1)); )
          --I;
        for (; I > h && n(H.charCodeAt(h)); )
          ++h;
        return h === 0 && I === H.length ? H : H.substring(h, I);
      }
      e(r, "headerValueNormalize");
      function o(H, h) {
        if (Array.isArray(h))
          for (let I = 0; I < h.length; ++I) {
            const k = h[I];
            if (k.length !== 2)
              throw B.errors.exception({ header: "Headers constructor", message: `expected name/value pair to be length 2, found ${k.length}.` });
            a(H, k[0], k[1]);
          }
        else if (typeof h == "object" && h !== null) {
          const I = Object.keys(h);
          for (let k = 0; k < I.length; ++k)
            a(H, I[k], h[I[k]]);
        } else
          throw B.errors.conversionFailed({ prefix: "Headers constructor", argument: "Argument 1", types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"] });
      }
      e(o, "fill");
      function a(H, h, I) {
        if (I = r(I), E(h)) {
          if (!t(I))
            throw B.errors.invalidArgument({ prefix: "Headers.append", value: I, type: "header value" });
        } else
          throw B.errors.invalidArgument({ prefix: "Headers.append", value: h, type: "header name" });
        if (M(H) === "immutable")
          throw new TypeError("immutable");
        return J(H).append(h, I, false);
      }
      e(a, "appendHeader");
      function g(H, h) {
        return H[0] < h[0] ? -1 : 1;
      }
      e(g, "compareHeaderName");
      class d {
        static {
          e(this, "HeadersList");
        }
        cookies = null;
        constructor(h) {
          h instanceof d ? (this[Q] = new Map(h[Q]), this[u] = h[u], this.cookies = h.cookies === null ? null : [...h.cookies]) : (this[Q] = new Map(h), this[u] = null);
        }
        contains(h, I) {
          return this[Q].has(I ? h : h.toLowerCase());
        }
        clear() {
          this[Q].clear(), this[u] = null, this.cookies = null;
        }
        append(h, I, k) {
          this[u] = null;
          const i = k ? h : h.toLowerCase(), F = this[Q].get(i);
          if (F) {
            const m = i === "cookie" ? "; " : ", ";
            this[Q].set(i, { name: F.name, value: `${F.value}${m}${I}` });
          } else
            this[Q].set(i, { name: h, value: I });
          i === "set-cookie" && (this.cookies ??= []).push(I);
        }
        set(h, I, k) {
          this[u] = null;
          const i = k ? h : h.toLowerCase();
          i === "set-cookie" && (this.cookies = [I]), this[Q].set(i, { name: h, value: I });
        }
        delete(h, I) {
          this[u] = null, I || (h = h.toLowerCase()), h === "set-cookie" && (this.cookies = null), this[Q].delete(h);
        }
        get(h, I) {
          return this[Q].get(I ? h : h.toLowerCase())?.value ?? null;
        }
        *[Symbol.iterator]() {
          for (const { 0: h, 1: { value: I } } of this[Q])
            yield [h, I];
        }
        get entries() {
          const h = {};
          if (this[Q].size !== 0)
            for (const { name: I, value: k } of this[Q].values())
              h[I] = k;
          return h;
        }
        rawValues() {
          return this[Q].values();
        }
        get entriesList() {
          const h = [];
          if (this[Q].size !== 0)
            for (const { 0: I, 1: { name: k, value: i } } of this[Q])
              if (I === "set-cookie")
                for (const F of this.cookies)
                  h.push([k, F]);
              else
                h.push([k, i]);
          return h;
        }
        toSortedArray() {
          const h = this[Q].size, I = new Array(h);
          if (h <= 32) {
            if (h === 0)
              return I;
            const k = this[Q][Symbol.iterator](), i = k.next().value;
            I[0] = [i[0], i[1].value], f(i[1].value !== null);
            for (let F = 1, m = 0, D = 0, S = 0, W = 0, q, O; F < h; ++F) {
              for (O = k.next().value, q = I[F] = [O[0], O[1].value], f(q[1] !== null), S = 0, D = F; S < D; )
                W = S + (D - S >> 1), I[W][0] <= q[0] ? S = W + 1 : D = W;
              if (F !== W) {
                for (m = F; m > S; )
                  I[m] = I[--m];
                I[S] = q;
              }
            }
            if (!k.next().done)
              throw new TypeError("Unreachable");
            return I;
          } else {
            let k = 0;
            for (const { 0: i, 1: { value: F } } of this[Q])
              I[k++] = [i, F], f(F !== null);
            return I.sort(g);
          }
        }
      }
      class N {
        static {
          e(this, "Headers");
        }
        #A;
        #e;
        constructor(h = void 0) {
          B.util.markAsUncloneable(this), h !== A && (this.#e = new d(), this.#A = "none", h !== void 0 && (h = B.converters.HeadersInit(h, "Headers contructor", "init"), o(this, h)));
        }
        append(h, I) {
          B.brandCheck(this, N), B.argumentLengthCheck(arguments, 2, "Headers.append");
          const k = "Headers.append";
          return h = B.converters.ByteString(h, k, "name"), I = B.converters.ByteString(I, k, "value"), a(this, h, I);
        }
        delete(h) {
          if (B.brandCheck(this, N), B.argumentLengthCheck(arguments, 1, "Headers.delete"), h = B.converters.ByteString(h, "Headers.delete", "name"), !E(h))
            throw B.errors.invalidArgument({ prefix: "Headers.delete", value: h, type: "header name" });
          if (this.#A === "immutable")
            throw new TypeError("immutable");
          this.#e.contains(h, false) && this.#e.delete(h, false);
        }
        get(h) {
          B.brandCheck(this, N), B.argumentLengthCheck(arguments, 1, "Headers.get");
          const I = "Headers.get";
          if (h = B.converters.ByteString(h, I, "name"), !E(h))
            throw B.errors.invalidArgument({ prefix: I, value: h, type: "header name" });
          return this.#e.get(h, false);
        }
        has(h) {
          B.brandCheck(this, N), B.argumentLengthCheck(arguments, 1, "Headers.has");
          const I = "Headers.has";
          if (h = B.converters.ByteString(h, I, "name"), !E(h))
            throw B.errors.invalidArgument({ prefix: I, value: h, type: "header name" });
          return this.#e.contains(h, false);
        }
        set(h, I) {
          B.brandCheck(this, N), B.argumentLengthCheck(arguments, 2, "Headers.set");
          const k = "Headers.set";
          if (h = B.converters.ByteString(h, k, "name"), I = B.converters.ByteString(I, k, "value"), I = r(I), E(h)) {
            if (!t(I))
              throw B.errors.invalidArgument({ prefix: k, value: I, type: "header value" });
          } else
            throw B.errors.invalidArgument({ prefix: k, value: h, type: "header name" });
          if (this.#A === "immutable")
            throw new TypeError("immutable");
          this.#e.set(h, I, false);
        }
        getSetCookie() {
          B.brandCheck(this, N);
          const h = this.#e.cookies;
          return h ? [...h] : [];
        }
        get [u]() {
          if (this.#e[u])
            return this.#e[u];
          const h = [], I = this.#e.toSortedArray(), k = this.#e.cookies;
          if (k === null || k.length === 1)
            return this.#e[u] = I;
          for (let i = 0; i < I.length; ++i) {
            const { 0: F, 1: m } = I[i];
            if (F === "set-cookie")
              for (let D = 0; D < k.length; ++D)
                h.push([F, k[D]]);
            else
              h.push([F, m]);
          }
          return this.#e[u] = h;
        }
        [l.inspect.custom](h, I) {
          return I.depth ??= h, `Headers ${l.formatWithOptions(I, this.#e.entries)}`;
        }
        static getHeadersGuard(h) {
          return h.#A;
        }
        static setHeadersGuard(h, I) {
          h.#A = I;
        }
        static getHeadersList(h) {
          return h.#e;
        }
        static setHeadersList(h, I) {
          h.#e = I;
        }
      }
      const { getHeadersGuard: M, setHeadersGuard: Y, getHeadersList: J, setHeadersList: V } = N;
      return Reflect.deleteProperty(N, "getHeadersGuard"), Reflect.deleteProperty(N, "setHeadersGuard"), Reflect.deleteProperty(N, "getHeadersList"), Reflect.deleteProperty(N, "setHeadersList"), c("Headers", N, u, 0, 1), Object.defineProperties(N.prototype, { append: p, delete: p, get: p, has: p, set: p, getSetCookie: p, [Symbol.toStringTag]: { value: "Headers", configurable: true }, [l.inspect.custom]: { enumerable: false } }), B.converters.HeadersInit = function(H, h, I) {
        if (B.util.Type(H) === "Object") {
          const k = Reflect.get(H, Symbol.iterator);
          if (!l.types.isProxy(H) && k === N.prototype.entries)
            try {
              return J(H).entriesList;
            } catch {
            }
          return typeof k == "function" ? B.converters["sequence<sequence<ByteString>>"](H, h, I, k.bind(H)) : B.converters["record<ByteString, ByteString>"](H, h, I);
        }
        throw B.errors.conversionFailed({ prefix: "Headers constructor", argument: "Argument 1", types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"] });
      }, headers = { fill: o, compareHeaderName: g, Headers: N, HeadersList: d, getHeadersGuard: M, setHeadersGuard: Y, setHeadersList: V, getHeadersList: J }, headers;
    }
    e(requireHeaders, "requireHeaders");
    var response;
    var hasRequiredResponse;
    function requireResponse() {
      if (hasRequiredResponse)
        return response;
      hasRequiredResponse = 1;
      const { Headers: A, HeadersList: p, fill: c, getHeadersGuard: E, setHeadersGuard: t, setHeadersList: B } = requireHeaders(), { extractBody: f, cloneBody: l, mixinBody: Q, hasFinalizationRegistry: u, streamRegistry: n, bodyUnusable: r } = requireBody(), o = requireUtil$7(), a = require$$0__default$3, { kEnumerableProperty: g } = o, { isValidReasonPhrase: d, isCancelled: N, isAborted: M, isBlobLike: Y, serializeJavascriptValueToJSONString: J, isErrorLike: V, isomorphicEncode: H, environmentSettingsObject: h } = requireUtil$6(), { redirectStatusSet: I, nullBodyStatus: k } = requireConstants$2(), { kState: i, kHeaders: F } = requireSymbols$3(), { webidl: m } = requireWebidl(), { FormData: D } = requireFormdata(), { URLSerializer: S } = requireDataUrl(), { kConstruct: W } = requireSymbols$4(), q = require$$0__default, { types: O } = require$$0__default$3, P = new TextEncoder("utf-8");
      class Z {
        static {
          e(this, "Response");
        }
        static error() {
          return UA(fA(), "immutable");
        }
        static json(eA, lA = {}) {
          m.argumentLengthCheck(arguments, 1, "Response.json"), lA !== null && (lA = m.converters.ResponseInit(lA));
          const YA = P.encode(J(eA)), nA = f(YA), $2 = UA(EA({}), "response");
          return TA($2, lA, { body: nA[0], type: "application/json" }), $2;
        }
        static redirect(eA, lA = 302) {
          m.argumentLengthCheck(arguments, 1, "Response.redirect"), eA = m.converters.USVString(eA), lA = m.converters["unsigned short"](lA);
          let YA;
          try {
            YA = new URL(eA, h.settingsObject.baseUrl);
          } catch (sA) {
            throw new TypeError(`Failed to parse URL from ${eA}`, { cause: sA });
          }
          if (!I.has(lA))
            throw new RangeError(`Invalid status code ${lA}`);
          const nA = UA(EA({}), "immutable");
          nA[i].status = lA;
          const $2 = H(S(YA));
          return nA[i].headersList.append("location", $2, true), nA;
        }
        constructor(eA = null, lA = {}) {
          if (m.util.markAsUncloneable(this), eA === W)
            return;
          eA !== null && (eA = m.converters.BodyInit(eA)), lA = m.converters.ResponseInit(lA), this[i] = EA({}), this[F] = new A(W), t(this[F], "response"), B(this[F], this[i].headersList);
          let YA = null;
          if (eA != null) {
            const [nA, $2] = f(eA);
            YA = { body: nA, type: $2 };
          }
          TA(this, lA, YA);
        }
        get type() {
          return m.brandCheck(this, Z), this[i].type;
        }
        get url() {
          m.brandCheck(this, Z);
          const eA = this[i].urlList, lA = eA[eA.length - 1] ?? null;
          return lA === null ? "" : S(lA, true);
        }
        get redirected() {
          return m.brandCheck(this, Z), this[i].urlList.length > 1;
        }
        get status() {
          return m.brandCheck(this, Z), this[i].status;
        }
        get ok() {
          return m.brandCheck(this, Z), this[i].status >= 200 && this[i].status <= 299;
        }
        get statusText() {
          return m.brandCheck(this, Z), this[i].statusText;
        }
        get headers() {
          return m.brandCheck(this, Z), this[F];
        }
        get body() {
          return m.brandCheck(this, Z), this[i].body ? this[i].body.stream : null;
        }
        get bodyUsed() {
          return m.brandCheck(this, Z), !!this[i].body && o.isDisturbed(this[i].body.stream);
        }
        clone() {
          if (m.brandCheck(this, Z), r(this))
            throw m.errors.exception({ header: "Response.clone", message: "Body has already been consumed." });
          const eA = cA(this[i]);
          return UA(eA, E(this[F]));
        }
        [a.inspect.custom](eA, lA) {
          lA.depth === null && (lA.depth = 2), lA.colors ??= true;
          const YA = { status: this.status, statusText: this.statusText, headers: this.headers, body: this.body, bodyUsed: this.bodyUsed, ok: this.ok, redirected: this.redirected, type: this.type, url: this.url };
          return `Response ${a.formatWithOptions(lA, YA)}`;
        }
      }
      Q(Z), Object.defineProperties(Z.prototype, { type: g, url: g, status: g, ok: g, redirected: g, statusText: g, headers: g, clone: g, body: g, bodyUsed: g, [Symbol.toStringTag]: { value: "Response", configurable: true } }), Object.defineProperties(Z, { json: g, redirect: g, error: g });
      function cA(QA) {
        if (QA.internalResponse)
          return RA(cA(QA.internalResponse), QA.type);
        const eA = EA({ ...QA, body: null });
        return QA.body != null && (eA.body = l(eA, QA.body)), eA;
      }
      e(cA, "cloneResponse");
      function EA(QA) {
        return { aborted: false, rangeRequested: false, timingAllowPassed: false, requestIncludesCredentials: false, type: "default", status: 200, timingInfo: null, cacheState: "", statusText: "", ...QA, headersList: QA?.headersList ? new p(QA?.headersList) : new p(), urlList: QA?.urlList ? [...QA.urlList] : [] };
      }
      e(EA, "makeResponse");
      function fA(QA) {
        const eA = V(QA);
        return EA({ type: "error", status: 0, error: eA ? QA : new Error(QA && String(QA)), aborted: QA && QA.name === "AbortError" });
      }
      e(fA, "makeNetworkError");
      function uA(QA) {
        return QA.type === "error" && QA.status === 0;
      }
      e(uA, "isNetworkError");
      function pA(QA, eA) {
        return eA = { internalResponse: QA, ...eA }, new Proxy(QA, { get(lA, YA) {
          return YA in eA ? eA[YA] : lA[YA];
        }, set(lA, YA, nA) {
          return q(!(YA in eA)), lA[YA] = nA, true;
        } });
      }
      e(pA, "makeFilteredResponse");
      function RA(QA, eA) {
        if (eA === "basic")
          return pA(QA, { type: "basic", headersList: QA.headersList });
        if (eA === "cors")
          return pA(QA, { type: "cors", headersList: QA.headersList });
        if (eA === "opaque")
          return pA(QA, { type: "opaque", urlList: Object.freeze([]), status: 0, statusText: "", body: null });
        if (eA === "opaqueredirect")
          return pA(QA, { type: "opaqueredirect", status: 0, statusText: "", headersList: [], body: null });
        q(false);
      }
      e(RA, "filterResponse");
      function DA(QA, eA = null) {
        return q(N(QA)), M(QA) ? fA(Object.assign(new DOMException("The operation was aborted.", "AbortError"), { cause: eA })) : fA(Object.assign(new DOMException("Request was cancelled."), { cause: eA }));
      }
      e(DA, "makeAppropriateNetworkError");
      function TA(QA, eA, lA) {
        if (eA.status !== null && (eA.status < 200 || eA.status > 599))
          throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
        if ("statusText" in eA && eA.statusText != null && !d(String(eA.statusText)))
          throw new TypeError("Invalid statusText");
        if ("status" in eA && eA.status != null && (QA[i].status = eA.status), "statusText" in eA && eA.statusText != null && (QA[i].statusText = eA.statusText), "headers" in eA && eA.headers != null && c(QA[F], eA.headers), lA) {
          if (k.includes(QA.status))
            throw m.errors.exception({ header: "Response constructor", message: `Invalid response status code ${QA.status}` });
          QA[i].body = lA.body, lA.type != null && !QA[i].headersList.contains("content-type", true) && QA[i].headersList.append("content-type", lA.type, true);
        }
      }
      e(TA, "initializeResponse");
      function UA(QA, eA) {
        const lA = new Z(W);
        return lA[i] = QA, lA[F] = new A(W), B(lA[F], QA.headersList), t(lA[F], eA), u && QA.body?.stream && n.register(lA, new WeakRef(QA.body.stream)), lA;
      }
      return e(UA, "fromInnerResponse"), m.converters.ReadableStream = m.interfaceConverter(ReadableStream), m.converters.FormData = m.interfaceConverter(D), m.converters.URLSearchParams = m.interfaceConverter(URLSearchParams), m.converters.XMLHttpRequestBodyInit = function(QA, eA, lA) {
        return typeof QA == "string" ? m.converters.USVString(QA, eA, lA) : Y(QA) ? m.converters.Blob(QA, eA, lA, { strict: false }) : ArrayBuffer.isView(QA) || O.isArrayBuffer(QA) ? m.converters.BufferSource(QA, eA, lA) : o.isFormDataLike(QA) ? m.converters.FormData(QA, eA, lA, { strict: false }) : QA instanceof URLSearchParams ? m.converters.URLSearchParams(QA, eA, lA) : m.converters.DOMString(QA, eA, lA);
      }, m.converters.BodyInit = function(QA, eA, lA) {
        return QA instanceof ReadableStream ? m.converters.ReadableStream(QA, eA, lA) : QA?.[Symbol.asyncIterator] ? QA : m.converters.XMLHttpRequestBodyInit(QA, eA, lA);
      }, m.converters.ResponseInit = m.dictionaryConverter([{ key: "status", converter: m.converters["unsigned short"], defaultValue: e(() => 200, "defaultValue") }, { key: "statusText", converter: m.converters.ByteString, defaultValue: e(() => "", "defaultValue") }, { key: "headers", converter: m.converters.HeadersInit }]), response = { isNetworkError: uA, makeNetworkError: fA, makeResponse: EA, makeAppropriateNetworkError: DA, filterResponse: RA, Response: Z, cloneResponse: cA, fromInnerResponse: UA }, response;
    }
    e(requireResponse, "requireResponse");
    var dispatcherWeakref;
    var hasRequiredDispatcherWeakref;
    function requireDispatcherWeakref() {
      if (hasRequiredDispatcherWeakref)
        return dispatcherWeakref;
      hasRequiredDispatcherWeakref = 1;
      const { kConnected: A, kSize: p } = requireSymbols$4();
      class c {
        static {
          e(this, "CompatWeakRef");
        }
        constructor(B) {
          this.value = B;
        }
        deref() {
          return this.value[A] === 0 && this.value[p] === 0 ? void 0 : this.value;
        }
      }
      class E {
        static {
          e(this, "CompatFinalizer");
        }
        constructor(B) {
          this.finalizer = B;
        }
        register(B, f) {
          B.on && B.on("disconnect", () => {
            B[A] === 0 && B[p] === 0 && this.finalizer(f);
          });
        }
        unregister(B) {
        }
      }
      return dispatcherWeakref = e(function() {
        return process.env.NODE_V8_COVERAGE && process.version.startsWith("v18") ? (process._rawDebug("Using compatibility WeakRef and FinalizationRegistry"), { WeakRef: c, FinalizationRegistry: E }) : { WeakRef, FinalizationRegistry };
      }, "dispatcherWeakref"), dispatcherWeakref;
    }
    e(requireDispatcherWeakref, "requireDispatcherWeakref");
    var request;
    var hasRequiredRequest;
    function requireRequest() {
      if (hasRequiredRequest)
        return request;
      hasRequiredRequest = 1;
      const { extractBody: A, mixinBody: p, cloneBody: c, bodyUnusable: E } = requireBody(), { Headers: t, fill: B, HeadersList: f, setHeadersGuard: l, getHeadersGuard: Q, setHeadersList: u, getHeadersList: n } = requireHeaders(), { FinalizationRegistry: r } = requireDispatcherWeakref()(), o = requireUtil$7(), a = require$$0__default$3, { isValidHTTPToken: g, sameOrigin: d, environmentSettingsObject: N } = requireUtil$6(), { forbiddenMethodsSet: M, corsSafeListedMethodsSet: Y, referrerPolicy: J, requestRedirect: V, requestMode: H, requestCredentials: h, requestCache: I, requestDuplex: k } = requireConstants$2(), { kEnumerableProperty: i, normalizedMethodRecordsBase: F, normalizedMethodRecords: m } = o, { kHeaders: D, kSignal: S, kState: W, kDispatcher: q } = requireSymbols$3(), { webidl: O } = requireWebidl(), { URLSerializer: P } = requireDataUrl(), { kConstruct: Z } = requireSymbols$4(), cA = require$$0__default, { getMaxListeners: EA, setMaxListeners: fA, getEventListeners: uA, defaultMaxListeners: pA } = require$$8__default, RA = Symbol("abortController"), DA = new r(({ signal: $2, abort: sA }) => {
        $2.removeEventListener("abort", sA);
      }), TA = /* @__PURE__ */ new WeakMap();
      function UA($2) {
        return sA;
        function sA() {
          const BA = $2.deref();
          if (BA !== void 0) {
            DA.unregister(sA), this.removeEventListener("abort", sA), BA.abort(this.reason);
            const dA = TA.get(BA.signal);
            if (dA !== void 0) {
              if (dA.size !== 0) {
                for (const CA of dA) {
                  const mA = CA.deref();
                  mA !== void 0 && mA.abort(this.reason);
                }
                dA.clear();
              }
              TA.delete(BA.signal);
            }
          }
        }
      }
      e(UA, "buildAbort");
      let QA = false;
      class eA {
        static {
          e(this, "Request");
        }
        constructor(sA, BA = {}) {
          if (O.util.markAsUncloneable(this), sA === Z)
            return;
          const dA = "Request constructor";
          O.argumentLengthCheck(arguments, 1, dA), sA = O.converters.RequestInfo(sA, dA, "input"), BA = O.converters.RequestInit(BA, dA, "init");
          let CA = null, mA = null;
          const xA = N.settingsObject.baseUrl;
          let bA = null;
          if (typeof sA == "string") {
            this[q] = BA.dispatcher;
            let AA;
            try {
              AA = new URL(sA, xA);
            } catch (IA) {
              throw new TypeError("Failed to parse URL from " + sA, { cause: IA });
            }
            if (AA.username || AA.password)
              throw new TypeError("Request cannot be constructed from a URL that includes credentials: " + sA);
            CA = lA({ urlList: [AA] }), mA = "cors";
          } else
            this[q] = BA.dispatcher || sA[q], cA(sA instanceof eA), CA = sA[W], bA = sA[S];
          const WA = N.settingsObject.origin;
          let LA = "client";
          if (CA.window?.constructor?.name === "EnvironmentSettingsObject" && d(CA.window, WA) && (LA = CA.window), BA.window != null)
            throw new TypeError(`'window' option '${LA}' must be null`);
          "window" in BA && (LA = "no-window"), CA = lA({ method: CA.method, headersList: CA.headersList, unsafeRequest: CA.unsafeRequest, client: N.settingsObject, window: LA, priority: CA.priority, origin: CA.origin, referrer: CA.referrer, referrerPolicy: CA.referrerPolicy, mode: CA.mode, credentials: CA.credentials, cache: CA.cache, redirect: CA.redirect, integrity: CA.integrity, keepalive: CA.keepalive, reloadNavigation: CA.reloadNavigation, historyNavigation: CA.historyNavigation, urlList: [...CA.urlList] });
          const GA = Object.keys(BA).length !== 0;
          if (GA && (CA.mode === "navigate" && (CA.mode = "same-origin"), CA.reloadNavigation = false, CA.historyNavigation = false, CA.origin = "client", CA.referrer = "client", CA.referrerPolicy = "", CA.url = CA.urlList[CA.urlList.length - 1], CA.urlList = [CA.url]), BA.referrer !== void 0) {
            const AA = BA.referrer;
            if (AA === "")
              CA.referrer = "no-referrer";
            else {
              let IA;
              try {
                IA = new URL(AA, xA);
              } catch (wA) {
                throw new TypeError(`Referrer "${AA}" is not a valid URL.`, { cause: wA });
              }
              IA.protocol === "about:" && IA.hostname === "client" || WA && !d(IA, N.settingsObject.baseUrl) ? CA.referrer = "client" : CA.referrer = IA;
            }
          }
          BA.referrerPolicy !== void 0 && (CA.referrerPolicy = BA.referrerPolicy);
          let NA;
          if (BA.mode !== void 0 ? NA = BA.mode : NA = mA, NA === "navigate")
            throw O.errors.exception({ header: "Request constructor", message: "invalid request mode navigate." });
          if (NA != null && (CA.mode = NA), BA.credentials !== void 0 && (CA.credentials = BA.credentials), BA.cache !== void 0 && (CA.cache = BA.cache), CA.cache === "only-if-cached" && CA.mode !== "same-origin")
            throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
          if (BA.redirect !== void 0 && (CA.redirect = BA.redirect), BA.integrity != null && (CA.integrity = String(BA.integrity)), BA.keepalive !== void 0 && (CA.keepalive = !!BA.keepalive), BA.method !== void 0) {
            let AA = BA.method;
            const IA = m[AA];
            if (IA !== void 0)
              CA.method = IA;
            else {
              if (!g(AA))
                throw new TypeError(`'${AA}' is not a valid HTTP method.`);
              const wA = AA.toUpperCase();
              if (M.has(wA))
                throw new TypeError(`'${AA}' HTTP method is unsupported.`);
              AA = F[wA] ?? AA, CA.method = AA;
            }
            !QA && CA.method === "patch" && (process.emitWarning("Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.", { code: "UNDICI-FETCH-patch" }), QA = true);
          }
          BA.signal !== void 0 && (bA = BA.signal), this[W] = CA;
          const KA = new AbortController();
          if (this[S] = KA.signal, bA != null) {
            if (!bA || typeof bA.aborted != "boolean" || typeof bA.addEventListener != "function")
              throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");
            if (bA.aborted)
              KA.abort(bA.reason);
            else {
              this[RA] = KA;
              const AA = new WeakRef(KA), IA = UA(AA);
              try {
                (typeof EA == "function" && EA(bA) === pA || uA(bA, "abort").length >= pA) && fA(1500, bA);
              } catch {
              }
              o.addAbortListener(bA, IA), DA.register(KA, { signal: bA, abort: IA }, IA);
            }
          }
          if (this[D] = new t(Z), u(this[D], CA.headersList), l(this[D], "request"), NA === "no-cors") {
            if (!Y.has(CA.method))
              throw new TypeError(`'${CA.method} is unsupported in no-cors mode.`);
            l(this[D], "request-no-cors");
          }
          if (GA) {
            const AA = n(this[D]), IA = BA.headers !== void 0 ? BA.headers : new f(AA);
            if (AA.clear(), IA instanceof f) {
              for (const { name: wA, value: FA } of IA.rawValues())
                AA.append(wA, FA, false);
              AA.cookies = IA.cookies;
            } else
              B(this[D], IA);
          }
          const ZA = sA instanceof eA ? sA[W].body : null;
          if ((BA.body != null || ZA != null) && (CA.method === "GET" || CA.method === "HEAD"))
            throw new TypeError("Request with GET/HEAD method cannot have body.");
          let PA = null;
          if (BA.body != null) {
            const [AA, IA] = A(BA.body, CA.keepalive);
            PA = AA, IA && !n(this[D]).contains("content-type", true) && this[D].append("content-type", IA);
          }
          const oA = PA ?? ZA;
          if (oA != null && oA.source == null) {
            if (PA != null && BA.duplex == null)
              throw new TypeError("RequestInit: duplex option is required when sending a body.");
            if (CA.mode !== "same-origin" && CA.mode !== "cors")
              throw new TypeError('If request is made from ReadableStream, mode should be "same-origin" or "cors"');
            CA.useCORSPreflightFlag = true;
          }
          let L = oA;
          if (PA == null && ZA != null) {
            if (E(sA))
              throw new TypeError("Cannot construct a Request with a Request object that has already been used.");
            const AA = new TransformStream();
            ZA.stream.pipeThrough(AA), L = { source: ZA.source, length: ZA.length, stream: AA.readable };
          }
          this[W].body = L;
        }
        get method() {
          return O.brandCheck(this, eA), this[W].method;
        }
        get url() {
          return O.brandCheck(this, eA), P(this[W].url);
        }
        get headers() {
          return O.brandCheck(this, eA), this[D];
        }
        get destination() {
          return O.brandCheck(this, eA), this[W].destination;
        }
        get referrer() {
          return O.brandCheck(this, eA), this[W].referrer === "no-referrer" ? "" : this[W].referrer === "client" ? "about:client" : this[W].referrer.toString();
        }
        get referrerPolicy() {
          return O.brandCheck(this, eA), this[W].referrerPolicy;
        }
        get mode() {
          return O.brandCheck(this, eA), this[W].mode;
        }
        get credentials() {
          return this[W].credentials;
        }
        get cache() {
          return O.brandCheck(this, eA), this[W].cache;
        }
        get redirect() {
          return O.brandCheck(this, eA), this[W].redirect;
        }
        get integrity() {
          return O.brandCheck(this, eA), this[W].integrity;
        }
        get keepalive() {
          return O.brandCheck(this, eA), this[W].keepalive;
        }
        get isReloadNavigation() {
          return O.brandCheck(this, eA), this[W].reloadNavigation;
        }
        get isHistoryNavigation() {
          return O.brandCheck(this, eA), this[W].historyNavigation;
        }
        get signal() {
          return O.brandCheck(this, eA), this[S];
        }
        get body() {
          return O.brandCheck(this, eA), this[W].body ? this[W].body.stream : null;
        }
        get bodyUsed() {
          return O.brandCheck(this, eA), !!this[W].body && o.isDisturbed(this[W].body.stream);
        }
        get duplex() {
          return O.brandCheck(this, eA), "half";
        }
        clone() {
          if (O.brandCheck(this, eA), E(this))
            throw new TypeError("unusable");
          const sA = YA(this[W]), BA = new AbortController();
          if (this.signal.aborted)
            BA.abort(this.signal.reason);
          else {
            let dA = TA.get(this.signal);
            dA === void 0 && (dA = /* @__PURE__ */ new Set(), TA.set(this.signal, dA));
            const CA = new WeakRef(BA);
            dA.add(CA), o.addAbortListener(BA.signal, UA(CA));
          }
          return nA(sA, BA.signal, Q(this[D]));
        }
        [a.inspect.custom](sA, BA) {
          BA.depth === null && (BA.depth = 2), BA.colors ??= true;
          const dA = { method: this.method, url: this.url, headers: this.headers, destination: this.destination, referrer: this.referrer, referrerPolicy: this.referrerPolicy, mode: this.mode, credentials: this.credentials, cache: this.cache, redirect: this.redirect, integrity: this.integrity, keepalive: this.keepalive, isReloadNavigation: this.isReloadNavigation, isHistoryNavigation: this.isHistoryNavigation, signal: this.signal };
          return `Request ${a.formatWithOptions(BA, dA)}`;
        }
      }
      p(eA);
      function lA($2) {
        return { method: $2.method ?? "GET", localURLsOnly: $2.localURLsOnly ?? false, unsafeRequest: $2.unsafeRequest ?? false, body: $2.body ?? null, client: $2.client ?? null, reservedClient: $2.reservedClient ?? null, replacesClientId: $2.replacesClientId ?? "", window: $2.window ?? "client", keepalive: $2.keepalive ?? false, serviceWorkers: $2.serviceWorkers ?? "all", initiator: $2.initiator ?? "", destination: $2.destination ?? "", priority: $2.priority ?? null, origin: $2.origin ?? "client", policyContainer: $2.policyContainer ?? "client", referrer: $2.referrer ?? "client", referrerPolicy: $2.referrerPolicy ?? "", mode: $2.mode ?? "no-cors", useCORSPreflightFlag: $2.useCORSPreflightFlag ?? false, credentials: $2.credentials ?? "same-origin", useCredentials: $2.useCredentials ?? false, cache: $2.cache ?? "default", redirect: $2.redirect ?? "follow", integrity: $2.integrity ?? "", cryptoGraphicsNonceMetadata: $2.cryptoGraphicsNonceMetadata ?? "", parserMetadata: $2.parserMetadata ?? "", reloadNavigation: $2.reloadNavigation ?? false, historyNavigation: $2.historyNavigation ?? false, userActivation: $2.userActivation ?? false, taintedOrigin: $2.taintedOrigin ?? false, redirectCount: $2.redirectCount ?? 0, responseTainting: $2.responseTainting ?? "basic", preventNoCacheCacheControlHeaderModification: $2.preventNoCacheCacheControlHeaderModification ?? false, done: $2.done ?? false, timingAllowFailed: $2.timingAllowFailed ?? false, urlList: $2.urlList, url: $2.urlList[0], headersList: $2.headersList ? new f($2.headersList) : new f() };
      }
      e(lA, "makeRequest");
      function YA($2) {
        const sA = lA({ ...$2, body: null });
        return $2.body != null && (sA.body = c(sA, $2.body)), sA;
      }
      e(YA, "cloneRequest");
      function nA($2, sA, BA) {
        const dA = new eA(Z);
        return dA[W] = $2, dA[S] = sA, dA[D] = new t(Z), u(dA[D], $2.headersList), l(dA[D], BA), dA;
      }
      return e(nA, "fromInnerRequest"), Object.defineProperties(eA.prototype, { method: i, url: i, headers: i, redirect: i, clone: i, signal: i, duplex: i, destination: i, body: i, bodyUsed: i, isHistoryNavigation: i, isReloadNavigation: i, keepalive: i, integrity: i, cache: i, credentials: i, attribute: i, referrerPolicy: i, referrer: i, mode: i, [Symbol.toStringTag]: { value: "Request", configurable: true } }), O.converters.Request = O.interfaceConverter(eA), O.converters.RequestInfo = function($2, sA, BA) {
        return typeof $2 == "string" ? O.converters.USVString($2, sA, BA) : $2 instanceof eA ? O.converters.Request($2, sA, BA) : O.converters.USVString($2, sA, BA);
      }, O.converters.AbortSignal = O.interfaceConverter(AbortSignal), O.converters.RequestInit = O.dictionaryConverter([{ key: "method", converter: O.converters.ByteString }, { key: "headers", converter: O.converters.HeadersInit }, { key: "body", converter: O.nullableConverter(O.converters.BodyInit) }, { key: "referrer", converter: O.converters.USVString }, { key: "referrerPolicy", converter: O.converters.DOMString, allowedValues: J }, { key: "mode", converter: O.converters.DOMString, allowedValues: H }, { key: "credentials", converter: O.converters.DOMString, allowedValues: h }, { key: "cache", converter: O.converters.DOMString, allowedValues: I }, { key: "redirect", converter: O.converters.DOMString, allowedValues: V }, { key: "integrity", converter: O.converters.DOMString }, { key: "keepalive", converter: O.converters.boolean }, { key: "signal", converter: O.nullableConverter(($2) => O.converters.AbortSignal($2, "RequestInit", "signal", { strict: false })) }, { key: "window", converter: O.converters.any }, { key: "duplex", converter: O.converters.DOMString, allowedValues: k }, { key: "dispatcher", converter: O.converters.any }]), request = { Request: eA, makeRequest: lA, fromInnerRequest: nA, cloneRequest: YA }, request;
    }
    e(requireRequest, "requireRequest");
    var fetch_1;
    var hasRequiredFetch;
    function requireFetch() {
      if (hasRequiredFetch)
        return fetch_1;
      hasRequiredFetch = 1;
      const { makeNetworkError: A, makeAppropriateNetworkError: p, filterResponse: c, makeResponse: E, fromInnerResponse: t } = requireResponse(), { HeadersList: B } = requireHeaders(), { Request: f, cloneRequest: l } = requireRequest(), Q = zlib__default, { bytesMatch: u, makePolicyContainer: n, clonePolicyContainer: r, requestBadPort: o, TAOCheck: a, appendRequestOriginHeader: g, responseLocationURL: d, requestCurrentURL: N, setRequestReferrerPolicyOnRedirect: M, tryUpgradeRequestToAPotentiallyTrustworthyURL: Y, createOpaqueTimingInfo: J, appendFetchMetadata: V, corsCheck: H, crossOriginResourcePolicyCheck: h, determineRequestsReferrer: I, coarsenedSharedCurrentTime: k, createDeferredPromise: i, isBlobLike: F, sameOrigin: m, isCancelled: D, isAborted: S, isErrorLike: W, fullyReadBody: q, readableStreamClose: O, isomorphicEncode: P, urlIsLocal: Z, urlIsHttpHttpsScheme: cA, urlHasHttpsScheme: EA, clampAndCoarsenConnectionTimingInfo: fA, simpleRangeHeaderValue: uA, buildContentRange: pA, createInflate: RA, extractMimeType: DA } = requireUtil$6(), { kState: TA, kDispatcher: UA } = requireSymbols$3(), QA = require$$0__default, { safelyExtractBody: eA, extractBody: lA } = requireBody(), { redirectStatusSet: YA, nullBodyStatus: nA, safeMethodsSet: $2, requestBodyHeader: sA, subresourceSet: BA } = requireConstants$2(), dA = require$$8__default, { Readable: CA, pipeline: mA, finished: xA } = Stream__default, { addAbortListener: bA, isErrored: WA, isReadable: LA, bufferToLowerCasedHeaderName: GA } = requireUtil$7(), { dataURLProcessor: NA, serializeAMimeType: KA, minimizeSupportedMimeType: ZA } = requireDataUrl(), { getGlobalDispatcher: PA } = requireGlobal(), { webidl: oA } = requireWebidl(), { STATUS_CODES: L } = http__default, AA = ["GET", "HEAD"], IA = typeof __UNDICI_IS_NODE__ < "u" || typeof esbuildDetection < "u" ? "node" : "undici";
      let wA;
      class FA extends dA {
        static {
          e(this, "Fetch");
        }
        constructor(X) {
          super(), this.dispatcher = X, this.connection = null, this.dump = false, this.state = "ongoing";
        }
        terminate(X) {
          this.state === "ongoing" && (this.state = "terminated", this.connection?.destroy(X), this.emit("terminated", X));
        }
        abort(X) {
          this.state === "ongoing" && (this.state = "aborted", X || (X = new DOMException("The operation was aborted.", "AbortError")), this.serializedAbortReason = X, this.connection?.destroy(X), this.emit("terminated", X));
        }
      }
      function MA(T) {
        _A(T, "fetch");
      }
      e(MA, "handleFetchDone");
      function OA(T, X = void 0) {
        oA.argumentLengthCheck(arguments, 1, "globalThis.fetch");
        let K = i(), _;
        try {
          _ = new f(T, X);
        } catch (zA) {
          return K.reject(zA), K.promise;
        }
        const gA = _[TA];
        if (_.signal.aborted)
          return kA(K, gA, null, _.signal.reason), K.promise;
        gA.client.globalObject?.constructor?.name === "ServiceWorkerGlobalScope" && (gA.serviceWorkers = "none");
        let hA = null, JA = false, qA = null;
        return bA(_.signal, () => {
          JA = true, QA(qA != null), qA.abort(_.signal.reason);
          const zA = hA?.deref();
          kA(K, gA, zA, _.signal.reason);
        }), qA = z({ request: gA, processResponseEndOfBody: MA, processResponse: e((zA) => {
          if (!JA) {
            if (zA.aborted) {
              kA(K, gA, hA, qA.serializedAbortReason);
              return;
            }
            if (zA.type === "error") {
              K.reject(new TypeError("fetch failed", { cause: zA.error }));
              return;
            }
            hA = new WeakRef(t(zA, "immutable")), K.resolve(hA.deref()), K = null;
          }
        }, "processResponse"), dispatcher: _[UA] }), K.promise;
      }
      e(OA, "fetch");
      function _A(T, X = "other") {
        if (T.type === "error" && T.aborted || !T.urlList?.length)
          return;
        const K = T.urlList[0];
        let _ = T.timingInfo, gA = T.cacheState;
        cA(K) && _ !== null && (T.timingAllowPassed || (_ = J({ startTime: _.startTime }), gA = ""), _.endTime = k(), T.timingInfo = _, $A(_, K.href, X, globalThis, gA));
      }
      e(_A, "finalizeAndReportTiming");
      const $A = performance.markResourceTiming;
      function kA(T, X, K, _) {
        if (T && T.reject(_), X.body != null && LA(X.body?.stream) && X.body.stream.cancel(_).catch((tA) => {
          if (tA.code !== "ERR_INVALID_STATE")
            throw tA;
        }), K == null)
          return;
        const gA = K[TA];
        gA.body != null && LA(gA.body?.stream) && gA.body.stream.cancel(_).catch((tA) => {
          if (tA.code !== "ERR_INVALID_STATE")
            throw tA;
        });
      }
      e(kA, "abortFetch");
      function z({ request: T, processRequestBodyChunkLength: X, processRequestEndOfBody: K, processResponse: _, processResponseEndOfBody: gA, processResponseConsumeBody: tA, useParallelQueue: hA = false, dispatcher: JA = PA() }) {
        QA(JA);
        let qA = null, VA = false;
        T.client != null && (qA = T.client.globalObject, VA = T.client.crossOriginIsolatedCapability);
        const zA = k(VA), ne = J({ startTime: zA }), HA = { controller: new FA(JA), request: T, timingInfo: ne, processRequestBodyChunkLength: X, processRequestEndOfBody: K, processResponse: _, processResponseConsumeBody: tA, processResponseEndOfBody: gA, taskDestination: qA, crossOriginIsolatedCapability: VA };
        return QA(!T.body || T.body.stream), T.window === "client" && (T.window = T.client?.globalObject?.constructor?.name === "Window" ? T.client : "no-window"), T.origin === "client" && (T.origin = T.client.origin), T.policyContainer === "client" && (T.client != null ? T.policyContainer = r(T.client.policyContainer) : T.policyContainer = n()), T.headersList.contains("accept", true) || T.headersList.append("accept", "*/*", true), T.headersList.contains("accept-language", true) || T.headersList.append("accept-language", "*", true), T.priority, BA.has(T.destination), iA(HA).catch((Ae) => {
          HA.controller.terminate(Ae);
        }), HA.controller;
      }
      e(z, "fetching");
      async function iA(T, X = false) {
        const K = T.request;
        let _ = null;
        if (K.localURLsOnly && !Z(N(K)) && (_ = A("local URLs only")), Y(K), o(K) === "blocked" && (_ = A("bad port")), K.referrerPolicy === "" && (K.referrerPolicy = K.policyContainer.referrerPolicy), K.referrer !== "no-referrer" && (K.referrer = I(K)), _ === null && (_ = await (async () => {
          const tA = N(K);
          return m(tA, K.url) && K.responseTainting === "basic" || tA.protocol === "data:" || K.mode === "navigate" || K.mode === "websocket" ? (K.responseTainting = "basic", await rA(T)) : K.mode === "same-origin" ? A('request mode cannot be "same-origin"') : K.mode === "no-cors" ? K.redirect !== "follow" ? A('redirect mode cannot be "follow" for "no-cors" request') : (K.responseTainting = "opaque", await rA(T)) : cA(N(K)) ? (K.responseTainting = "cors", await SA(T)) : A("URL scheme must be a HTTP(S) scheme");
        })()), X)
          return _;
        _.status !== 0 && !_.internalResponse && (K.responseTainting, K.responseTainting === "basic" ? _ = c(_, "basic") : K.responseTainting === "cors" ? _ = c(_, "cors") : K.responseTainting === "opaque" ? _ = c(_, "opaque") : QA(false));
        let gA = _.status === 0 ? _ : _.internalResponse;
        if (gA.urlList.length === 0 && gA.urlList.push(...K.urlList), K.timingAllowFailed || (_.timingAllowPassed = true), _.type === "opaque" && gA.status === 206 && gA.rangeRequested && !K.headers.contains("range", true) && (_ = gA = A()), _.status !== 0 && (K.method === "HEAD" || K.method === "CONNECT" || nA.includes(gA.status)) && (gA.body = null, T.controller.dump = true), K.integrity) {
          const tA = e((JA) => yA(T, A(JA)), "processBodyError");
          if (K.responseTainting === "opaque" || _.body == null) {
            tA(_.error);
            return;
          }
          const hA = e((JA) => {
            if (!u(JA, K.integrity)) {
              tA("integrity mismatch");
              return;
            }
            _.body = eA(JA)[0], yA(T, _);
          }, "processBody");
          await q(_.body, hA, tA);
        } else
          yA(T, _);
      }
      e(iA, "mainFetch");
      function rA(T) {
        if (D(T) && T.request.redirectCount === 0)
          return Promise.resolve(p(T));
        const { request: X } = T, { protocol: K } = N(X);
        switch (K) {
          case "about:":
            return Promise.resolve(A("about scheme is not supported"));
          case "blob:": {
            wA || (wA = require$$0__default$2.resolveObjectURL);
            const _ = N(X);
            if (_.search.length !== 0)
              return Promise.resolve(A("NetworkError when attempting to fetch resource."));
            const gA = wA(_.toString());
            if (X.method !== "GET" || !F(gA))
              return Promise.resolve(A("invalid method"));
            const tA = E(), hA = gA.size, JA = P(`${hA}`), qA = gA.type;
            if (X.headersList.contains("range", true)) {
              tA.rangeRequested = true;
              const VA = X.headersList.get("range", true), zA = uA(VA, true);
              if (zA === "failure")
                return Promise.resolve(A("failed to fetch the data URL"));
              let { rangeStartValue: ne, rangeEndValue: HA } = zA;
              if (ne === null)
                ne = hA - HA, HA = ne + HA - 1;
              else {
                if (ne >= hA)
                  return Promise.resolve(A("Range start is greater than the blob's size."));
                (HA === null || HA >= hA) && (HA = hA - 1);
              }
              const Ae = gA.slice(ne, HA, qA), re = lA(Ae);
              tA.body = re[0];
              const XA = P(`${Ae.size}`), oe = pA(ne, HA, hA);
              tA.status = 206, tA.statusText = "Partial Content", tA.headersList.set("content-length", XA, true), tA.headersList.set("content-type", qA, true), tA.headersList.set("content-range", oe, true);
            } else {
              const VA = lA(gA);
              tA.statusText = "OK", tA.body = VA[0], tA.headersList.set("content-length", JA, true), tA.headersList.set("content-type", qA, true);
            }
            return Promise.resolve(tA);
          }
          case "data:": {
            const _ = N(X), gA = NA(_);
            if (gA === "failure")
              return Promise.resolve(A("failed to fetch the data URL"));
            const tA = KA(gA.mimeType);
            return Promise.resolve(E({ statusText: "OK", headersList: [["content-type", { name: "Content-Type", value: tA }]], body: eA(gA.body)[0] }));
          }
          case "file:":
            return Promise.resolve(A("not implemented... yet..."));
          case "http:":
          case "https:":
            return SA(T).catch((_) => A(_));
          default:
            return Promise.resolve(A("unknown scheme"));
        }
      }
      e(rA, "schemeFetch");
      function aA(T, X) {
        T.request.done = true, T.processResponseDone != null && queueMicrotask(() => T.processResponseDone(X));
      }
      e(aA, "finalizeResponse");
      function yA(T, X) {
        let K = T.timingInfo;
        const _ = e(() => {
          const tA = Date.now();
          T.request.destination === "document" && (T.controller.fullTimingInfo = K), T.controller.reportTimingSteps = () => {
            if (T.request.url.protocol !== "https:")
              return;
            K.endTime = tA;
            let JA = X.cacheState;
            const qA = X.bodyInfo;
            X.timingAllowPassed || (K = J(K), JA = "");
            let VA = 0;
            if (T.request.mode !== "navigator" || !X.hasCrossOriginRedirects) {
              VA = X.status;
              const zA = DA(X.headersList);
              zA !== "failure" && (qA.contentType = ZA(zA));
            }
            T.request.initiatorType != null && $A(K, T.request.url.href, T.request.initiatorType, globalThis, JA, qA, VA);
          };
          const hA = e(() => {
            T.request.done = true, T.processResponseEndOfBody != null && queueMicrotask(() => T.processResponseEndOfBody(X)), T.request.initiatorType != null && T.controller.reportTimingSteps();
          }, "processResponseEndOfBodyTask");
          queueMicrotask(() => hA());
        }, "processResponseEndOfBody");
        T.processResponse != null && queueMicrotask(() => {
          T.processResponse(X), T.processResponse = null;
        });
        const gA = X.type === "error" ? X : X.internalResponse ?? X;
        gA.body == null ? _() : xA(gA.body.stream, () => {
          _();
        });
      }
      e(yA, "fetchFinale");
      async function SA(T) {
        const X = T.request;
        let K = null, _ = null;
        const gA = T.timingInfo;
        if (X.serviceWorkers, K === null) {
          if (X.redirect === "follow" && (X.serviceWorkers = "none"), _ = K = await G(T), X.responseTainting === "cors" && H(X, K) === "failure")
            return A("cors failure");
          a(X, K) === "failure" && (X.timingAllowFailed = true);
        }
        return (X.responseTainting === "opaque" || K.type === "opaque") && h(X.origin, X.client, X.destination, _) === "blocked" ? A("blocked") : (YA.has(_.status) && (X.redirect !== "manual" && T.controller.connection.destroy(void 0, false), X.redirect === "error" ? K = A("unexpected redirect") : X.redirect === "manual" ? K = _ : X.redirect === "follow" ? K = await vA(T, K) : QA(false)), K.timingInfo = gA, K);
      }
      e(SA, "httpFetch");
      function vA(T, X) {
        const K = T.request, _ = X.internalResponse ? X.internalResponse : X;
        let gA;
        try {
          if (gA = d(_, N(K).hash), gA == null)
            return X;
        } catch (hA) {
          return Promise.resolve(A(hA));
        }
        if (!cA(gA))
          return Promise.resolve(A("URL scheme must be a HTTP(S) scheme"));
        if (K.redirectCount === 20)
          return Promise.resolve(A("redirect count exceeded"));
        if (K.redirectCount += 1, K.mode === "cors" && (gA.username || gA.password) && !m(K, gA))
          return Promise.resolve(A('cross origin not allowed for request mode "cors"'));
        if (K.responseTainting === "cors" && (gA.username || gA.password))
          return Promise.resolve(A('URL cannot contain credentials for request mode "cors"'));
        if (_.status !== 303 && K.body != null && K.body.source == null)
          return Promise.resolve(A());
        if ([301, 302].includes(_.status) && K.method === "POST" || _.status === 303 && !AA.includes(K.method)) {
          K.method = "GET", K.body = null;
          for (const hA of sA)
            K.headersList.delete(hA);
        }
        m(N(K), gA) || (K.headersList.delete("authorization", true), K.headersList.delete("proxy-authorization", true), K.headersList.delete("cookie", true), K.headersList.delete("host", true)), K.body != null && (QA(K.body.source != null), K.body = eA(K.body.source)[0]);
        const tA = T.timingInfo;
        return tA.redirectEndTime = tA.postRedirectStartTime = k(T.crossOriginIsolatedCapability), tA.redirectStartTime === 0 && (tA.redirectStartTime = tA.startTime), K.urlList.push(gA), M(K, _), iA(T, true);
      }
      e(vA, "httpRedirectFetch");
      async function G(T, X = false, K = false) {
        const _ = T.request;
        let gA = null, tA = null, hA = null;
        _.window === "no-window" && _.redirect === "error" ? (gA = T, tA = _) : (tA = l(_), gA = { ...T }, gA.request = tA);
        const JA = _.credentials === "include" || _.credentials === "same-origin" && _.responseTainting === "basic", qA = tA.body ? tA.body.length : null;
        let VA = null;
        if (tA.body == null && ["POST", "PUT"].includes(tA.method) && (VA = "0"), qA != null && (VA = P(`${qA}`)), VA != null && tA.headersList.append("content-length", VA, true), qA != null && tA.keepalive, tA.referrer instanceof URL && tA.headersList.append("referer", P(tA.referrer.href), true), g(tA), V(tA), tA.headersList.contains("user-agent", true) || tA.headersList.append("user-agent", IA), tA.cache === "default" && (tA.headersList.contains("if-modified-since", true) || tA.headersList.contains("if-none-match", true) || tA.headersList.contains("if-unmodified-since", true) || tA.headersList.contains("if-match", true) || tA.headersList.contains("if-range", true)) && (tA.cache = "no-store"), tA.cache === "no-cache" && !tA.preventNoCacheCacheControlHeaderModification && !tA.headersList.contains("cache-control", true) && tA.headersList.append("cache-control", "max-age=0", true), (tA.cache === "no-store" || tA.cache === "reload") && (tA.headersList.contains("pragma", true) || tA.headersList.append("pragma", "no-cache", true), tA.headersList.contains("cache-control", true) || tA.headersList.append("cache-control", "no-cache", true)), tA.headersList.contains("range", true) && tA.headersList.append("accept-encoding", "identity", true), tA.headersList.contains("accept-encoding", true) || (EA(N(tA)) ? tA.headersList.append("accept-encoding", "br, gzip, deflate", true) : tA.headersList.append("accept-encoding", "gzip, deflate", true)), tA.headersList.delete("host", true), tA.cache = "no-store", tA.cache !== "no-store" && tA.cache, hA == null) {
          if (tA.cache === "only-if-cached")
            return A("only if cached");
          const zA = await j(gA, JA, K);
          !$2.has(tA.method) && zA.status >= 200 && zA.status <= 399, hA == null && (hA = zA);
        }
        if (hA.urlList = [...tA.urlList], tA.headersList.contains("range", true) && (hA.rangeRequested = true), hA.requestIncludesCredentials = JA, hA.status === 407)
          return _.window === "no-window" ? A() : D(T) ? p(T) : A("proxy authentication required");
        if (hA.status === 421 && !K && (_.body == null || _.body.source != null)) {
          if (D(T))
            return p(T);
          T.controller.connection.destroy(), hA = await G(T, X, true);
        }
        return hA;
      }
      e(G, "httpNetworkOrCacheFetch");
      async function j(T, X = false, K = false) {
        QA(!T.controller.connection || T.controller.connection.destroyed), T.controller.connection = { abort: null, destroyed: false, destroy(HA, Ae = true) {
          this.destroyed || (this.destroyed = true, Ae && this.abort?.(HA ?? new DOMException("The operation was aborted.", "AbortError")));
        } };
        const _ = T.request;
        let gA = null;
        const tA = T.timingInfo;
        _.cache = "no-store", _.mode;
        let hA = null;
        if (_.body == null && T.processRequestEndOfBody)
          queueMicrotask(() => T.processRequestEndOfBody());
        else if (_.body != null) {
          const HA = e(async function* (XA) {
            D(T) || (yield XA, T.processRequestBodyChunkLength?.(XA.byteLength));
          }, "processBodyChunk"), Ae = e(() => {
            D(T) || T.processRequestEndOfBody && T.processRequestEndOfBody();
          }, "processEndOfBody"), re = e((XA) => {
            D(T) || (XA.name === "AbortError" ? T.controller.abort() : T.controller.terminate(XA));
          }, "processBodyError");
          hA = async function* () {
            try {
              for await (const XA of _.body.stream)
                yield* HA(XA);
              Ae();
            } catch (XA) {
              re(XA);
            }
          }();
        }
        try {
          const { body: HA, status: Ae, statusText: re, headersList: XA, socket: oe } = await ne({ body: hA });
          if (oe)
            gA = E({ status: Ae, statusText: re, headersList: XA, socket: oe });
          else {
            const jA = HA[Symbol.asyncIterator]();
            T.controller.next = () => jA.next(), gA = E({ status: Ae, statusText: re, headersList: XA });
          }
        } catch (HA) {
          return HA.name === "AbortError" ? (T.controller.connection.destroy(), p(T, HA)) : A(HA);
        }
        const JA = e(async () => {
          await T.controller.resume();
        }, "pullAlgorithm"), qA = e((HA) => {
          D(T) || T.controller.abort(HA);
        }, "cancelAlgorithm"), VA = new ReadableStream({ async start(HA) {
          T.controller.controller = HA;
        }, async pull(HA) {
          await JA();
        }, async cancel(HA) {
          await qA(HA);
        }, type: "bytes" });
        gA.body = { stream: VA, source: null, length: null }, T.controller.onAborted = zA, T.controller.on("terminated", zA), T.controller.resume = async () => {
          for (; ; ) {
            let HA, Ae;
            try {
              const { done: XA, value: oe } = await T.controller.next();
              if (S(T))
                break;
              HA = XA ? void 0 : oe;
            } catch (XA) {
              T.controller.ended && !tA.encodedBodySize ? HA = void 0 : (HA = XA, Ae = true);
            }
            if (HA === void 0) {
              O(T.controller.controller), aA(T, gA);
              return;
            }
            if (tA.decodedBodySize += HA?.byteLength ?? 0, Ae) {
              T.controller.terminate(HA);
              return;
            }
            const re = new Uint8Array(HA);
            if (re.byteLength && T.controller.controller.enqueue(re), WA(VA)) {
              T.controller.terminate();
              return;
            }
            if (T.controller.controller.desiredSize <= 0)
              return;
          }
        };
        function zA(HA) {
          S(T) ? (gA.aborted = true, LA(VA) && T.controller.controller.error(T.controller.serializedAbortReason)) : LA(VA) && T.controller.controller.error(new TypeError("terminated", { cause: W(HA) ? HA : void 0 })), T.controller.connection.destroy();
        }
        return e(zA, "onAborted"), gA;
        function ne({ body: HA }) {
          const Ae = N(_), re = T.controller.dispatcher;
          return new Promise((XA, oe) => re.dispatch({ path: Ae.pathname + Ae.search, origin: Ae.origin, method: _.method, body: re.isMockActive ? _.body && (_.body.source || _.body.stream) : HA, headers: _.headersList.entries, maxRedirections: 0, upgrade: _.mode === "websocket" ? "websocket" : void 0 }, { body: null, abort: null, onConnect(jA) {
            const { connection: ee } = T.controller;
            tA.finalConnectionTimingInfo = fA(void 0, tA.postRedirectStartTime, T.crossOriginIsolatedCapability), ee.destroyed ? jA(new DOMException("The operation was aborted.", "AbortError")) : (T.controller.on("terminated", jA), this.abort = ee.abort = jA), tA.finalNetworkRequestStartTime = k(T.crossOriginIsolatedCapability);
          }, onResponseStarted() {
            tA.finalNetworkResponseStartTime = k(T.crossOriginIsolatedCapability);
          }, onHeaders(jA, ee, ce, ae) {
            if (jA < 200)
              return;
            let se = [], Be = "";
            const ge = new B();
            for (let te = 0; te < ee.length; te += 2)
              ge.append(GA(ee[te]), ee[te + 1].toString("latin1"), true);
            const Ee = ge.get("content-encoding", true);
            Ee && (se = Ee.toLowerCase().split(",").map((te) => te.trim())), Be = ge.get("location", true), this.body = new CA({ read: ce });
            const ie = [], Ie = Be && _.redirect === "follow" && YA.has(jA);
            if (se.length !== 0 && _.method !== "HEAD" && _.method !== "CONNECT" && !nA.includes(jA) && !Ie)
              for (let te = se.length - 1; te >= 0; --te) {
                const Qe = se[te];
                if (Qe === "x-gzip" || Qe === "gzip")
                  ie.push(Q.createGunzip({ flush: Q.constants.Z_SYNC_FLUSH, finishFlush: Q.constants.Z_SYNC_FLUSH }));
                else if (Qe === "deflate")
                  ie.push(RA({ flush: Q.constants.Z_SYNC_FLUSH, finishFlush: Q.constants.Z_SYNC_FLUSH }));
                else if (Qe === "br")
                  ie.push(Q.createBrotliDecompress({ flush: Q.constants.BROTLI_OPERATION_FLUSH, finishFlush: Q.constants.BROTLI_OPERATION_FLUSH }));
                else {
                  ie.length = 0;
                  break;
                }
              }
            const Ce = this.onError.bind(this);
            return XA({ status: jA, statusText: ae, headersList: ge, body: ie.length ? mA(this.body, ...ie, (te) => {
              te && this.onError(te);
            }).on("error", Ce) : this.body.on("error", Ce) }), true;
          }, onData(jA) {
            if (T.controller.dump)
              return;
            const ee = jA;
            return tA.encodedBodySize += ee.byteLength, this.body.push(ee);
          }, onComplete() {
            this.abort && T.controller.off("terminated", this.abort), T.controller.onAborted && T.controller.off("terminated", T.controller.onAborted), T.controller.ended = true, this.body.push(null);
          }, onError(jA) {
            this.abort && T.controller.off("terminated", this.abort), this.body?.destroy(jA), T.controller.terminate(jA), oe(jA);
          }, onUpgrade(jA, ee, ce) {
            if (jA !== 101)
              return;
            const ae = new B();
            for (let se = 0; se < ee.length; se += 2)
              ae.append(GA(ee[se]), ee[se + 1].toString("latin1"), true);
            return XA({ status: jA, statusText: L[jA], headersList: ae, socket: ce }), true;
          } }));
        }
        e(ne, "dispatch");
      }
      return e(j, "httpNetworkFetch"), fetch_1 = { fetch: OA, Fetch: FA, fetching: z, finalizeAndReportTiming: _A }, fetch_1;
    }
    e(requireFetch, "requireFetch");
    var symbols$2;
    var hasRequiredSymbols$2;
    function requireSymbols$2() {
      return hasRequiredSymbols$2 || (hasRequiredSymbols$2 = 1, symbols$2 = { kState: Symbol("FileReader state"), kResult: Symbol("FileReader result"), kError: Symbol("FileReader error"), kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"), kEvents: Symbol("FileReader events"), kAborted: Symbol("FileReader aborted") }), symbols$2;
    }
    e(requireSymbols$2, "requireSymbols$2");
    var progressevent;
    var hasRequiredProgressevent;
    function requireProgressevent() {
      if (hasRequiredProgressevent)
        return progressevent;
      hasRequiredProgressevent = 1;
      const { webidl: A } = requireWebidl(), p = Symbol("ProgressEvent state");
      class c extends Event {
        static {
          e(this, "ProgressEvent");
        }
        constructor(t, B = {}) {
          t = A.converters.DOMString(t, "ProgressEvent constructor", "type"), B = A.converters.ProgressEventInit(B ?? {}), super(t, B), this[p] = { lengthComputable: B.lengthComputable, loaded: B.loaded, total: B.total };
        }
        get lengthComputable() {
          return A.brandCheck(this, c), this[p].lengthComputable;
        }
        get loaded() {
          return A.brandCheck(this, c), this[p].loaded;
        }
        get total() {
          return A.brandCheck(this, c), this[p].total;
        }
      }
      return A.converters.ProgressEventInit = A.dictionaryConverter([{ key: "lengthComputable", converter: A.converters.boolean, defaultValue: e(() => false, "defaultValue") }, { key: "loaded", converter: A.converters["unsigned long long"], defaultValue: e(() => 0, "defaultValue") }, { key: "total", converter: A.converters["unsigned long long"], defaultValue: e(() => 0, "defaultValue") }, { key: "bubbles", converter: A.converters.boolean, defaultValue: e(() => false, "defaultValue") }, { key: "cancelable", converter: A.converters.boolean, defaultValue: e(() => false, "defaultValue") }, { key: "composed", converter: A.converters.boolean, defaultValue: e(() => false, "defaultValue") }]), progressevent = { ProgressEvent: c }, progressevent;
    }
    e(requireProgressevent, "requireProgressevent");
    var encoding;
    var hasRequiredEncoding;
    function requireEncoding() {
      if (hasRequiredEncoding)
        return encoding;
      hasRequiredEncoding = 1;
      function A(p) {
        if (!p)
          return "failure";
        switch (p.trim().toLowerCase()) {
          case "unicode-1-1-utf-8":
          case "unicode11utf8":
          case "unicode20utf8":
          case "utf-8":
          case "utf8":
          case "x-unicode20utf8":
            return "UTF-8";
          case "866":
          case "cp866":
          case "csibm866":
          case "ibm866":
            return "IBM866";
          case "csisolatin2":
          case "iso-8859-2":
          case "iso-ir-101":
          case "iso8859-2":
          case "iso88592":
          case "iso_8859-2":
          case "iso_8859-2:1987":
          case "l2":
          case "latin2":
            return "ISO-8859-2";
          case "csisolatin3":
          case "iso-8859-3":
          case "iso-ir-109":
          case "iso8859-3":
          case "iso88593":
          case "iso_8859-3":
          case "iso_8859-3:1988":
          case "l3":
          case "latin3":
            return "ISO-8859-3";
          case "csisolatin4":
          case "iso-8859-4":
          case "iso-ir-110":
          case "iso8859-4":
          case "iso88594":
          case "iso_8859-4":
          case "iso_8859-4:1988":
          case "l4":
          case "latin4":
            return "ISO-8859-4";
          case "csisolatincyrillic":
          case "cyrillic":
          case "iso-8859-5":
          case "iso-ir-144":
          case "iso8859-5":
          case "iso88595":
          case "iso_8859-5":
          case "iso_8859-5:1988":
            return "ISO-8859-5";
          case "arabic":
          case "asmo-708":
          case "csiso88596e":
          case "csiso88596i":
          case "csisolatinarabic":
          case "ecma-114":
          case "iso-8859-6":
          case "iso-8859-6-e":
          case "iso-8859-6-i":
          case "iso-ir-127":
          case "iso8859-6":
          case "iso88596":
          case "iso_8859-6":
          case "iso_8859-6:1987":
            return "ISO-8859-6";
          case "csisolatingreek":
          case "ecma-118":
          case "elot_928":
          case "greek":
          case "greek8":
          case "iso-8859-7":
          case "iso-ir-126":
          case "iso8859-7":
          case "iso88597":
          case "iso_8859-7":
          case "iso_8859-7:1987":
          case "sun_eu_greek":
            return "ISO-8859-7";
          case "csiso88598e":
          case "csisolatinhebrew":
          case "hebrew":
          case "iso-8859-8":
          case "iso-8859-8-e":
          case "iso-ir-138":
          case "iso8859-8":
          case "iso88598":
          case "iso_8859-8":
          case "iso_8859-8:1988":
          case "visual":
            return "ISO-8859-8";
          case "csiso88598i":
          case "iso-8859-8-i":
          case "logical":
            return "ISO-8859-8-I";
          case "csisolatin6":
          case "iso-8859-10":
          case "iso-ir-157":
          case "iso8859-10":
          case "iso885910":
          case "l6":
          case "latin6":
            return "ISO-8859-10";
          case "iso-8859-13":
          case "iso8859-13":
          case "iso885913":
            return "ISO-8859-13";
          case "iso-8859-14":
          case "iso8859-14":
          case "iso885914":
            return "ISO-8859-14";
          case "csisolatin9":
          case "iso-8859-15":
          case "iso8859-15":
          case "iso885915":
          case "iso_8859-15":
          case "l9":
            return "ISO-8859-15";
          case "iso-8859-16":
            return "ISO-8859-16";
          case "cskoi8r":
          case "koi":
          case "koi8":
          case "koi8-r":
          case "koi8_r":
            return "KOI8-R";
          case "koi8-ru":
          case "koi8-u":
            return "KOI8-U";
          case "csmacintosh":
          case "mac":
          case "macintosh":
          case "x-mac-roman":
            return "macintosh";
          case "iso-8859-11":
          case "iso8859-11":
          case "iso885911":
          case "tis-620":
          case "windows-874":
            return "windows-874";
          case "cp1250":
          case "windows-1250":
          case "x-cp1250":
            return "windows-1250";
          case "cp1251":
          case "windows-1251":
          case "x-cp1251":
            return "windows-1251";
          case "ansi_x3.4-1968":
          case "ascii":
          case "cp1252":
          case "cp819":
          case "csisolatin1":
          case "ibm819":
          case "iso-8859-1":
          case "iso-ir-100":
          case "iso8859-1":
          case "iso88591":
          case "iso_8859-1":
          case "iso_8859-1:1987":
          case "l1":
          case "latin1":
          case "us-ascii":
          case "windows-1252":
          case "x-cp1252":
            return "windows-1252";
          case "cp1253":
          case "windows-1253":
          case "x-cp1253":
            return "windows-1253";
          case "cp1254":
          case "csisolatin5":
          case "iso-8859-9":
          case "iso-ir-148":
          case "iso8859-9":
          case "iso88599":
          case "iso_8859-9":
          case "iso_8859-9:1989":
          case "l5":
          case "latin5":
          case "windows-1254":
          case "x-cp1254":
            return "windows-1254";
          case "cp1255":
          case "windows-1255":
          case "x-cp1255":
            return "windows-1255";
          case "cp1256":
          case "windows-1256":
          case "x-cp1256":
            return "windows-1256";
          case "cp1257":
          case "windows-1257":
          case "x-cp1257":
            return "windows-1257";
          case "cp1258":
          case "windows-1258":
          case "x-cp1258":
            return "windows-1258";
          case "x-mac-cyrillic":
          case "x-mac-ukrainian":
            return "x-mac-cyrillic";
          case "chinese":
          case "csgb2312":
          case "csiso58gb231280":
          case "gb2312":
          case "gb_2312":
          case "gb_2312-80":
          case "gbk":
          case "iso-ir-58":
          case "x-gbk":
            return "GBK";
          case "gb18030":
            return "gb18030";
          case "big5":
          case "big5-hkscs":
          case "cn-big5":
          case "csbig5":
          case "x-x-big5":
            return "Big5";
          case "cseucpkdfmtjapanese":
          case "euc-jp":
          case "x-euc-jp":
            return "EUC-JP";
          case "csiso2022jp":
          case "iso-2022-jp":
            return "ISO-2022-JP";
          case "csshiftjis":
          case "ms932":
          case "ms_kanji":
          case "shift-jis":
          case "shift_jis":
          case "sjis":
          case "windows-31j":
          case "x-sjis":
            return "Shift_JIS";
          case "cseuckr":
          case "csksc56011987":
          case "euc-kr":
          case "iso-ir-149":
          case "korean":
          case "ks_c_5601-1987":
          case "ks_c_5601-1989":
          case "ksc5601":
          case "ksc_5601":
          case "windows-949":
            return "EUC-KR";
          case "csiso2022kr":
          case "hz-gb-2312":
          case "iso-2022-cn":
          case "iso-2022-cn-ext":
          case "iso-2022-kr":
          case "replacement":
            return "replacement";
          case "unicodefffe":
          case "utf-16be":
            return "UTF-16BE";
          case "csunicode":
          case "iso-10646-ucs-2":
          case "ucs-2":
          case "unicode":
          case "unicodefeff":
          case "utf-16":
          case "utf-16le":
            return "UTF-16LE";
          case "x-user-defined":
            return "x-user-defined";
          default:
            return "failure";
        }
      }
      return e(A, "getEncoding"), encoding = { getEncoding: A }, encoding;
    }
    e(requireEncoding, "requireEncoding");
    var util$4;
    var hasRequiredUtil$4;
    function requireUtil$4() {
      if (hasRequiredUtil$4)
        return util$4;
      hasRequiredUtil$4 = 1;
      const { kState: A, kError: p, kResult: c, kAborted: E, kLastProgressEventFired: t } = requireSymbols$2(), { ProgressEvent: B } = requireProgressevent(), { getEncoding: f } = requireEncoding(), { serializeAMimeType: l, parseMIMEType: Q } = requireDataUrl(), { types: u } = require$$0__default$3, { StringDecoder: n } = require$$5__default$3, { btoa: r } = require$$0__default$2, o = { enumerable: true, writable: false, configurable: false };
      function a(J, V, H, h) {
        if (J[A] === "loading")
          throw new DOMException("Invalid state", "InvalidStateError");
        J[A] = "loading", J[c] = null, J[p] = null;
        const k = V.stream().getReader(), i = [];
        let F = k.read(), m = true;
        (async () => {
          for (; !J[E]; )
            try {
              const { done: D, value: S } = await F;
              if (m && !J[E] && queueMicrotask(() => {
                g("loadstart", J);
              }), m = false, !D && u.isUint8Array(S))
                i.push(S), (J[t] === void 0 || Date.now() - J[t] >= 50) && !J[E] && (J[t] = Date.now(), queueMicrotask(() => {
                  g("progress", J);
                })), F = k.read();
              else if (D) {
                queueMicrotask(() => {
                  J[A] = "done";
                  try {
                    const W = d(i, H, V.type, h);
                    if (J[E])
                      return;
                    J[c] = W, g("load", J);
                  } catch (W) {
                    J[p] = W, g("error", J);
                  }
                  J[A] !== "loading" && g("loadend", J);
                });
                break;
              }
            } catch (D) {
              if (J[E])
                return;
              queueMicrotask(() => {
                J[A] = "done", J[p] = D, g("error", J), J[A] !== "loading" && g("loadend", J);
              });
              break;
            }
        })();
      }
      e(a, "readOperation");
      function g(J, V) {
        const H = new B(J, { bubbles: false, cancelable: false });
        V.dispatchEvent(H);
      }
      e(g, "fireAProgressEvent");
      function d(J, V, H, h) {
        switch (V) {
          case "DataURL": {
            let I = "data:";
            const k = Q(H || "application/octet-stream");
            k !== "failure" && (I += l(k)), I += ";base64,";
            const i = new n("latin1");
            for (const F of J)
              I += r(i.write(F));
            return I += r(i.end()), I;
          }
          case "Text": {
            let I = "failure";
            if (h && (I = f(h)), I === "failure" && H) {
              const k = Q(H);
              k !== "failure" && (I = f(k.parameters.get("charset")));
            }
            return I === "failure" && (I = "UTF-8"), N(J, I);
          }
          case "ArrayBuffer":
            return Y(J).buffer;
          case "BinaryString": {
            let I = "";
            const k = new n("latin1");
            for (const i of J)
              I += k.write(i);
            return I += k.end(), I;
          }
        }
      }
      e(d, "packageData");
      function N(J, V) {
        const H = Y(J), h = M(H);
        let I = 0;
        h !== null && (V = h, I = h === "UTF-8" ? 3 : 2);
        const k = H.slice(I);
        return new TextDecoder(V).decode(k);
      }
      e(N, "decode");
      function M(J) {
        const [V, H, h] = J;
        return V === 239 && H === 187 && h === 191 ? "UTF-8" : V === 254 && H === 255 ? "UTF-16BE" : V === 255 && H === 254 ? "UTF-16LE" : null;
      }
      e(M, "BOMSniffing");
      function Y(J) {
        const V = J.reduce((h, I) => h + I.byteLength, 0);
        let H = 0;
        return J.reduce((h, I) => (h.set(I, H), H += I.byteLength, h), new Uint8Array(V));
      }
      return e(Y, "combineByteSequences"), util$4 = { staticPropertyDescriptors: o, readOperation: a, fireAProgressEvent: g }, util$4;
    }
    e(requireUtil$4, "requireUtil$4");
    var filereader;
    var hasRequiredFilereader;
    function requireFilereader() {
      if (hasRequiredFilereader)
        return filereader;
      hasRequiredFilereader = 1;
      const { staticPropertyDescriptors: A, readOperation: p, fireAProgressEvent: c } = requireUtil$4(), { kState: E, kError: t, kResult: B, kEvents: f, kAborted: l } = requireSymbols$2(), { webidl: Q } = requireWebidl(), { kEnumerableProperty: u } = requireUtil$7();
      class n extends EventTarget {
        static {
          e(this, "FileReader");
        }
        constructor() {
          super(), this[E] = "empty", this[B] = null, this[t] = null, this[f] = { loadend: null, error: null, abort: null, load: null, progress: null, loadstart: null };
        }
        readAsArrayBuffer(o) {
          Q.brandCheck(this, n), Q.argumentLengthCheck(arguments, 1, "FileReader.readAsArrayBuffer"), o = Q.converters.Blob(o, { strict: false }), p(this, o, "ArrayBuffer");
        }
        readAsBinaryString(o) {
          Q.brandCheck(this, n), Q.argumentLengthCheck(arguments, 1, "FileReader.readAsBinaryString"), o = Q.converters.Blob(o, { strict: false }), p(this, o, "BinaryString");
        }
        readAsText(o, a = void 0) {
          Q.brandCheck(this, n), Q.argumentLengthCheck(arguments, 1, "FileReader.readAsText"), o = Q.converters.Blob(o, { strict: false }), a !== void 0 && (a = Q.converters.DOMString(a, "FileReader.readAsText", "encoding")), p(this, o, "Text", a);
        }
        readAsDataURL(o) {
          Q.brandCheck(this, n), Q.argumentLengthCheck(arguments, 1, "FileReader.readAsDataURL"), o = Q.converters.Blob(o, { strict: false }), p(this, o, "DataURL");
        }
        abort() {
          if (this[E] === "empty" || this[E] === "done") {
            this[B] = null;
            return;
          }
          this[E] === "loading" && (this[E] = "done", this[B] = null), this[l] = true, c("abort", this), this[E] !== "loading" && c("loadend", this);
        }
        get readyState() {
          switch (Q.brandCheck(this, n), this[E]) {
            case "empty":
              return this.EMPTY;
            case "loading":
              return this.LOADING;
            case "done":
              return this.DONE;
          }
        }
        get result() {
          return Q.brandCheck(this, n), this[B];
        }
        get error() {
          return Q.brandCheck(this, n), this[t];
        }
        get onloadend() {
          return Q.brandCheck(this, n), this[f].loadend;
        }
        set onloadend(o) {
          Q.brandCheck(this, n), this[f].loadend && this.removeEventListener("loadend", this[f].loadend), typeof o == "function" ? (this[f].loadend = o, this.addEventListener("loadend", o)) : this[f].loadend = null;
        }
        get onerror() {
          return Q.brandCheck(this, n), this[f].error;
        }
        set onerror(o) {
          Q.brandCheck(this, n), this[f].error && this.removeEventListener("error", this[f].error), typeof o == "function" ? (this[f].error = o, this.addEventListener("error", o)) : this[f].error = null;
        }
        get onloadstart() {
          return Q.brandCheck(this, n), this[f].loadstart;
        }
        set onloadstart(o) {
          Q.brandCheck(this, n), this[f].loadstart && this.removeEventListener("loadstart", this[f].loadstart), typeof o == "function" ? (this[f].loadstart = o, this.addEventListener("loadstart", o)) : this[f].loadstart = null;
        }
        get onprogress() {
          return Q.brandCheck(this, n), this[f].progress;
        }
        set onprogress(o) {
          Q.brandCheck(this, n), this[f].progress && this.removeEventListener("progress", this[f].progress), typeof o == "function" ? (this[f].progress = o, this.addEventListener("progress", o)) : this[f].progress = null;
        }
        get onload() {
          return Q.brandCheck(this, n), this[f].load;
        }
        set onload(o) {
          Q.brandCheck(this, n), this[f].load && this.removeEventListener("load", this[f].load), typeof o == "function" ? (this[f].load = o, this.addEventListener("load", o)) : this[f].load = null;
        }
        get onabort() {
          return Q.brandCheck(this, n), this[f].abort;
        }
        set onabort(o) {
          Q.brandCheck(this, n), this[f].abort && this.removeEventListener("abort", this[f].abort), typeof o == "function" ? (this[f].abort = o, this.addEventListener("abort", o)) : this[f].abort = null;
        }
      }
      return n.EMPTY = n.prototype.EMPTY = 0, n.LOADING = n.prototype.LOADING = 1, n.DONE = n.prototype.DONE = 2, Object.defineProperties(n.prototype, { EMPTY: A, LOADING: A, DONE: A, readAsArrayBuffer: u, readAsBinaryString: u, readAsText: u, readAsDataURL: u, abort: u, readyState: u, result: u, error: u, onloadstart: u, onprogress: u, onload: u, onabort: u, onerror: u, onloadend: u, [Symbol.toStringTag]: { value: "FileReader", writable: false, enumerable: false, configurable: true } }), Object.defineProperties(n, { EMPTY: A, LOADING: A, DONE: A }), filereader = { FileReader: n }, filereader;
    }
    e(requireFilereader, "requireFilereader");
    var symbols$1;
    var hasRequiredSymbols$1;
    function requireSymbols$1() {
      return hasRequiredSymbols$1 || (hasRequiredSymbols$1 = 1, symbols$1 = { kConstruct: requireSymbols$4().kConstruct }), symbols$1;
    }
    e(requireSymbols$1, "requireSymbols$1");
    var util$3;
    var hasRequiredUtil$3;
    function requireUtil$3() {
      if (hasRequiredUtil$3)
        return util$3;
      hasRequiredUtil$3 = 1;
      const A = require$$0__default, { URLSerializer: p } = requireDataUrl(), { isValidHeaderName: c } = requireUtil$6();
      function E(B, f, l = false) {
        const Q = p(B, l), u = p(f, l);
        return Q === u;
      }
      e(E, "urlEquals");
      function t(B) {
        A(B !== null);
        const f = [];
        for (let l of B.split(","))
          l = l.trim(), c(l) && f.push(l);
        return f;
      }
      return e(t, "getFieldValues"), util$3 = { urlEquals: E, getFieldValues: t }, util$3;
    }
    e(requireUtil$3, "requireUtil$3");
    var cache;
    var hasRequiredCache;
    function requireCache() {
      if (hasRequiredCache)
        return cache;
      hasRequiredCache = 1;
      const { kConstruct: A } = requireSymbols$1(), { urlEquals: p, getFieldValues: c } = requireUtil$3(), { kEnumerableProperty: E, isDisturbed: t } = requireUtil$7(), { webidl: B } = requireWebidl(), { Response: f, cloneResponse: l, fromInnerResponse: Q } = requireResponse(), { Request: u, fromInnerRequest: n } = requireRequest(), { kState: r } = requireSymbols$3(), { fetching: o } = requireFetch(), { urlIsHttpHttpsScheme: a, createDeferredPromise: g, readAllBytes: d } = requireUtil$6(), N = require$$0__default;
      class M {
        static {
          e(this, "Cache");
        }
        #A;
        constructor() {
          arguments[0] !== A && B.illegalConstructor(), B.util.markAsUncloneable(this), this.#A = arguments[1];
        }
        async match(V, H = {}) {
          B.brandCheck(this, M);
          const h = "Cache.match";
          B.argumentLengthCheck(arguments, 1, h), V = B.converters.RequestInfo(V, h, "request"), H = B.converters.CacheQueryOptions(H, h, "options");
          const I = this.#t(V, H, 1);
          if (I.length !== 0)
            return I[0];
        }
        async matchAll(V = void 0, H = {}) {
          B.brandCheck(this, M);
          const h = "Cache.matchAll";
          return V !== void 0 && (V = B.converters.RequestInfo(V, h, "request")), H = B.converters.CacheQueryOptions(H, h, "options"), this.#t(V, H);
        }
        async add(V) {
          B.brandCheck(this, M);
          const H = "Cache.add";
          B.argumentLengthCheck(arguments, 1, H), V = B.converters.RequestInfo(V, H, "request");
          const h = [V];
          return await this.addAll(h);
        }
        async addAll(V) {
          B.brandCheck(this, M);
          const H = "Cache.addAll";
          B.argumentLengthCheck(arguments, 1, H);
          const h = [], I = [];
          for (let q of V) {
            if (q === void 0)
              throw B.errors.conversionFailed({ prefix: H, argument: "Argument 1", types: ["undefined is not allowed"] });
            if (q = B.converters.RequestInfo(q), typeof q == "string")
              continue;
            const O = q[r];
            if (!a(O.url) || O.method !== "GET")
              throw B.errors.exception({ header: H, message: "Expected http/s scheme when method is not GET." });
          }
          const k = [];
          for (const q of V) {
            const O = new u(q)[r];
            if (!a(O.url))
              throw B.errors.exception({ header: H, message: "Expected http/s scheme." });
            O.initiator = "fetch", O.destination = "subresource", I.push(O);
            const P = g();
            k.push(o({ request: O, processResponse(Z) {
              if (Z.type === "error" || Z.status === 206 || Z.status < 200 || Z.status > 299)
                P.reject(B.errors.exception({ header: "Cache.addAll", message: "Received an invalid status code or the request failed." }));
              else if (Z.headersList.contains("vary")) {
                const cA = c(Z.headersList.get("vary"));
                for (const EA of cA)
                  if (EA === "*") {
                    P.reject(B.errors.exception({ header: "Cache.addAll", message: "invalid vary field value" }));
                    for (const fA of k)
                      fA.abort();
                    return;
                  }
              }
            }, processResponseEndOfBody(Z) {
              if (Z.aborted) {
                P.reject(new DOMException("aborted", "AbortError"));
                return;
              }
              P.resolve(Z);
            } })), h.push(P.promise);
          }
          const F = await Promise.all(h), m = [];
          let D = 0;
          for (const q of F) {
            const O = { type: "put", request: I[D], response: q };
            m.push(O), D++;
          }
          const S = g();
          let W = null;
          try {
            this.#e(m);
          } catch (q) {
            W = q;
          }
          return queueMicrotask(() => {
            W === null ? S.resolve(void 0) : S.reject(W);
          }), S.promise;
        }
        async put(V, H) {
          B.brandCheck(this, M);
          const h = "Cache.put";
          B.argumentLengthCheck(arguments, 2, h), V = B.converters.RequestInfo(V, h, "request"), H = B.converters.Response(H, h, "response");
          let I = null;
          if (V instanceof u ? I = V[r] : I = new u(V)[r], !a(I.url) || I.method !== "GET")
            throw B.errors.exception({ header: h, message: "Expected an http/s scheme when method is not GET" });
          const k = H[r];
          if (k.status === 206)
            throw B.errors.exception({ header: h, message: "Got 206 status" });
          if (k.headersList.contains("vary")) {
            const O = c(k.headersList.get("vary"));
            for (const P of O)
              if (P === "*")
                throw B.errors.exception({ header: h, message: "Got * vary field value" });
          }
          if (k.body && (t(k.body.stream) || k.body.stream.locked))
            throw B.errors.exception({ header: h, message: "Response body is locked or disturbed" });
          const i = l(k), F = g();
          if (k.body != null) {
            const P = k.body.stream.getReader();
            d(P).then(F.resolve, F.reject);
          } else
            F.resolve(void 0);
          const m = [], D = { type: "put", request: I, response: i };
          m.push(D);
          const S = await F.promise;
          i.body != null && (i.body.source = S);
          const W = g();
          let q = null;
          try {
            this.#e(m);
          } catch (O) {
            q = O;
          }
          return queueMicrotask(() => {
            q === null ? W.resolve() : W.reject(q);
          }), W.promise;
        }
        async delete(V, H = {}) {
          B.brandCheck(this, M);
          const h = "Cache.delete";
          B.argumentLengthCheck(arguments, 1, h), V = B.converters.RequestInfo(V, h, "request"), H = B.converters.CacheQueryOptions(H, h, "options");
          let I = null;
          if (V instanceof u) {
            if (I = V[r], I.method !== "GET" && !H.ignoreMethod)
              return false;
          } else
            N(typeof V == "string"), I = new u(V)[r];
          const k = [], i = { type: "delete", request: I, options: H };
          k.push(i);
          const F = g();
          let m = null, D;
          try {
            D = this.#e(k);
          } catch (S) {
            m = S;
          }
          return queueMicrotask(() => {
            m === null ? F.resolve(!!D?.length) : F.reject(m);
          }), F.promise;
        }
        async keys(V = void 0, H = {}) {
          B.brandCheck(this, M);
          const h = "Cache.keys";
          V !== void 0 && (V = B.converters.RequestInfo(V, h, "request")), H = B.converters.CacheQueryOptions(H, h, "options");
          let I = null;
          if (V !== void 0)
            if (V instanceof u) {
              if (I = V[r], I.method !== "GET" && !H.ignoreMethod)
                return [];
            } else
              typeof V == "string" && (I = new u(V)[r]);
          const k = g(), i = [];
          if (V === void 0)
            for (const F of this.#A)
              i.push(F[0]);
          else {
            const F = this.#n(I, H);
            for (const m of F)
              i.push(m[0]);
          }
          return queueMicrotask(() => {
            const F = [];
            for (const m of i) {
              const D = n(m, new AbortController().signal, "immutable");
              F.push(D);
            }
            k.resolve(Object.freeze(F));
          }), k.promise;
        }
        #e(V) {
          const H = this.#A, h = [...H], I = [], k = [];
          try {
            for (const i of V) {
              if (i.type !== "delete" && i.type !== "put")
                throw B.errors.exception({ header: "Cache.#batchCacheOperations", message: 'operation type does not match "delete" or "put"' });
              if (i.type === "delete" && i.response != null)
                throw B.errors.exception({ header: "Cache.#batchCacheOperations", message: "delete operation should not have an associated response" });
              if (this.#n(i.request, i.options, I).length)
                throw new DOMException("???", "InvalidStateError");
              let F;
              if (i.type === "delete") {
                if (F = this.#n(i.request, i.options), F.length === 0)
                  return [];
                for (const m of F) {
                  const D = H.indexOf(m);
                  N(D !== -1), H.splice(D, 1);
                }
              } else if (i.type === "put") {
                if (i.response == null)
                  throw B.errors.exception({ header: "Cache.#batchCacheOperations", message: "put operation should have an associated response" });
                const m = i.request;
                if (!a(m.url))
                  throw B.errors.exception({ header: "Cache.#batchCacheOperations", message: "expected http or https scheme" });
                if (m.method !== "GET")
                  throw B.errors.exception({ header: "Cache.#batchCacheOperations", message: "not get method" });
                if (i.options != null)
                  throw B.errors.exception({ header: "Cache.#batchCacheOperations", message: "options must not be defined" });
                F = this.#n(i.request);
                for (const D of F) {
                  const S = H.indexOf(D);
                  N(S !== -1), H.splice(S, 1);
                }
                H.push([i.request, i.response]), I.push([i.request, i.response]);
              }
              k.push([i.request, i.response]);
            }
            return k;
          } catch (i) {
            throw this.#A.length = 0, this.#A = h, i;
          }
        }
        #n(V, H, h) {
          const I = [], k = h ?? this.#A;
          for (const i of k) {
            const [F, m] = i;
            this.#r(V, F, m, H) && I.push(i);
          }
          return I;
        }
        #r(V, H, h = null, I) {
          const k = new URL(V.url), i = new URL(H.url);
          if (I?.ignoreSearch && (i.search = "", k.search = ""), !p(k, i, true))
            return false;
          if (h == null || I?.ignoreVary || !h.headersList.contains("vary"))
            return true;
          const F = c(h.headersList.get("vary"));
          for (const m of F) {
            if (m === "*")
              return false;
            const D = H.headersList.get(m), S = V.headersList.get(m);
            if (D !== S)
              return false;
          }
          return true;
        }
        #t(V, H, h = 1 / 0) {
          let I = null;
          if (V !== void 0)
            if (V instanceof u) {
              if (I = V[r], I.method !== "GET" && !H.ignoreMethod)
                return [];
            } else
              typeof V == "string" && (I = new u(V)[r]);
          const k = [];
          if (V === void 0)
            for (const F of this.#A)
              k.push(F[1]);
          else {
            const F = this.#n(I, H);
            for (const m of F)
              k.push(m[1]);
          }
          const i = [];
          for (const F of k) {
            const m = Q(F, "immutable");
            if (i.push(m.clone()), i.length >= h)
              break;
          }
          return Object.freeze(i);
        }
      }
      Object.defineProperties(M.prototype, { [Symbol.toStringTag]: { value: "Cache", configurable: true }, match: E, matchAll: E, add: E, addAll: E, put: E, delete: E, keys: E });
      const Y = [{ key: "ignoreSearch", converter: B.converters.boolean, defaultValue: e(() => false, "defaultValue") }, { key: "ignoreMethod", converter: B.converters.boolean, defaultValue: e(() => false, "defaultValue") }, { key: "ignoreVary", converter: B.converters.boolean, defaultValue: e(() => false, "defaultValue") }];
      return B.converters.CacheQueryOptions = B.dictionaryConverter(Y), B.converters.MultiCacheQueryOptions = B.dictionaryConverter([...Y, { key: "cacheName", converter: B.converters.DOMString }]), B.converters.Response = B.interfaceConverter(f), B.converters["sequence<RequestInfo>"] = B.sequenceConverter(B.converters.RequestInfo), cache = { Cache: M }, cache;
    }
    e(requireCache, "requireCache");
    var cachestorage;
    var hasRequiredCachestorage;
    function requireCachestorage() {
      if (hasRequiredCachestorage)
        return cachestorage;
      hasRequiredCachestorage = 1;
      const { kConstruct: A } = requireSymbols$1(), { Cache: p } = requireCache(), { webidl: c } = requireWebidl(), { kEnumerableProperty: E } = requireUtil$7();
      class t {
        static {
          e(this, "CacheStorage");
        }
        #A = /* @__PURE__ */ new Map();
        constructor() {
          arguments[0] !== A && c.illegalConstructor(), c.util.markAsUncloneable(this);
        }
        async match(f, l = {}) {
          if (c.brandCheck(this, t), c.argumentLengthCheck(arguments, 1, "CacheStorage.match"), f = c.converters.RequestInfo(f), l = c.converters.MultiCacheQueryOptions(l), l.cacheName != null) {
            if (this.#A.has(l.cacheName)) {
              const Q = this.#A.get(l.cacheName);
              return await new p(A, Q).match(f, l);
            }
          } else
            for (const Q of this.#A.values()) {
              const n = await new p(A, Q).match(f, l);
              if (n !== void 0)
                return n;
            }
        }
        async has(f) {
          c.brandCheck(this, t);
          const l = "CacheStorage.has";
          return c.argumentLengthCheck(arguments, 1, l), f = c.converters.DOMString(f, l, "cacheName"), this.#A.has(f);
        }
        async open(f) {
          c.brandCheck(this, t);
          const l = "CacheStorage.open";
          if (c.argumentLengthCheck(arguments, 1, l), f = c.converters.DOMString(f, l, "cacheName"), this.#A.has(f)) {
            const u = this.#A.get(f);
            return new p(A, u);
          }
          const Q = [];
          return this.#A.set(f, Q), new p(A, Q);
        }
        async delete(f) {
          c.brandCheck(this, t);
          const l = "CacheStorage.delete";
          return c.argumentLengthCheck(arguments, 1, l), f = c.converters.DOMString(f, l, "cacheName"), this.#A.delete(f);
        }
        async keys() {
          return c.brandCheck(this, t), [...this.#A.keys()];
        }
      }
      return Object.defineProperties(t.prototype, { [Symbol.toStringTag]: { value: "CacheStorage", configurable: true }, match: E, has: E, open: E, delete: E, keys: E }), cachestorage = { CacheStorage: t }, cachestorage;
    }
    e(requireCachestorage, "requireCachestorage");
    var constants$1;
    var hasRequiredConstants$1;
    function requireConstants$1() {
      return hasRequiredConstants$1 || (hasRequiredConstants$1 = 1, constants$1 = { maxAttributeValueSize: 1024, maxNameValuePairSize: 4096 }), constants$1;
    }
    e(requireConstants$1, "requireConstants$1");
    var util$2;
    var hasRequiredUtil$2;
    function requireUtil$2() {
      if (hasRequiredUtil$2)
        return util$2;
      hasRequiredUtil$2 = 1;
      function A(r) {
        for (let o = 0; o < r.length; ++o) {
          const a = r.charCodeAt(o);
          if (a >= 0 && a <= 8 || a >= 10 && a <= 31 || a === 127)
            return true;
        }
        return false;
      }
      e(A, "isCTLExcludingHtab");
      function p(r) {
        for (let o = 0; o < r.length; ++o) {
          const a = r.charCodeAt(o);
          if (a < 33 || a > 126 || a === 34 || a === 40 || a === 41 || a === 60 || a === 62 || a === 64 || a === 44 || a === 59 || a === 58 || a === 92 || a === 47 || a === 91 || a === 93 || a === 63 || a === 61 || a === 123 || a === 125)
            throw new Error("Invalid cookie name");
        }
      }
      e(p, "validateCookieName");
      function c(r) {
        let o = r.length, a = 0;
        if (r[0] === '"') {
          if (o === 1 || r[o - 1] !== '"')
            throw new Error("Invalid cookie value");
          --o, ++a;
        }
        for (; a < o; ) {
          const g = r.charCodeAt(a++);
          if (g < 33 || g > 126 || g === 34 || g === 44 || g === 59 || g === 92)
            throw new Error("Invalid cookie value");
        }
      }
      e(c, "validateCookieValue");
      function E(r) {
        for (let o = 0; o < r.length; ++o) {
          const a = r.charCodeAt(o);
          if (a < 32 || a === 127 || a === 59)
            throw new Error("Invalid cookie path");
        }
      }
      e(E, "validateCookiePath");
      function t(r) {
        if (r.startsWith("-") || r.endsWith(".") || r.endsWith("-"))
          throw new Error("Invalid cookie domain");
      }
      e(t, "validateCookieDomain");
      const B = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], f = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], l = Array(61).fill(0).map((r, o) => o.toString().padStart(2, "0"));
      function Q(r) {
        return typeof r == "number" && (r = new Date(r)), `${B[r.getUTCDay()]}, ${l[r.getUTCDate()]} ${f[r.getUTCMonth()]} ${r.getUTCFullYear()} ${l[r.getUTCHours()]}:${l[r.getUTCMinutes()]}:${l[r.getUTCSeconds()]} GMT`;
      }
      e(Q, "toIMFDate");
      function u(r) {
        if (r < 0)
          throw new Error("Invalid cookie max-age");
      }
      e(u, "validateCookieMaxAge");
      function n(r) {
        if (r.name.length === 0)
          return null;
        p(r.name), c(r.value);
        const o = [`${r.name}=${r.value}`];
        r.name.startsWith("__Secure-") && (r.secure = true), r.name.startsWith("__Host-") && (r.secure = true, r.domain = null, r.path = "/"), r.secure && o.push("Secure"), r.httpOnly && o.push("HttpOnly"), typeof r.maxAge == "number" && (u(r.maxAge), o.push(`Max-Age=${r.maxAge}`)), r.domain && (t(r.domain), o.push(`Domain=${r.domain}`)), r.path && (E(r.path), o.push(`Path=${r.path}`)), r.expires && r.expires.toString() !== "Invalid Date" && o.push(`Expires=${Q(r.expires)}`), r.sameSite && o.push(`SameSite=${r.sameSite}`);
        for (const a of r.unparsed) {
          if (!a.includes("="))
            throw new Error("Invalid unparsed");
          const [g, ...d] = a.split("=");
          o.push(`${g.trim()}=${d.join("=")}`);
        }
        return o.join("; ");
      }
      return e(n, "stringify"), util$2 = { isCTLExcludingHtab: A, validateCookieName: p, validateCookiePath: E, validateCookieValue: c, toIMFDate: Q, stringify: n }, util$2;
    }
    e(requireUtil$2, "requireUtil$2");
    var parse2;
    var hasRequiredParse;
    function requireParse() {
      if (hasRequiredParse)
        return parse2;
      hasRequiredParse = 1;
      const { maxNameValuePairSize: A, maxAttributeValueSize: p } = requireConstants$1(), { isCTLExcludingHtab: c } = requireUtil$2(), { collectASequenceOfCodePointsFast: E } = requireDataUrl(), t = require$$0__default;
      function B(l) {
        if (c(l))
          return null;
        let Q = "", u = "", n = "", r = "";
        if (l.includes(";")) {
          const o = { position: 0 };
          Q = E(";", l, o), u = l.slice(o.position);
        } else
          Q = l;
        if (!Q.includes("="))
          r = Q;
        else {
          const o = { position: 0 };
          n = E("=", Q, o), r = Q.slice(o.position + 1);
        }
        return n = n.trim(), r = r.trim(), n.length + r.length > A ? null : { name: n, value: r, ...f(u) };
      }
      e(B, "parseSetCookie");
      function f(l, Q = {}) {
        if (l.length === 0)
          return Q;
        t(l[0] === ";"), l = l.slice(1);
        let u = "";
        l.includes(";") ? (u = E(";", l, { position: 0 }), l = l.slice(u.length)) : (u = l, l = "");
        let n = "", r = "";
        if (u.includes("=")) {
          const a = { position: 0 };
          n = E("=", u, a), r = u.slice(a.position + 1);
        } else
          n = u;
        if (n = n.trim(), r = r.trim(), r.length > p)
          return f(l, Q);
        const o = n.toLowerCase();
        if (o === "expires") {
          const a = new Date(r);
          Q.expires = a;
        } else if (o === "max-age") {
          const a = r.charCodeAt(0);
          if ((a < 48 || a > 57) && r[0] !== "-" || !/^\d+$/.test(r))
            return f(l, Q);
          const g = Number(r);
          Q.maxAge = g;
        } else if (o === "domain") {
          let a = r;
          a[0] === "." && (a = a.slice(1)), a = a.toLowerCase(), Q.domain = a;
        } else if (o === "path") {
          let a = "";
          r.length === 0 || r[0] !== "/" ? a = "/" : a = r, Q.path = a;
        } else if (o === "secure")
          Q.secure = true;
        else if (o === "httponly")
          Q.httpOnly = true;
        else if (o === "samesite") {
          let a = "Default";
          const g = r.toLowerCase();
          g.includes("none") && (a = "None"), g.includes("strict") && (a = "Strict"), g.includes("lax") && (a = "Lax"), Q.sameSite = a;
        } else
          Q.unparsed ??= [], Q.unparsed.push(`${n}=${r}`);
        return f(l, Q);
      }
      return e(f, "parseUnparsedAttributes"), parse2 = { parseSetCookie: B, parseUnparsedAttributes: f }, parse2;
    }
    e(requireParse, "requireParse");
    var cookies;
    var hasRequiredCookies;
    function requireCookies() {
      if (hasRequiredCookies)
        return cookies;
      hasRequiredCookies = 1;
      const { parseSetCookie: A } = requireParse(), { stringify: p } = requireUtil$2(), { webidl: c } = requireWebidl(), { Headers: E } = requireHeaders();
      function t(Q) {
        c.argumentLengthCheck(arguments, 1, "getCookies"), c.brandCheck(Q, E, { strict: false });
        const u = Q.get("cookie"), n = {};
        if (!u)
          return n;
        for (const r of u.split(";")) {
          const [o, ...a] = r.split("=");
          n[o.trim()] = a.join("=");
        }
        return n;
      }
      e(t, "getCookies");
      function B(Q, u, n) {
        c.brandCheck(Q, E, { strict: false });
        const r = "deleteCookie";
        c.argumentLengthCheck(arguments, 2, r), u = c.converters.DOMString(u, r, "name"), n = c.converters.DeleteCookieAttributes(n), l(Q, { name: u, value: "", expires: new Date(0), ...n });
      }
      e(B, "deleteCookie");
      function f(Q) {
        c.argumentLengthCheck(arguments, 1, "getSetCookies"), c.brandCheck(Q, E, { strict: false });
        const u = Q.getSetCookie();
        return u ? u.map((n) => A(n)) : [];
      }
      e(f, "getSetCookies");
      function l(Q, u) {
        c.argumentLengthCheck(arguments, 2, "setCookie"), c.brandCheck(Q, E, { strict: false }), u = c.converters.Cookie(u);
        const n = p(u);
        n && Q.append("Set-Cookie", n);
      }
      return e(l, "setCookie"), c.converters.DeleteCookieAttributes = c.dictionaryConverter([{ converter: c.nullableConverter(c.converters.DOMString), key: "path", defaultValue: e(() => null, "defaultValue") }, { converter: c.nullableConverter(c.converters.DOMString), key: "domain", defaultValue: e(() => null, "defaultValue") }]), c.converters.Cookie = c.dictionaryConverter([{ converter: c.converters.DOMString, key: "name" }, { converter: c.converters.DOMString, key: "value" }, { converter: c.nullableConverter((Q) => typeof Q == "number" ? c.converters["unsigned long long"](Q) : new Date(Q)), key: "expires", defaultValue: e(() => null, "defaultValue") }, { converter: c.nullableConverter(c.converters["long long"]), key: "maxAge", defaultValue: e(() => null, "defaultValue") }, { converter: c.nullableConverter(c.converters.DOMString), key: "domain", defaultValue: e(() => null, "defaultValue") }, { converter: c.nullableConverter(c.converters.DOMString), key: "path", defaultValue: e(() => null, "defaultValue") }, { converter: c.nullableConverter(c.converters.boolean), key: "secure", defaultValue: e(() => null, "defaultValue") }, { converter: c.nullableConverter(c.converters.boolean), key: "httpOnly", defaultValue: e(() => null, "defaultValue") }, { converter: c.converters.USVString, key: "sameSite", allowedValues: ["Strict", "Lax", "None"] }, { converter: c.sequenceConverter(c.converters.DOMString), key: "unparsed", defaultValue: e(() => new Array(0), "defaultValue") }]), cookies = { getCookies: t, deleteCookie: B, getSetCookies: f, setCookie: l }, cookies;
    }
    e(requireCookies, "requireCookies");
    var events;
    var hasRequiredEvents;
    function requireEvents() {
      if (hasRequiredEvents)
        return events;
      hasRequiredEvents = 1;
      const { webidl: A } = requireWebidl(), { kEnumerableProperty: p } = requireUtil$7(), { kConstruct: c } = requireSymbols$4(), { MessagePort: E } = require$$1__default;
      class t extends Event {
        static {
          e(this, "MessageEvent");
        }
        #A;
        constructor(n, r = {}) {
          if (n === c) {
            super(arguments[1], arguments[2]), A.util.markAsUncloneable(this);
            return;
          }
          const o = "MessageEvent constructor";
          A.argumentLengthCheck(arguments, 1, o), n = A.converters.DOMString(n, o, "type"), r = A.converters.MessageEventInit(r, o, "eventInitDict"), super(n, r), this.#A = r, A.util.markAsUncloneable(this);
        }
        get data() {
          return A.brandCheck(this, t), this.#A.data;
        }
        get origin() {
          return A.brandCheck(this, t), this.#A.origin;
        }
        get lastEventId() {
          return A.brandCheck(this, t), this.#A.lastEventId;
        }
        get source() {
          return A.brandCheck(this, t), this.#A.source;
        }
        get ports() {
          return A.brandCheck(this, t), Object.isFrozen(this.#A.ports) || Object.freeze(this.#A.ports), this.#A.ports;
        }
        initMessageEvent(n, r = false, o = false, a = null, g = "", d = "", N = null, M = []) {
          return A.brandCheck(this, t), A.argumentLengthCheck(arguments, 1, "MessageEvent.initMessageEvent"), new t(n, { bubbles: r, cancelable: o, data: a, origin: g, lastEventId: d, source: N, ports: M });
        }
        static createFastMessageEvent(n, r) {
          const o = new t(c, n, r);
          return o.#A = r, o.#A.data ??= null, o.#A.origin ??= "", o.#A.lastEventId ??= "", o.#A.source ??= null, o.#A.ports ??= [], o;
        }
      }
      const { createFastMessageEvent: B } = t;
      delete t.createFastMessageEvent;
      class f extends Event {
        static {
          e(this, "CloseEvent");
        }
        #A;
        constructor(n, r = {}) {
          const o = "CloseEvent constructor";
          A.argumentLengthCheck(arguments, 1, o), n = A.converters.DOMString(n, o, "type"), r = A.converters.CloseEventInit(r), super(n, r), this.#A = r, A.util.markAsUncloneable(this);
        }
        get wasClean() {
          return A.brandCheck(this, f), this.#A.wasClean;
        }
        get code() {
          return A.brandCheck(this, f), this.#A.code;
        }
        get reason() {
          return A.brandCheck(this, f), this.#A.reason;
        }
      }
      class l extends Event {
        static {
          e(this, "ErrorEvent");
        }
        #A;
        constructor(n, r) {
          const o = "ErrorEvent constructor";
          A.argumentLengthCheck(arguments, 1, o), super(n, r), A.util.markAsUncloneable(this), n = A.converters.DOMString(n, o, "type"), r = A.converters.ErrorEventInit(r ?? {}), this.#A = r;
        }
        get message() {
          return A.brandCheck(this, l), this.#A.message;
        }
        get filename() {
          return A.brandCheck(this, l), this.#A.filename;
        }
        get lineno() {
          return A.brandCheck(this, l), this.#A.lineno;
        }
        get colno() {
          return A.brandCheck(this, l), this.#A.colno;
        }
        get error() {
          return A.brandCheck(this, l), this.#A.error;
        }
      }
      Object.defineProperties(t.prototype, { [Symbol.toStringTag]: { value: "MessageEvent", configurable: true }, data: p, origin: p, lastEventId: p, source: p, ports: p, initMessageEvent: p }), Object.defineProperties(f.prototype, { [Symbol.toStringTag]: { value: "CloseEvent", configurable: true }, reason: p, code: p, wasClean: p }), Object.defineProperties(l.prototype, { [Symbol.toStringTag]: { value: "ErrorEvent", configurable: true }, message: p, filename: p, lineno: p, colno: p, error: p }), A.converters.MessagePort = A.interfaceConverter(E), A.converters["sequence<MessagePort>"] = A.sequenceConverter(A.converters.MessagePort);
      const Q = [{ key: "bubbles", converter: A.converters.boolean, defaultValue: e(() => false, "defaultValue") }, { key: "cancelable", converter: A.converters.boolean, defaultValue: e(() => false, "defaultValue") }, { key: "composed", converter: A.converters.boolean, defaultValue: e(() => false, "defaultValue") }];
      return A.converters.MessageEventInit = A.dictionaryConverter([...Q, { key: "data", converter: A.converters.any, defaultValue: e(() => null, "defaultValue") }, { key: "origin", converter: A.converters.USVString, defaultValue: e(() => "", "defaultValue") }, { key: "lastEventId", converter: A.converters.DOMString, defaultValue: e(() => "", "defaultValue") }, { key: "source", converter: A.nullableConverter(A.converters.MessagePort), defaultValue: e(() => null, "defaultValue") }, { key: "ports", converter: A.converters["sequence<MessagePort>"], defaultValue: e(() => new Array(0), "defaultValue") }]), A.converters.CloseEventInit = A.dictionaryConverter([...Q, { key: "wasClean", converter: A.converters.boolean, defaultValue: e(() => false, "defaultValue") }, { key: "code", converter: A.converters["unsigned short"], defaultValue: e(() => 0, "defaultValue") }, { key: "reason", converter: A.converters.USVString, defaultValue: e(() => "", "defaultValue") }]), A.converters.ErrorEventInit = A.dictionaryConverter([...Q, { key: "message", converter: A.converters.DOMString, defaultValue: e(() => "", "defaultValue") }, { key: "filename", converter: A.converters.USVString, defaultValue: e(() => "", "defaultValue") }, { key: "lineno", converter: A.converters["unsigned long"], defaultValue: e(() => 0, "defaultValue") }, { key: "colno", converter: A.converters["unsigned long"], defaultValue: e(() => 0, "defaultValue") }, { key: "error", converter: A.converters.any }]), events = { MessageEvent: t, CloseEvent: f, ErrorEvent: l, createFastMessageEvent: B }, events;
    }
    e(requireEvents, "requireEvents");
    var constants3;
    var hasRequiredConstants;
    function requireConstants() {
      if (hasRequiredConstants)
        return constants3;
      hasRequiredConstants = 1;
      const A = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11", p = { enumerable: true, writable: false, configurable: false }, c = { CONNECTING: 0, OPEN: 1, CLOSING: 2, CLOSED: 3 }, E = { NOT_SENT: 0, PROCESSING: 1, SENT: 2 }, t = { CONTINUATION: 0, TEXT: 1, BINARY: 2, CLOSE: 8, PING: 9, PONG: 10 }, B = 2 ** 16 - 1, f = { INFO: 0, PAYLOADLENGTH_16: 2, PAYLOADLENGTH_64: 3, READ_DATA: 4 }, l = Buffer.allocUnsafe(0);
      return constants3 = { uid: A, sentCloseFrameState: E, staticPropertyDescriptors: p, states: c, opcodes: t, maxUnsigned16Bit: B, parserStates: f, emptyBuffer: l, sendHints: { string: 1, typedArray: 2, arrayBuffer: 3, blob: 4 } }, constants3;
    }
    e(requireConstants, "requireConstants");
    var symbols;
    var hasRequiredSymbols;
    function requireSymbols() {
      return hasRequiredSymbols || (hasRequiredSymbols = 1, symbols = { kWebSocketURL: Symbol("url"), kReadyState: Symbol("ready state"), kController: Symbol("controller"), kResponse: Symbol("response"), kBinaryType: Symbol("binary type"), kSentClose: Symbol("sent close"), kReceivedClose: Symbol("received close"), kByteParser: Symbol("byte parser") }), symbols;
    }
    e(requireSymbols, "requireSymbols");
    var util$1;
    var hasRequiredUtil$1;
    function requireUtil$1() {
      if (hasRequiredUtil$1)
        return util$1;
      hasRequiredUtil$1 = 1;
      const { kReadyState: A, kController: p, kResponse: c, kBinaryType: E, kWebSocketURL: t } = requireSymbols(), { states: B, opcodes: f } = requireConstants(), { ErrorEvent: l, createFastMessageEvent: Q } = requireEvents(), { isUtf8: u } = require$$0__default$2, { collectASequenceOfCodePointsFast: n, removeHTTPWhitespace: r } = requireDataUrl();
      function o(q) {
        return q[A] === B.CONNECTING;
      }
      e(o, "isConnecting");
      function a(q) {
        return q[A] === B.OPEN;
      }
      e(a, "isEstablished");
      function g(q) {
        return q[A] === B.CLOSING;
      }
      e(g, "isClosing");
      function d(q) {
        return q[A] === B.CLOSED;
      }
      e(d, "isClosed");
      function N(q, O, P = (cA, EA) => new Event(cA, EA), Z = {}) {
        const cA = P(q, Z);
        O.dispatchEvent(cA);
      }
      e(N, "fireEvent");
      function M(q, O, P) {
        if (q[A] !== B.OPEN)
          return;
        let Z;
        if (O === f.TEXT)
          try {
            Z = W(P);
          } catch {
            H(q, "Received invalid UTF-8 in text frame.");
            return;
          }
        else
          O === f.BINARY && (q[E] === "blob" ? Z = new Blob([P]) : Z = Y(P));
        N("message", q, Q, { origin: q[t].origin, data: Z });
      }
      e(M, "websocketMessageReceived");
      function Y(q) {
        return q.byteLength === q.buffer.byteLength ? q.buffer : q.buffer.slice(q.byteOffset, q.byteOffset + q.byteLength);
      }
      e(Y, "toArrayBuffer");
      function J(q) {
        if (q.length === 0)
          return false;
        for (let O = 0; O < q.length; ++O) {
          const P = q.charCodeAt(O);
          if (P < 33 || P > 126 || P === 34 || P === 40 || P === 41 || P === 44 || P === 47 || P === 58 || P === 59 || P === 60 || P === 61 || P === 62 || P === 63 || P === 64 || P === 91 || P === 92 || P === 93 || P === 123 || P === 125)
            return false;
        }
        return true;
      }
      e(J, "isValidSubprotocol");
      function V(q) {
        return q >= 1e3 && q < 1015 ? q !== 1004 && q !== 1005 && q !== 1006 : q >= 3e3 && q <= 4999;
      }
      e(V, "isValidStatusCode");
      function H(q, O) {
        const { [p]: P, [c]: Z } = q;
        P.abort(), Z?.socket && !Z.socket.destroyed && Z.socket.destroy(), O && N("error", q, (cA, EA) => new l(cA, EA), { error: new Error(O), message: O });
      }
      e(H, "failWebsocketConnection");
      function h(q) {
        return q === f.CLOSE || q === f.PING || q === f.PONG;
      }
      e(h, "isControlFrame");
      function I(q) {
        return q === f.CONTINUATION;
      }
      e(I, "isContinuationFrame");
      function k(q) {
        return q === f.TEXT || q === f.BINARY;
      }
      e(k, "isTextBinaryFrame");
      function i(q) {
        return k(q) || I(q) || h(q);
      }
      e(i, "isValidOpcode");
      function F(q) {
        const O = { position: 0 }, P = /* @__PURE__ */ new Map();
        for (; O.position < q.length; ) {
          const Z = n(";", q, O), [cA, EA = ""] = Z.split("=");
          P.set(r(cA, true, false), r(EA, false, true)), O.position++;
        }
        return P;
      }
      e(F, "parseExtensions");
      function m(q) {
        for (let O = 0; O < q.length; O++) {
          const P = q.charCodeAt(O);
          if (P < 48 || P > 57)
            return false;
        }
        return true;
      }
      e(m, "isValidClientWindowBits");
      const D = typeof process.versions.icu == "string", S = D ? new TextDecoder("utf-8", { fatal: true }) : void 0, W = D ? S.decode.bind(S) : function(q) {
        if (u(q))
          return q.toString("utf-8");
        throw new TypeError("Invalid utf-8 received.");
      };
      return util$1 = { isConnecting: o, isEstablished: a, isClosing: g, isClosed: d, fireEvent: N, isValidSubprotocol: J, isValidStatusCode: V, failWebsocketConnection: H, websocketMessageReceived: M, utf8Decode: W, isControlFrame: h, isContinuationFrame: I, isTextBinaryFrame: k, isValidOpcode: i, parseExtensions: F, isValidClientWindowBits: m }, util$1;
    }
    e(requireUtil$1, "requireUtil$1");
    var frame;
    var hasRequiredFrame;
    function requireFrame() {
      if (hasRequiredFrame)
        return frame;
      hasRequiredFrame = 1;
      const { maxUnsigned16Bit: A } = requireConstants(), p = 16386;
      let c, E = null, t = p;
      try {
        c = require("node:crypto");
      } catch {
        c = { randomFillSync: e(function(Q, u, n) {
          for (let r = 0; r < Q.length; ++r)
            Q[r] = Math.random() * 255 | 0;
          return Q;
        }, "randomFillSync") };
      }
      function B() {
        return t === p && (t = 0, c.randomFillSync(E ??= Buffer.allocUnsafe(p), 0, p)), [E[t++], E[t++], E[t++], E[t++]];
      }
      e(B, "generateMask");
      class f {
        static {
          e(this, "WebsocketFrameSend");
        }
        constructor(Q) {
          this.frameData = Q;
        }
        createFrame(Q) {
          const u = this.frameData, n = B(), r = u?.byteLength ?? 0;
          let o = r, a = 6;
          r > A ? (a += 8, o = 127) : r > 125 && (a += 2, o = 126);
          const g = Buffer.allocUnsafe(r + a);
          g[0] = g[1] = 0, g[0] |= 128, g[0] = (g[0] & 240) + Q;
          g[a - 4] = n[0], g[a - 3] = n[1], g[a - 2] = n[2], g[a - 1] = n[3], g[1] = o, o === 126 ? g.writeUInt16BE(r, 2) : o === 127 && (g[2] = g[3] = 0, g.writeUIntBE(r, 4, 6)), g[1] |= 128;
          for (let d = 0; d < r; ++d)
            g[a + d] = u[d] ^ n[d & 3];
          return g;
        }
      }
      return frame = { WebsocketFrameSend: f }, frame;
    }
    e(requireFrame, "requireFrame");
    var connection;
    var hasRequiredConnection;
    function requireConnection() {
      if (hasRequiredConnection)
        return connection;
      hasRequiredConnection = 1;
      const { uid: A, states: p, sentCloseFrameState: c, emptyBuffer: E, opcodes: t } = requireConstants(), { kReadyState: B, kSentClose: f, kByteParser: l, kReceivedClose: Q, kResponse: u } = requireSymbols(), { fireEvent: n, failWebsocketConnection: r, isClosing: o, isClosed: a, isEstablished: g, parseExtensions: d } = requireUtil$1(), { channels: N } = requireDiagnostics(), { CloseEvent: M } = requireEvents(), { makeRequest: Y } = requireRequest(), { fetching: J } = requireFetch(), { Headers: V, getHeadersList: H } = requireHeaders(), { getDecodeSplit: h } = requireUtil$6(), { WebsocketFrameSend: I } = requireFrame();
      let k;
      try {
        k = require("node:crypto");
      } catch {
      }
      function i(W, q, O, P, Z, cA) {
        const EA = W;
        EA.protocol = W.protocol === "ws:" ? "http:" : "https:";
        const fA = Y({ urlList: [EA], client: O, serviceWorkers: "none", referrer: "no-referrer", mode: "websocket", credentials: "include", cache: "no-store", redirect: "error" });
        if (cA.headers) {
          const DA = H(new V(cA.headers));
          fA.headersList = DA;
        }
        const uA = k.randomBytes(16).toString("base64");
        fA.headersList.append("sec-websocket-key", uA), fA.headersList.append("sec-websocket-version", "13");
        for (const DA of q)
          fA.headersList.append("sec-websocket-protocol", DA);
        return fA.headersList.append("sec-websocket-extensions", "permessage-deflate; client_max_window_bits"), J({ request: fA, useParallelQueue: true, dispatcher: cA.dispatcher, processResponse(DA) {
          if (DA.type === "error" || DA.status !== 101) {
            r(P, "Received network error or non-101 status code.");
            return;
          }
          if (q.length !== 0 && !DA.headersList.get("Sec-WebSocket-Protocol")) {
            r(P, "Server did not respond with sent protocols.");
            return;
          }
          if (DA.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
            r(P, 'Server did not set Upgrade header to "websocket".');
            return;
          }
          if (DA.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
            r(P, 'Server did not set Connection header to "upgrade".');
            return;
          }
          const TA = DA.headersList.get("Sec-WebSocket-Accept"), UA = k.createHash("sha1").update(uA + A).digest("base64");
          if (TA !== UA) {
            r(P, "Incorrect hash received in Sec-WebSocket-Accept header.");
            return;
          }
          const QA = DA.headersList.get("Sec-WebSocket-Extensions");
          let eA;
          if (QA !== null && (eA = d(QA), !eA.has("permessage-deflate"))) {
            r(P, "Sec-WebSocket-Extensions header does not match.");
            return;
          }
          const lA = DA.headersList.get("Sec-WebSocket-Protocol");
          if (lA !== null && !h("sec-websocket-protocol", fA.headersList).includes(lA)) {
            r(P, "Protocol was not set in the opening handshake.");
            return;
          }
          DA.socket.on("data", m), DA.socket.on("close", D), DA.socket.on("error", S), N.open.hasSubscribers && N.open.publish({ address: DA.socket.address(), protocol: lA, extensions: QA }), Z(DA, eA);
        } });
      }
      e(i, "establishWebSocketConnection");
      function F(W, q, O, P) {
        if (!(o(W) || a(W)))
          if (!g(W))
            r(W, "Connection was closed before it was established."), W[B] = p.CLOSING;
          else if (W[f] === c.NOT_SENT) {
            W[f] = c.PROCESSING;
            const Z = new I();
            q !== void 0 && O === void 0 ? (Z.frameData = Buffer.allocUnsafe(2), Z.frameData.writeUInt16BE(q, 0)) : q !== void 0 && O !== void 0 ? (Z.frameData = Buffer.allocUnsafe(2 + P), Z.frameData.writeUInt16BE(q, 0), Z.frameData.write(O, 2, "utf-8")) : Z.frameData = E, W[u].socket.write(Z.createFrame(t.CLOSE)), W[f] = c.SENT, W[B] = p.CLOSING;
          } else
            W[B] = p.CLOSING;
      }
      e(F, "closeWebSocketConnection");
      function m(W) {
        this.ws[l].write(W) || this.pause();
      }
      e(m, "onSocketData");
      function D() {
        const { ws: W } = this, { [u]: q } = W;
        q.socket.off("data", m), q.socket.off("close", D), q.socket.off("error", S);
        const O = W[f] === c.SENT && W[Q];
        let P = 1005, Z = "";
        const cA = W[l].closingInfo;
        cA && !cA.error ? (P = cA.code ?? 1005, Z = cA.reason) : W[Q] || (P = 1006), W[B] = p.CLOSED, n("close", W, (EA, fA) => new M(EA, fA), { wasClean: O, code: P, reason: Z }), N.close.hasSubscribers && N.close.publish({ websocket: W, code: P, reason: Z });
      }
      e(D, "onSocketClose");
      function S(W) {
        const { ws: q } = this;
        q[B] = p.CLOSING, N.socketError.hasSubscribers && N.socketError.publish(W), this.destroy();
      }
      return e(S, "onSocketError"), connection = { establishWebSocketConnection: i, closeWebSocketConnection: F }, connection;
    }
    e(requireConnection, "requireConnection");
    var permessageDeflate;
    var hasRequiredPermessageDeflate;
    function requirePermessageDeflate() {
      if (hasRequiredPermessageDeflate)
        return permessageDeflate;
      hasRequiredPermessageDeflate = 1;
      const { createInflateRaw: A, Z_DEFAULT_WINDOWBITS: p } = zlib__default, { isValidClientWindowBits: c } = requireUtil$1(), E = Buffer.from([0, 0, 255, 255]), t = Symbol("kBuffer"), B = Symbol("kLength");
      class f {
        static {
          e(this, "PerMessageDeflate");
        }
        #A;
        #e = {};
        constructor(Q) {
          this.#e.serverNoContextTakeover = Q.has("server_no_context_takeover"), this.#e.serverMaxWindowBits = Q.get("server_max_window_bits");
        }
        decompress(Q, u, n) {
          if (!this.#A) {
            let r = p;
            if (this.#e.serverMaxWindowBits) {
              if (!c(this.#e.serverMaxWindowBits)) {
                n(new Error("Invalid server_max_window_bits"));
                return;
              }
              r = Number.parseInt(this.#e.serverMaxWindowBits);
            }
            this.#A = A({ windowBits: r }), this.#A[t] = [], this.#A[B] = 0, this.#A.on("data", (o) => {
              this.#A[t].push(o), this.#A[B] += o.length;
            }), this.#A.on("error", (o) => {
              this.#A = null, n(o);
            });
          }
          this.#A.write(Q), u && this.#A.write(E), this.#A.flush(() => {
            const r = Buffer.concat(this.#A[t], this.#A[B]);
            this.#A[t].length = 0, this.#A[B] = 0, n(null, r);
          });
        }
      }
      return permessageDeflate = { PerMessageDeflate: f }, permessageDeflate;
    }
    e(requirePermessageDeflate, "requirePermessageDeflate");
    var receiver;
    var hasRequiredReceiver;
    function requireReceiver() {
      if (hasRequiredReceiver)
        return receiver;
      hasRequiredReceiver = 1;
      const { Writable: A } = Stream__default, p = require$$0__default, { parserStates: c, opcodes: E, states: t, emptyBuffer: B, sentCloseFrameState: f } = requireConstants(), { kReadyState: l, kSentClose: Q, kResponse: u, kReceivedClose: n } = requireSymbols(), { channels: r } = requireDiagnostics(), { isValidStatusCode: o, isValidOpcode: a, failWebsocketConnection: g, websocketMessageReceived: d, utf8Decode: N, isControlFrame: M, isTextBinaryFrame: Y, isContinuationFrame: J } = requireUtil$1(), { WebsocketFrameSend: V } = requireFrame(), { closeWebSocketConnection: H } = requireConnection(), { PerMessageDeflate: h } = requirePermessageDeflate();
      class I extends A {
        static {
          e(this, "ByteParser");
        }
        #A = [];
        #e = 0;
        #n = false;
        #r = c.INFO;
        #t = {};
        #s = [];
        #o;
        constructor(i, F) {
          super(), this.ws = i, this.#o = F ?? /* @__PURE__ */ new Map(), this.#o.has("permessage-deflate") && this.#o.set("permessage-deflate", new h(F));
        }
        _write(i, F, m) {
          this.#A.push(i), this.#e += i.length, this.#n = true, this.run(m);
        }
        run(i) {
          for (; this.#n; )
            if (this.#r === c.INFO) {
              if (this.#e < 2)
                return i();
              const F = this.consume(2), m = (F[0] & 128) !== 0, D = F[0] & 15, S = (F[1] & 128) === 128, W = !m && D !== E.CONTINUATION, q = F[1] & 127, O = F[0] & 64, P = F[0] & 32, Z = F[0] & 16;
              if (!a(D))
                return g(this.ws, "Invalid opcode received"), i();
              if (S)
                return g(this.ws, "Frame cannot be masked"), i();
              if (O !== 0 && !this.#o.has("permessage-deflate")) {
                g(this.ws, "Expected RSV1 to be clear.");
                return;
              }
              if (P !== 0 || Z !== 0) {
                g(this.ws, "RSV1, RSV2, RSV3 must be clear");
                return;
              }
              if (W && !Y(D)) {
                g(this.ws, "Invalid frame type was fragmented.");
                return;
              }
              if (Y(D) && this.#s.length > 0) {
                g(this.ws, "Expected continuation frame");
                return;
              }
              if (this.#t.fragmented && W) {
                g(this.ws, "Fragmented frame exceeded 125 bytes.");
                return;
              }
              if ((q > 125 || W) && M(D)) {
                g(this.ws, "Control frame either too large or fragmented");
                return;
              }
              if (J(D) && this.#s.length === 0 && !this.#t.compressed) {
                g(this.ws, "Unexpected continuation frame");
                return;
              }
              q <= 125 ? (this.#t.payloadLength = q, this.#r = c.READ_DATA) : q === 126 ? this.#r = c.PAYLOADLENGTH_16 : q === 127 && (this.#r = c.PAYLOADLENGTH_64), Y(D) && (this.#t.binaryType = D, this.#t.compressed = O !== 0), this.#t.opcode = D, this.#t.masked = S, this.#t.fin = m, this.#t.fragmented = W;
            } else if (this.#r === c.PAYLOADLENGTH_16) {
              if (this.#e < 2)
                return i();
              const F = this.consume(2);
              this.#t.payloadLength = F.readUInt16BE(0), this.#r = c.READ_DATA;
            } else if (this.#r === c.PAYLOADLENGTH_64) {
              if (this.#e < 8)
                return i();
              const F = this.consume(8), m = F.readUInt32BE(0);
              if (m > 2 ** 31 - 1) {
                g(this.ws, "Received payload length > 2^31 bytes.");
                return;
              }
              const D = F.readUInt32BE(4);
              this.#t.payloadLength = (m << 8) + D, this.#r = c.READ_DATA;
            } else if (this.#r === c.READ_DATA) {
              if (this.#e < this.#t.payloadLength)
                return i();
              const F = this.consume(this.#t.payloadLength);
              if (M(this.#t.opcode))
                this.#n = this.parseControlFrame(F), this.#r = c.INFO;
              else if (this.#t.compressed) {
                this.#o.get("permessage-deflate").decompress(F, this.#t.fin, (m, D) => {
                  if (m) {
                    H(this.ws, 1007, m.message, m.message.length);
                    return;
                  }
                  if (this.#s.push(D), !this.#t.fin) {
                    this.#r = c.INFO, this.#n = true, this.run(i);
                    return;
                  }
                  d(this.ws, this.#t.binaryType, Buffer.concat(this.#s)), this.#n = true, this.#r = c.INFO, this.#s.length = 0, this.run(i);
                }), this.#n = false;
                break;
              } else {
                if (this.#s.push(F), !this.#t.fragmented && this.#t.fin) {
                  const m = Buffer.concat(this.#s);
                  d(this.ws, this.#t.binaryType, m), this.#s.length = 0;
                }
                this.#r = c.INFO;
              }
            }
        }
        consume(i) {
          if (i > this.#e)
            throw new Error("Called consume() before buffers satiated.");
          if (i === 0)
            return B;
          if (this.#A[0].length === i)
            return this.#e -= this.#A[0].length, this.#A.shift();
          const F = Buffer.allocUnsafe(i);
          let m = 0;
          for (; m !== i; ) {
            const D = this.#A[0], { length: S } = D;
            if (S + m === i) {
              F.set(this.#A.shift(), m);
              break;
            } else if (S + m > i) {
              F.set(D.subarray(0, i - m), m), this.#A[0] = D.subarray(i - m);
              break;
            } else
              F.set(this.#A.shift(), m), m += D.length;
          }
          return this.#e -= i, F;
        }
        parseCloseBody(i) {
          p(i.length !== 1);
          let F;
          if (i.length >= 2 && (F = i.readUInt16BE(0)), F !== void 0 && !o(F))
            return { code: 1002, reason: "Invalid status code", error: true };
          let m = i.subarray(2);
          m[0] === 239 && m[1] === 187 && m[2] === 191 && (m = m.subarray(3));
          try {
            m = N(m);
          } catch {
            return { code: 1007, reason: "Invalid UTF-8", error: true };
          }
          return { code: F, reason: m, error: false };
        }
        parseControlFrame(i) {
          const { opcode: F, payloadLength: m } = this.#t;
          if (F === E.CLOSE) {
            if (m === 1)
              return g(this.ws, "Received close frame with a 1-byte body."), false;
            if (this.#t.closeInfo = this.parseCloseBody(i), this.#t.closeInfo.error) {
              const { code: D, reason: S } = this.#t.closeInfo;
              return H(this.ws, D, S, S.length), g(this.ws, S), false;
            }
            if (this.ws[Q] !== f.SENT) {
              let D = B;
              this.#t.closeInfo.code && (D = Buffer.allocUnsafe(2), D.writeUInt16BE(this.#t.closeInfo.code, 0));
              const S = new V(D);
              this.ws[u].socket.write(S.createFrame(E.CLOSE), (W) => {
                W || (this.ws[Q] = f.SENT);
              });
            }
            return this.ws[l] = t.CLOSING, this.ws[n] = true, false;
          } else if (F === E.PING) {
            if (!this.ws[n]) {
              const D = new V(i);
              this.ws[u].socket.write(D.createFrame(E.PONG)), r.ping.hasSubscribers && r.ping.publish({ payload: i });
            }
          } else
            F === E.PONG && r.pong.hasSubscribers && r.pong.publish({ payload: i });
          return true;
        }
        get closingInfo() {
          return this.#t.closeInfo;
        }
      }
      return receiver = { ByteParser: I }, receiver;
    }
    e(requireReceiver, "requireReceiver");
    var sender;
    var hasRequiredSender;
    function requireSender() {
      if (hasRequiredSender)
        return sender;
      hasRequiredSender = 1;
      const { WebsocketFrameSend: A } = requireFrame(), { opcodes: p, sendHints: c } = requireConstants(), E = requireFixedQueue(), t = Buffer[Symbol.species];
      class B {
        static {
          e(this, "SendQueue");
        }
        #A = new E();
        #e = false;
        #n;
        constructor(u) {
          this.#n = u;
        }
        add(u, n, r) {
          if (r !== c.blob) {
            const a = f(u, r);
            if (!this.#e)
              this.#n.write(a, n);
            else {
              const g = { promise: null, callback: n, frame: a };
              this.#A.push(g);
            }
            return;
          }
          const o = { promise: u.arrayBuffer().then((a) => {
            o.promise = null, o.frame = f(a, r);
          }), callback: n, frame: null };
          this.#A.push(o), this.#e || this.#r();
        }
        async #r() {
          this.#e = true;
          const u = this.#A;
          for (; !u.isEmpty(); ) {
            const n = u.shift();
            n.promise !== null && await n.promise, this.#n.write(n.frame, n.callback), n.callback = n.frame = null;
          }
          this.#e = false;
        }
      }
      function f(Q, u) {
        return new A(l(Q, u)).createFrame(u === c.string ? p.TEXT : p.BINARY);
      }
      e(f, "createFrame");
      function l(Q, u) {
        switch (u) {
          case c.string:
            return Buffer.from(Q);
          case c.arrayBuffer:
          case c.blob:
            return new t(Q);
          case c.typedArray:
            return new t(Q.buffer, Q.byteOffset, Q.byteLength);
        }
      }
      return e(l, "toBuffer"), sender = { SendQueue: B }, sender;
    }
    e(requireSender, "requireSender");
    var websocket;
    var hasRequiredWebsocket;
    function requireWebsocket() {
      if (hasRequiredWebsocket)
        return websocket;
      hasRequiredWebsocket = 1;
      const { webidl: A } = requireWebidl(), { URLSerializer: p } = requireDataUrl(), { environmentSettingsObject: c } = requireUtil$6(), { staticPropertyDescriptors: E, states: t, sentCloseFrameState: B, sendHints: f } = requireConstants(), { kWebSocketURL: l, kReadyState: Q, kController: u, kBinaryType: n, kResponse: r, kSentClose: o, kByteParser: a } = requireSymbols(), { isConnecting: g, isEstablished: d, isClosing: N, isValidSubprotocol: M, fireEvent: Y } = requireUtil$1(), { establishWebSocketConnection: J, closeWebSocketConnection: V } = requireConnection(), { ByteParser: H } = requireReceiver(), { kEnumerableProperty: h, isBlobLike: I } = requireUtil$7(), { getGlobalDispatcher: k } = requireGlobal(), { types: i } = require$$0__default$3, { ErrorEvent: F, CloseEvent: m } = requireEvents(), { SendQueue: D } = requireSender();
      class S extends EventTarget {
        static {
          e(this, "WebSocket");
        }
        #A = { open: null, error: null, close: null, message: null };
        #e = 0;
        #n = "";
        #r = "";
        #t;
        constructor(P, Z = []) {
          super(), A.util.markAsUncloneable(this);
          const cA = "WebSocket constructor";
          A.argumentLengthCheck(arguments, 1, cA);
          const EA = A.converters["DOMString or sequence<DOMString> or WebSocketInit"](Z, cA, "options");
          P = A.converters.USVString(P, cA, "url"), Z = EA.protocols;
          const fA = c.settingsObject.baseUrl;
          let uA;
          try {
            uA = new URL(P, fA);
          } catch (RA) {
            throw new DOMException(RA, "SyntaxError");
          }
          if (uA.protocol === "http:" ? uA.protocol = "ws:" : uA.protocol === "https:" && (uA.protocol = "wss:"), uA.protocol !== "ws:" && uA.protocol !== "wss:")
            throw new DOMException(`Expected a ws: or wss: protocol, got ${uA.protocol}`, "SyntaxError");
          if (uA.hash || uA.href.endsWith("#"))
            throw new DOMException("Got fragment", "SyntaxError");
          if (typeof Z == "string" && (Z = [Z]), Z.length !== new Set(Z.map((RA) => RA.toLowerCase())).size)
            throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
          if (Z.length > 0 && !Z.every((RA) => M(RA)))
            throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
          this[l] = new URL(uA.href);
          const pA = c.settingsObject;
          this[u] = J(uA, Z, pA, this, (RA, DA) => this.#s(RA, DA), EA), this[Q] = S.CONNECTING, this[o] = B.NOT_SENT, this[n] = "blob";
        }
        close(P = void 0, Z = void 0) {
          A.brandCheck(this, S);
          const cA = "WebSocket.close";
          if (P !== void 0 && (P = A.converters["unsigned short"](P, cA, "code", { clamp: true })), Z !== void 0 && (Z = A.converters.USVString(Z, cA, "reason")), P !== void 0 && P !== 1e3 && (P < 3e3 || P > 4999))
            throw new DOMException("invalid code", "InvalidAccessError");
          let EA = 0;
          if (Z !== void 0 && (EA = Buffer.byteLength(Z), EA > 123))
            throw new DOMException(`Reason must be less than 123 bytes; received ${EA}`, "SyntaxError");
          V(this, P, Z, EA);
        }
        send(P) {
          A.brandCheck(this, S);
          const Z = "WebSocket.send";
          if (A.argumentLengthCheck(arguments, 1, Z), P = A.converters.WebSocketSendData(P, Z, "data"), g(this))
            throw new DOMException("Sent before connected.", "InvalidStateError");
          if (!(!d(this) || N(this)))
            if (typeof P == "string") {
              const cA = Buffer.byteLength(P);
              this.#e += cA, this.#t.add(P, () => {
                this.#e -= cA;
              }, f.string);
            } else
              i.isArrayBuffer(P) ? (this.#e += P.byteLength, this.#t.add(P, () => {
                this.#e -= P.byteLength;
              }, f.arrayBuffer)) : ArrayBuffer.isView(P) ? (this.#e += P.byteLength, this.#t.add(P, () => {
                this.#e -= P.byteLength;
              }, f.typedArray)) : I(P) && (this.#e += P.size, this.#t.add(P, () => {
                this.#e -= P.size;
              }, f.blob));
        }
        get readyState() {
          return A.brandCheck(this, S), this[Q];
        }
        get bufferedAmount() {
          return A.brandCheck(this, S), this.#e;
        }
        get url() {
          return A.brandCheck(this, S), p(this[l]);
        }
        get extensions() {
          return A.brandCheck(this, S), this.#r;
        }
        get protocol() {
          return A.brandCheck(this, S), this.#n;
        }
        get onopen() {
          return A.brandCheck(this, S), this.#A.open;
        }
        set onopen(P) {
          A.brandCheck(this, S), this.#A.open && this.removeEventListener("open", this.#A.open), typeof P == "function" ? (this.#A.open = P, this.addEventListener("open", P)) : this.#A.open = null;
        }
        get onerror() {
          return A.brandCheck(this, S), this.#A.error;
        }
        set onerror(P) {
          A.brandCheck(this, S), this.#A.error && this.removeEventListener("error", this.#A.error), typeof P == "function" ? (this.#A.error = P, this.addEventListener("error", P)) : this.#A.error = null;
        }
        get onclose() {
          return A.brandCheck(this, S), this.#A.close;
        }
        set onclose(P) {
          A.brandCheck(this, S), this.#A.close && this.removeEventListener("close", this.#A.close), typeof P == "function" ? (this.#A.close = P, this.addEventListener("close", P)) : this.#A.close = null;
        }
        get onmessage() {
          return A.brandCheck(this, S), this.#A.message;
        }
        set onmessage(P) {
          A.brandCheck(this, S), this.#A.message && this.removeEventListener("message", this.#A.message), typeof P == "function" ? (this.#A.message = P, this.addEventListener("message", P)) : this.#A.message = null;
        }
        get binaryType() {
          return A.brandCheck(this, S), this[n];
        }
        set binaryType(P) {
          A.brandCheck(this, S), P !== "blob" && P !== "arraybuffer" ? this[n] = "blob" : this[n] = P;
        }
        #s(P, Z) {
          this[r] = P;
          const cA = new H(this, Z);
          cA.on("drain", W), cA.on("error", q.bind(this)), P.socket.ws = this, this[a] = cA, this.#t = new D(P.socket), this[Q] = t.OPEN;
          const EA = P.headersList.get("sec-websocket-extensions");
          EA !== null && (this.#r = EA);
          const fA = P.headersList.get("sec-websocket-protocol");
          fA !== null && (this.#n = fA), Y("open", this);
        }
      }
      S.CONNECTING = S.prototype.CONNECTING = t.CONNECTING, S.OPEN = S.prototype.OPEN = t.OPEN, S.CLOSING = S.prototype.CLOSING = t.CLOSING, S.CLOSED = S.prototype.CLOSED = t.CLOSED, Object.defineProperties(S.prototype, { CONNECTING: E, OPEN: E, CLOSING: E, CLOSED: E, url: h, readyState: h, bufferedAmount: h, onopen: h, onerror: h, onclose: h, close: h, onmessage: h, binaryType: h, send: h, extensions: h, protocol: h, [Symbol.toStringTag]: { value: "WebSocket", writable: false, enumerable: false, configurable: true } }), Object.defineProperties(S, { CONNECTING: E, OPEN: E, CLOSING: E, CLOSED: E }), A.converters["sequence<DOMString>"] = A.sequenceConverter(A.converters.DOMString), A.converters["DOMString or sequence<DOMString>"] = function(O, P, Z) {
        return A.util.Type(O) === "Object" && Symbol.iterator in O ? A.converters["sequence<DOMString>"](O) : A.converters.DOMString(O, P, Z);
      }, A.converters.WebSocketInit = A.dictionaryConverter([{ key: "protocols", converter: A.converters["DOMString or sequence<DOMString>"], defaultValue: e(() => new Array(0), "defaultValue") }, { key: "dispatcher", converter: A.converters.any, defaultValue: e(() => k(), "defaultValue") }, { key: "headers", converter: A.nullableConverter(A.converters.HeadersInit) }]), A.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(O) {
        return A.util.Type(O) === "Object" && !(Symbol.iterator in O) ? A.converters.WebSocketInit(O) : { protocols: A.converters["DOMString or sequence<DOMString>"](O) };
      }, A.converters.WebSocketSendData = function(O) {
        if (A.util.Type(O) === "Object") {
          if (I(O))
            return A.converters.Blob(O, { strict: false });
          if (ArrayBuffer.isView(O) || i.isArrayBuffer(O))
            return A.converters.BufferSource(O);
        }
        return A.converters.USVString(O);
      };
      function W() {
        this.ws[r].socket.resume();
      }
      e(W, "onParserDrain");
      function q(O) {
        let P, Z;
        O instanceof m ? (P = O.reason, Z = O.code) : P = O.message, Y("error", this, () => new F("error", { error: O, message: P })), V(this, Z);
      }
      return e(q, "onParserError"), websocket = { WebSocket: S }, websocket;
    }
    e(requireWebsocket, "requireWebsocket");
    var util;
    var hasRequiredUtil;
    function requireUtil() {
      if (hasRequiredUtil)
        return util;
      hasRequiredUtil = 1;
      function A(E) {
        return E.indexOf("\0") === -1;
      }
      e(A, "isValidLastEventId");
      function p(E) {
        if (E.length === 0)
          return false;
        for (let t = 0; t < E.length; t++)
          if (E.charCodeAt(t) < 48 || E.charCodeAt(t) > 57)
            return false;
        return true;
      }
      e(p, "isASCIINumber");
      function c(E) {
        return new Promise((t) => {
          setTimeout(t, E).unref();
        });
      }
      return e(c, "delay"), util = { isValidLastEventId: A, isASCIINumber: p, delay: c }, util;
    }
    e(requireUtil, "requireUtil");
    var eventsourceStream;
    var hasRequiredEventsourceStream;
    function requireEventsourceStream() {
      if (hasRequiredEventsourceStream)
        return eventsourceStream;
      hasRequiredEventsourceStream = 1;
      const { Transform: A } = Stream__default, { isASCIINumber: p, isValidLastEventId: c } = requireUtil(), E = [239, 187, 191], t = 10, B = 13, f = 58, l = 32;
      class Q extends A {
        static {
          e(this, "EventSourceStream");
        }
        state = null;
        checkBOM = true;
        crlfCheck = false;
        eventEndCheck = false;
        buffer = null;
        pos = 0;
        event = { data: void 0, event: void 0, id: void 0, retry: void 0 };
        constructor(n = {}) {
          n.readableObjectMode = true, super(n), this.state = n.eventSourceSettings || {}, n.push && (this.push = n.push);
        }
        _transform(n, r, o) {
          if (n.length === 0) {
            o();
            return;
          }
          if (this.buffer ? this.buffer = Buffer.concat([this.buffer, n]) : this.buffer = n, this.checkBOM)
            switch (this.buffer.length) {
              case 1:
                if (this.buffer[0] === E[0]) {
                  o();
                  return;
                }
                this.checkBOM = false, o();
                return;
              case 2:
                if (this.buffer[0] === E[0] && this.buffer[1] === E[1]) {
                  o();
                  return;
                }
                this.checkBOM = false;
                break;
              case 3:
                if (this.buffer[0] === E[0] && this.buffer[1] === E[1] && this.buffer[2] === E[2]) {
                  this.buffer = Buffer.alloc(0), this.checkBOM = false, o();
                  return;
                }
                this.checkBOM = false;
                break;
              default:
                this.buffer[0] === E[0] && this.buffer[1] === E[1] && this.buffer[2] === E[2] && (this.buffer = this.buffer.subarray(3)), this.checkBOM = false;
                break;
            }
          for (; this.pos < this.buffer.length; ) {
            if (this.eventEndCheck) {
              if (this.crlfCheck) {
                if (this.buffer[this.pos] === t) {
                  this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, this.crlfCheck = false;
                  continue;
                }
                this.crlfCheck = false;
              }
              if (this.buffer[this.pos] === t || this.buffer[this.pos] === B) {
                this.buffer[this.pos] === B && (this.crlfCheck = true), this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, (this.event.data !== void 0 || this.event.event || this.event.id || this.event.retry) && this.processEvent(this.event), this.clearEvent();
                continue;
              }
              this.eventEndCheck = false;
              continue;
            }
            if (this.buffer[this.pos] === t || this.buffer[this.pos] === B) {
              this.buffer[this.pos] === B && (this.crlfCheck = true), this.parseLine(this.buffer.subarray(0, this.pos), this.event), this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, this.eventEndCheck = true;
              continue;
            }
            this.pos++;
          }
          o();
        }
        parseLine(n, r) {
          if (n.length === 0)
            return;
          const o = n.indexOf(f);
          if (o === 0)
            return;
          let a = "", g = "";
          if (o !== -1) {
            a = n.subarray(0, o).toString("utf8");
            let d = o + 1;
            n[d] === l && ++d, g = n.subarray(d).toString("utf8");
          } else
            a = n.toString("utf8"), g = "";
          switch (a) {
            case "data":
              r[a] === void 0 ? r[a] = g : r[a] += `
${g}`;
              break;
            case "retry":
              p(g) && (r[a] = g);
              break;
            case "id":
              c(g) && (r[a] = g);
              break;
            case "event":
              g.length > 0 && (r[a] = g);
              break;
          }
        }
        processEvent(n) {
          n.retry && p(n.retry) && (this.state.reconnectionTime = parseInt(n.retry, 10)), n.id && c(n.id) && (this.state.lastEventId = n.id), n.data !== void 0 && this.push({ type: n.event || "message", options: { data: n.data, lastEventId: this.state.lastEventId, origin: this.state.origin } });
        }
        clearEvent() {
          this.event = { data: void 0, event: void 0, id: void 0, retry: void 0 };
        }
      }
      return eventsourceStream = { EventSourceStream: Q }, eventsourceStream;
    }
    e(requireEventsourceStream, "requireEventsourceStream");
    var eventsource;
    var hasRequiredEventsource;
    function requireEventsource() {
      if (hasRequiredEventsource)
        return eventsource;
      hasRequiredEventsource = 1;
      const { pipeline: A } = Stream__default, { fetching: p } = requireFetch(), { makeRequest: c } = requireRequest(), { webidl: E } = requireWebidl(), { EventSourceStream: t } = requireEventsourceStream(), { parseMIMEType: B } = requireDataUrl(), { createFastMessageEvent: f } = requireEvents(), { isNetworkError: l } = requireResponse(), { delay: Q } = requireUtil(), { kEnumerableProperty: u } = requireUtil$7(), { environmentSettingsObject: n } = requireUtil$6();
      let r = false;
      const o = 3e3, a = 0, g = 1, d = 2, N = "anonymous", M = "use-credentials";
      class Y extends EventTarget {
        static {
          e(this, "EventSource");
        }
        #A = { open: null, error: null, message: null };
        #e = null;
        #n = false;
        #r = a;
        #t = null;
        #s = null;
        #o;
        #i;
        constructor(H, h = {}) {
          super(), E.util.markAsUncloneable(this);
          const I = "EventSource constructor";
          E.argumentLengthCheck(arguments, 1, I), r || (r = true, process.emitWarning("EventSource is experimental, expect them to change at any time.", { code: "UNDICI-ES" })), H = E.converters.USVString(H, I, "url"), h = E.converters.EventSourceInitDict(h, I, "eventSourceInitDict"), this.#o = h.dispatcher, this.#i = { lastEventId: "", reconnectionTime: o };
          const k = n;
          let i;
          try {
            i = new URL(H, k.settingsObject.baseUrl), this.#i.origin = i.origin;
          } catch (D) {
            throw new DOMException(D, "SyntaxError");
          }
          this.#e = i.href;
          let F = N;
          h.withCredentials && (F = M, this.#n = true);
          const m = { redirect: "follow", keepalive: true, mode: "cors", credentials: F === "anonymous" ? "same-origin" : "omit", referrer: "no-referrer" };
          m.client = n.settingsObject, m.headersList = [["accept", { name: "accept", value: "text/event-stream" }]], m.cache = "no-store", m.initiator = "other", m.urlList = [new URL(this.#e)], this.#t = c(m), this.#a();
        }
        get readyState() {
          return this.#r;
        }
        get url() {
          return this.#e;
        }
        get withCredentials() {
          return this.#n;
        }
        #a() {
          if (this.#r === d)
            return;
          this.#r = a;
          const H = { request: this.#t, dispatcher: this.#o }, h = e((I) => {
            l(I) && (this.dispatchEvent(new Event("error")), this.close()), this.#g();
          }, "processEventSourceEndOfBody");
          H.processResponseEndOfBody = h, H.processResponse = (I) => {
            if (l(I))
              if (I.aborted) {
                this.close(), this.dispatchEvent(new Event("error"));
                return;
              } else {
                this.#g();
                return;
              }
            const k = I.headersList.get("content-type", true), i = k !== null ? B(k) : "failure", F = i !== "failure" && i.essence === "text/event-stream";
            if (I.status !== 200 || F === false) {
              this.close(), this.dispatchEvent(new Event("error"));
              return;
            }
            this.#r = g, this.dispatchEvent(new Event("open")), this.#i.origin = I.urlList[I.urlList.length - 1].origin;
            const m = new t({ eventSourceSettings: this.#i, push: e((D) => {
              this.dispatchEvent(f(D.type, D.options));
            }, "push") });
            A(I.body.stream, m, (D) => {
              D?.aborted === false && (this.close(), this.dispatchEvent(new Event("error")));
            });
          }, this.#s = p(H);
        }
        async #g() {
          this.#r !== d && (this.#r = a, this.dispatchEvent(new Event("error")), await Q(this.#i.reconnectionTime), this.#r === a && (this.#i.lastEventId.length && this.#t.headersList.set("last-event-id", this.#i.lastEventId, true), this.#a()));
        }
        close() {
          E.brandCheck(this, Y), this.#r !== d && (this.#r = d, this.#s.abort(), this.#t = null);
        }
        get onopen() {
          return this.#A.open;
        }
        set onopen(H) {
          this.#A.open && this.removeEventListener("open", this.#A.open), typeof H == "function" ? (this.#A.open = H, this.addEventListener("open", H)) : this.#A.open = null;
        }
        get onmessage() {
          return this.#A.message;
        }
        set onmessage(H) {
          this.#A.message && this.removeEventListener("message", this.#A.message), typeof H == "function" ? (this.#A.message = H, this.addEventListener("message", H)) : this.#A.message = null;
        }
        get onerror() {
          return this.#A.error;
        }
        set onerror(H) {
          this.#A.error && this.removeEventListener("error", this.#A.error), typeof H == "function" ? (this.#A.error = H, this.addEventListener("error", H)) : this.#A.error = null;
        }
      }
      const J = { CONNECTING: { __proto__: null, configurable: false, enumerable: true, value: a, writable: false }, OPEN: { __proto__: null, configurable: false, enumerable: true, value: g, writable: false }, CLOSED: { __proto__: null, configurable: false, enumerable: true, value: d, writable: false } };
      return Object.defineProperties(Y, J), Object.defineProperties(Y.prototype, J), Object.defineProperties(Y.prototype, { close: u, onerror: u, onmessage: u, onopen: u, readyState: u, url: u, withCredentials: u }), E.converters.EventSourceInitDict = E.dictionaryConverter([{ key: "withCredentials", converter: E.converters.boolean, defaultValue: e(() => false, "defaultValue") }, { key: "dispatcher", converter: E.converters.any }]), eventsource = { EventSource: Y, defaultReconnectionTime: o }, eventsource;
    }
    e(requireEventsource, "requireEventsource");
    var hasRequiredUndici;
    function requireUndici() {
      if (hasRequiredUndici)
        return undici;
      hasRequiredUndici = 1;
      const A = requireClient(), p = requireDispatcher(), c = requirePool(), E = requireBalancedPool(), t = requireAgent(), B = requireProxyAgent(), f = requireEnvHttpProxyAgent(), l = requireRetryAgent(), Q = requireErrors(), u = requireUtil$7(), { InvalidArgumentError: n } = Q, r = requireApi(), o = requireConnect(), a = requireMockClient(), g = requireMockAgent(), d = requireMockPool(), N = requireMockErrors(), M = requireRetryHandler(), { getGlobalDispatcher: Y, setGlobalDispatcher: J } = requireGlobal(), V = requireDecoratorHandler(), H = requireRedirectHandler(), h = requireRedirectInterceptor();
      Object.assign(p.prototype, r), undici.Dispatcher = p, undici.Client = A, undici.Pool = c, undici.BalancedPool = E, undici.Agent = t, undici.ProxyAgent = B, undici.EnvHttpProxyAgent = f, undici.RetryAgent = l, undici.RetryHandler = M, undici.DecoratorHandler = V, undici.RedirectHandler = H, undici.createRedirectInterceptor = h, undici.interceptors = { redirect: requireRedirect(), retry: requireRetry(), dump: requireDump(), dns: requireDns() }, undici.buildConnector = o, undici.errors = Q, undici.util = { parseHeaders: u.parseHeaders, headerNameToString: u.headerNameToString };
      function I(pA) {
        return (RA, DA, TA) => {
          if (typeof DA == "function" && (TA = DA, DA = null), !RA || typeof RA != "string" && typeof RA != "object" && !(RA instanceof URL))
            throw new n("invalid url");
          if (DA != null && typeof DA != "object")
            throw new n("invalid opts");
          if (DA && DA.path != null) {
            if (typeof DA.path != "string")
              throw new n("invalid opts.path");
            let eA = DA.path;
            DA.path.startsWith("/") || (eA = `/${eA}`), RA = new URL(u.parseOrigin(RA).origin + eA);
          } else
            DA || (DA = typeof RA == "object" ? RA : {}), RA = u.parseURL(RA);
          const { agent: UA, dispatcher: QA = Y() } = DA;
          if (UA)
            throw new n("unsupported opts.agent. Did you mean opts.client?");
          return pA.call(QA, { ...DA, origin: RA.origin, path: RA.search ? `${RA.pathname}${RA.search}` : RA.pathname, method: DA.method || (DA.body ? "PUT" : "GET") }, TA);
        };
      }
      e(I, "makeDispatcher"), undici.setGlobalDispatcher = J, undici.getGlobalDispatcher = Y;
      const k = requireFetch().fetch;
      undici.fetch = e(async function(RA, DA = void 0) {
        try {
          return await k(RA, DA);
        } catch (TA) {
          throw TA && typeof TA == "object" && Error.captureStackTrace(TA), TA;
        }
      }, "fetch"), undici.Headers = requireHeaders().Headers, undici.Response = requireResponse().Response, undici.Request = requireRequest().Request, undici.FormData = requireFormdata().FormData, undici.File = globalThis.File ?? require$$0__default$2.File, undici.FileReader = requireFilereader().FileReader;
      const { setGlobalOrigin: i, getGlobalOrigin: F } = requireGlobal$1();
      undici.setGlobalOrigin = i, undici.getGlobalOrigin = F;
      const { CacheStorage: m } = requireCachestorage(), { kConstruct: D } = requireSymbols$1();
      undici.caches = new m(D);
      const { deleteCookie: S, getCookies: W, getSetCookies: q, setCookie: O } = requireCookies();
      undici.deleteCookie = S, undici.getCookies = W, undici.getSetCookies = q, undici.setCookie = O;
      const { parseMIMEType: P, serializeAMimeType: Z } = requireDataUrl();
      undici.parseMIMEType = P, undici.serializeAMimeType = Z;
      const { CloseEvent: cA, ErrorEvent: EA, MessageEvent: fA } = requireEvents();
      undici.WebSocket = requireWebsocket().WebSocket, undici.CloseEvent = cA, undici.ErrorEvent = EA, undici.MessageEvent = fA, undici.request = I(r.request), undici.stream = I(r.stream), undici.pipeline = I(r.pipeline), undici.connect = I(r.connect), undici.upgrade = I(r.upgrade), undici.MockClient = a, undici.MockPool = d, undici.MockAgent = g, undici.mockErrors = N;
      const { EventSource: uA } = requireEventsource();
      return undici.EventSource = uA, undici;
    }
    e(requireUndici, "requireUndici");
    var undiciExports = requireUndici();
    var dist$2 = {};
    var helpers = {};
    var hasRequiredHelpers;
    function requireHelpers() {
      if (hasRequiredHelpers)
        return helpers;
      hasRequiredHelpers = 1;
      var A = helpers.__createBinding || (Object.create ? function(Q, u, n, r) {
        r === void 0 && (r = n);
        var o = Object.getOwnPropertyDescriptor(u, n);
        (!o || ("get" in o ? !u.__esModule : o.writable || o.configurable)) && (o = { enumerable: true, get: e(function() {
          return u[n];
        }, "get") }), Object.defineProperty(Q, r, o);
      } : function(Q, u, n, r) {
        r === void 0 && (r = n), Q[r] = u[n];
      }), p = helpers.__setModuleDefault || (Object.create ? function(Q, u) {
        Object.defineProperty(Q, "default", { enumerable: true, value: u });
      } : function(Q, u) {
        Q.default = u;
      }), c = helpers.__importStar || function(Q) {
        if (Q && Q.__esModule)
          return Q;
        var u = {};
        if (Q != null)
          for (var n in Q)
            n !== "default" && Object.prototype.hasOwnProperty.call(Q, n) && A(u, Q, n);
        return p(u, Q), u;
      };
      Object.defineProperty(helpers, "__esModule", { value: true }), helpers.req = helpers.json = helpers.toBuffer = void 0;
      const E = c(require$$0__default$5), t = c(require$$1__default$4);
      async function B(Q) {
        let u = 0;
        const n = [];
        for await (const r of Q)
          u += r.length, n.push(r);
        return Buffer.concat(n, u);
      }
      e(B, "toBuffer"), helpers.toBuffer = B;
      async function f(Q) {
        const n = (await B(Q)).toString("utf8");
        try {
          return JSON.parse(n);
        } catch (r) {
          const o = r;
          throw o.message += ` (input: ${n})`, o;
        }
      }
      e(f, "json"), helpers.json = f;
      function l(Q, u = {}) {
        const r = ((typeof Q == "string" ? Q : Q.href).startsWith("https:") ? t : E).request(Q, u), o = new Promise((a, g) => {
          r.once("response", a).once("error", g).end();
        });
        return r.then = o.then.bind(o), r;
      }
      return e(l, "req"), helpers.req = l, helpers;
    }
    e(requireHelpers, "requireHelpers");
    var hasRequiredDist$2;
    function requireDist$2() {
      return hasRequiredDist$2 || (hasRequiredDist$2 = 1, function(A) {
        var p = dist$2.__createBinding || (Object.create ? function(n, r, o, a) {
          a === void 0 && (a = o);
          var g = Object.getOwnPropertyDescriptor(r, o);
          (!g || ("get" in g ? !r.__esModule : g.writable || g.configurable)) && (g = { enumerable: true, get: e(function() {
            return r[o];
          }, "get") }), Object.defineProperty(n, a, g);
        } : function(n, r, o, a) {
          a === void 0 && (a = o), n[a] = r[o];
        }), c = dist$2.__setModuleDefault || (Object.create ? function(n, r) {
          Object.defineProperty(n, "default", { enumerable: true, value: r });
        } : function(n, r) {
          n.default = r;
        }), E = dist$2.__importStar || function(n) {
          if (n && n.__esModule)
            return n;
          var r = {};
          if (n != null)
            for (var o in n)
              o !== "default" && Object.prototype.hasOwnProperty.call(n, o) && p(r, n, o);
          return c(r, n), r;
        }, t = dist$2.__exportStar || function(n, r) {
          for (var o in n)
            o !== "default" && !Object.prototype.hasOwnProperty.call(r, o) && p(r, n, o);
        };
        Object.defineProperty(A, "__esModule", { value: true }), A.Agent = void 0;
        const B = E(require$$0__default$6), f = E(require$$0__default$5), l = require$$1__default$4;
        t(requireHelpers(), A);
        const Q = Symbol("AgentBaseInternalState");
        class u extends f.Agent {
          static {
            e(this, "Agent");
          }
          constructor(r) {
            super(r), this[Q] = {};
          }
          isSecureEndpoint(r) {
            if (r) {
              if (typeof r.secureEndpoint == "boolean")
                return r.secureEndpoint;
              if (typeof r.protocol == "string")
                return r.protocol === "https:";
            }
            const { stack: o } = new Error();
            return typeof o != "string" ? false : o.split(`
`).some((a) => a.indexOf("(https.js:") !== -1 || a.indexOf("node:https:") !== -1);
          }
          incrementSockets(r) {
            if (this.maxSockets === 1 / 0 && this.maxTotalSockets === 1 / 0)
              return null;
            this.sockets[r] || (this.sockets[r] = []);
            const o = new B.Socket({ writable: false });
            return this.sockets[r].push(o), this.totalSocketCount++, o;
          }
          decrementSockets(r, o) {
            if (!this.sockets[r] || o === null)
              return;
            const a = this.sockets[r], g = a.indexOf(o);
            g !== -1 && (a.splice(g, 1), this.totalSocketCount--, a.length === 0 && delete this.sockets[r]);
          }
          getName(r) {
            return (typeof r.secureEndpoint == "boolean" ? r.secureEndpoint : this.isSecureEndpoint(r)) ? l.Agent.prototype.getName.call(this, r) : super.getName(r);
          }
          createSocket(r, o, a) {
            const g = { ...o, secureEndpoint: this.isSecureEndpoint(o) }, d = this.getName(g), N = this.incrementSockets(d);
            Promise.resolve().then(() => this.connect(r, g)).then((M) => {
              if (this.decrementSockets(d, N), M instanceof f.Agent)
                try {
                  return M.addRequest(r, g);
                } catch (Y) {
                  return a(Y);
                }
              this[Q].currentSocket = M, super.createSocket(r, o, a);
            }, (M) => {
              this.decrementSockets(d, N), a(M);
            });
          }
          createConnection() {
            const r = this[Q].currentSocket;
            if (this[Q].currentSocket = void 0, !r)
              throw new Error("No socket was returned in the `connect()` function");
            return r;
          }
          get defaultPort() {
            return this[Q].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
          }
          set defaultPort(r) {
            this[Q] && (this[Q].defaultPort = r);
          }
          get protocol() {
            return this[Q].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
          }
          set protocol(r) {
            this[Q] && (this[Q].protocol = r);
          }
        }
        A.Agent = u;
      }(dist$2)), dist$2;
    }
    e(requireDist$2, "requireDist$2");
    var distExports$2 = requireDist$2();
    var dist$1 = {};
    var src = { exports: {} };
    var browser = { exports: {} };
    var ms;
    var hasRequiredMs;
    function requireMs() {
      if (hasRequiredMs)
        return ms;
      hasRequiredMs = 1;
      var A = 1e3, p = A * 60, c = p * 60, E = c * 24, t = E * 7, B = E * 365.25;
      ms = e(function(n, r) {
        r = r || {};
        var o = typeof n;
        if (o === "string" && n.length > 0)
          return f(n);
        if (o === "number" && isFinite(n))
          return r.long ? Q(n) : l(n);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(n));
      }, "ms");
      function f(n) {
        if (n = String(n), !(n.length > 100)) {
          var r = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(n);
          if (r) {
            var o = parseFloat(r[1]), a = (r[2] || "ms").toLowerCase();
            switch (a) {
              case "years":
              case "year":
              case "yrs":
              case "yr":
              case "y":
                return o * B;
              case "weeks":
              case "week":
              case "w":
                return o * t;
              case "days":
              case "day":
              case "d":
                return o * E;
              case "hours":
              case "hour":
              case "hrs":
              case "hr":
              case "h":
                return o * c;
              case "minutes":
              case "minute":
              case "mins":
              case "min":
              case "m":
                return o * p;
              case "seconds":
              case "second":
              case "secs":
              case "sec":
              case "s":
                return o * A;
              case "milliseconds":
              case "millisecond":
              case "msecs":
              case "msec":
              case "ms":
                return o;
              default:
                return;
            }
          }
        }
      }
      e(f, "parse");
      function l(n) {
        var r = Math.abs(n);
        return r >= E ? Math.round(n / E) + "d" : r >= c ? Math.round(n / c) + "h" : r >= p ? Math.round(n / p) + "m" : r >= A ? Math.round(n / A) + "s" : n + "ms";
      }
      e(l, "fmtShort");
      function Q(n) {
        var r = Math.abs(n);
        return r >= E ? u(n, r, E, "day") : r >= c ? u(n, r, c, "hour") : r >= p ? u(n, r, p, "minute") : r >= A ? u(n, r, A, "second") : n + " ms";
      }
      e(Q, "fmtLong");
      function u(n, r, o, a) {
        var g = r >= o * 1.5;
        return Math.round(n / o) + " " + a + (g ? "s" : "");
      }
      return e(u, "plural"), ms;
    }
    e(requireMs, "requireMs");
    var common2;
    var hasRequiredCommon;
    function requireCommon() {
      if (hasRequiredCommon)
        return common2;
      hasRequiredCommon = 1;
      function A(p) {
        E.debug = E, E.default = E, E.coerce = u, E.disable = l, E.enable = B, E.enabled = Q, E.humanize = requireMs(), E.destroy = n, Object.keys(p).forEach((r) => {
          E[r] = p[r];
        }), E.names = [], E.skips = [], E.formatters = {};
        function c(r) {
          let o = 0;
          for (let a = 0; a < r.length; a++)
            o = (o << 5) - o + r.charCodeAt(a), o |= 0;
          return E.colors[Math.abs(o) % E.colors.length];
        }
        e(c, "selectColor"), E.selectColor = c;
        function E(r) {
          let o, a = null, g, d;
          function N(...M) {
            if (!N.enabled)
              return;
            const Y = N, J = Number(new Date()), V = J - (o || J);
            Y.diff = V, Y.prev = o, Y.curr = J, o = J, M[0] = E.coerce(M[0]), typeof M[0] != "string" && M.unshift("%O");
            let H = 0;
            M[0] = M[0].replace(/%([a-zA-Z%])/g, (I, k) => {
              if (I === "%%")
                return "%";
              H++;
              const i = E.formatters[k];
              if (typeof i == "function") {
                const F = M[H];
                I = i.call(Y, F), M.splice(H, 1), H--;
              }
              return I;
            }), E.formatArgs.call(Y, M), (Y.log || E.log).apply(Y, M);
          }
          return e(N, "debug"), N.namespace = r, N.useColors = E.useColors(), N.color = E.selectColor(r), N.extend = t, N.destroy = E.destroy, Object.defineProperty(N, "enabled", { enumerable: true, configurable: false, get: e(() => a !== null ? a : (g !== E.namespaces && (g = E.namespaces, d = E.enabled(r)), d), "get"), set: e((M) => {
            a = M;
          }, "set") }), typeof E.init == "function" && E.init(N), N;
        }
        e(E, "createDebug");
        function t(r, o) {
          const a = E(this.namespace + (typeof o > "u" ? ":" : o) + r);
          return a.log = this.log, a;
        }
        e(t, "extend");
        function B(r) {
          E.save(r), E.namespaces = r, E.names = [], E.skips = [];
          const o = (typeof r == "string" ? r : "").trim().replace(" ", ",").split(",").filter(Boolean);
          for (const a of o)
            a[0] === "-" ? E.skips.push(a.slice(1)) : E.names.push(a);
        }
        e(B, "enable");
        function f(r, o) {
          let a = 0, g = 0, d = -1, N = 0;
          for (; a < r.length; )
            if (g < o.length && (o[g] === r[a] || o[g] === "*"))
              o[g] === "*" ? (d = g, N = a, g++) : (a++, g++);
            else if (d !== -1)
              g = d + 1, N++, a = N;
            else
              return false;
          for (; g < o.length && o[g] === "*"; )
            g++;
          return g === o.length;
        }
        e(f, "matchesTemplate");
        function l() {
          const r = [...E.names, ...E.skips.map((o) => "-" + o)].join(",");
          return E.enable(""), r;
        }
        e(l, "disable");
        function Q(r) {
          for (const o of E.skips)
            if (f(r, o))
              return false;
          for (const o of E.names)
            if (f(r, o))
              return true;
          return false;
        }
        e(Q, "enabled");
        function u(r) {
          return r instanceof Error ? r.stack || r.message : r;
        }
        e(u, "coerce");
        function n() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        return e(n, "destroy"), E.enable(E.load()), E;
      }
      return e(A, "setup"), common2 = A, common2;
    }
    e(requireCommon, "requireCommon");
    var hasRequiredBrowser;
    function requireBrowser() {
      return hasRequiredBrowser || (hasRequiredBrowser = 1, function(A, p) {
        p.formatArgs = E, p.save = t, p.load = B, p.useColors = c, p.storage = f(), p.destroy = (() => {
          let Q = false;
          return () => {
            Q || (Q = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
          };
        })(), p.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
        function c() {
          if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
            return true;
          if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
            return false;
          let Q;
          return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && (Q = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(Q[1], 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }
        e(c, "useColors");
        function E(Q) {
          if (Q[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + Q[0] + (this.useColors ? "%c " : " ") + "+" + A.exports.humanize(this.diff), !this.useColors)
            return;
          const u = "color: " + this.color;
          Q.splice(1, 0, u, "color: inherit");
          let n = 0, r = 0;
          Q[0].replace(/%[a-zA-Z%]/g, (o) => {
            o !== "%%" && (n++, o === "%c" && (r = n));
          }), Q.splice(r, 0, u);
        }
        e(E, "formatArgs"), p.log = console.debug || console.log || (() => {
        });
        function t(Q) {
          try {
            Q ? p.storage.setItem("debug", Q) : p.storage.removeItem("debug");
          } catch {
          }
        }
        e(t, "save");
        function B() {
          let Q;
          try {
            Q = p.storage.getItem("debug");
          } catch {
          }
          return !Q && typeof process < "u" && "env" in process && (Q = process.env.DEBUG), Q;
        }
        e(B, "load");
        function f() {
          try {
            return localStorage;
          } catch {
          }
        }
        e(f, "localstorage"), A.exports = requireCommon()(p);
        const { formatters: l } = A.exports;
        l.j = function(Q) {
          try {
            return JSON.stringify(Q);
          } catch (u) {
            return "[UnexpectedJSONParseError]: " + u.message;
          }
        };
      }(browser, browser.exports)), browser.exports;
    }
    e(requireBrowser, "requireBrowser");
    var node = { exports: {} };
    var hasFlag2;
    var hasRequiredHasFlag;
    function requireHasFlag() {
      return hasRequiredHasFlag || (hasRequiredHasFlag = 1, hasFlag2 = e((A, p = process.argv) => {
        const c = A.startsWith("-") ? "" : A.length === 1 ? "-" : "--", E = p.indexOf(c + A), t = p.indexOf("--");
        return E !== -1 && (t === -1 || E < t);
      }, "hasFlag")), hasFlag2;
    }
    e(requireHasFlag, "requireHasFlag");
    var supportsColor_1;
    var hasRequiredSupportsColor;
    function requireSupportsColor() {
      if (hasRequiredSupportsColor)
        return supportsColor_1;
      hasRequiredSupportsColor = 1;
      const A = require$$0__default$7, p = require$$1__default$5, c = requireHasFlag(), { env: E } = process;
      let t;
      c("no-color") || c("no-colors") || c("color=false") || c("color=never") ? t = 0 : (c("color") || c("colors") || c("color=true") || c("color=always")) && (t = 1), "FORCE_COLOR" in E && (E.FORCE_COLOR === "true" ? t = 1 : E.FORCE_COLOR === "false" ? t = 0 : t = E.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(E.FORCE_COLOR, 10), 3));
      function B(Q) {
        return Q === 0 ? false : { level: Q, hasBasic: true, has256: Q >= 2, has16m: Q >= 3 };
      }
      e(B, "translateLevel");
      function f(Q, u) {
        if (t === 0)
          return 0;
        if (c("color=16m") || c("color=full") || c("color=truecolor"))
          return 3;
        if (c("color=256"))
          return 2;
        if (Q && !u && t === void 0)
          return 0;
        const n = t || 0;
        if (E.TERM === "dumb")
          return n;
        if (process.platform === "win32") {
          const r = A.release().split(".");
          return Number(r[0]) >= 10 && Number(r[2]) >= 10586 ? Number(r[2]) >= 14931 ? 3 : 2 : 1;
        }
        if ("CI" in E)
          return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((r) => r in E) || E.CI_NAME === "codeship" ? 1 : n;
        if ("TEAMCITY_VERSION" in E)
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(E.TEAMCITY_VERSION) ? 1 : 0;
        if (E.COLORTERM === "truecolor")
          return 3;
        if ("TERM_PROGRAM" in E) {
          const r = parseInt((E.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          switch (E.TERM_PROGRAM) {
            case "iTerm.app":
              return r >= 3 ? 3 : 2;
            case "Apple_Terminal":
              return 2;
          }
        }
        return /-256(color)?$/i.test(E.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(E.TERM) || "COLORTERM" in E ? 1 : n;
      }
      e(f, "supportsColor");
      function l(Q) {
        const u = f(Q, Q && Q.isTTY);
        return B(u);
      }
      return e(l, "getSupportLevel"), supportsColor_1 = { supportsColor: l, stdout: B(f(true, p.isatty(1))), stderr: B(f(true, p.isatty(2))) }, supportsColor_1;
    }
    e(requireSupportsColor, "requireSupportsColor");
    var hasRequiredNode;
    function requireNode() {
      return hasRequiredNode || (hasRequiredNode = 1, function(A, p) {
        const c = require$$1__default$5, E = require$$1__default$6;
        p.init = n, p.log = l, p.formatArgs = B, p.save = Q, p.load = u, p.useColors = t, p.destroy = E.deprecate(() => {
        }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."), p.colors = [6, 2, 3, 4, 5, 1];
        try {
          const o = requireSupportsColor();
          o && (o.stderr || o).level >= 2 && (p.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221]);
        } catch {
        }
        p.inspectOpts = Object.keys(process.env).filter((o) => /^debug_/i.test(o)).reduce((o, a) => {
          const g = a.substring(6).toLowerCase().replace(/_([a-z])/g, (N, M) => M.toUpperCase());
          let d = process.env[a];
          return /^(yes|on|true|enabled)$/i.test(d) ? d = true : /^(no|off|false|disabled)$/i.test(d) ? d = false : d === "null" ? d = null : d = Number(d), o[g] = d, o;
        }, {});
        function t() {
          return "colors" in p.inspectOpts ? !!p.inspectOpts.colors : c.isatty(process.stderr.fd);
        }
        e(t, "useColors");
        function B(o) {
          const { namespace: a, useColors: g } = this;
          if (g) {
            const d = this.color, N = "\x1B[3" + (d < 8 ? d : "8;5;" + d), M = `  ${N};1m${a} \x1B[0m`;
            o[0] = M + o[0].split(`
`).join(`
` + M), o.push(N + "m+" + A.exports.humanize(this.diff) + "\x1B[0m");
          } else
            o[0] = f() + a + " " + o[0];
        }
        e(B, "formatArgs");
        function f() {
          return p.inspectOpts.hideDate ? "" : new Date().toISOString() + " ";
        }
        e(f, "getDate");
        function l(...o) {
          return process.stderr.write(E.formatWithOptions(p.inspectOpts, ...o) + `
`);
        }
        e(l, "log");
        function Q(o) {
          o ? process.env.DEBUG = o : delete process.env.DEBUG;
        }
        e(Q, "save");
        function u() {
          return process.env.DEBUG;
        }
        e(u, "load");
        function n(o) {
          o.inspectOpts = {};
          const a = Object.keys(p.inspectOpts);
          for (let g = 0; g < a.length; g++)
            o.inspectOpts[a[g]] = p.inspectOpts[a[g]];
        }
        e(n, "init"), A.exports = requireCommon()(p);
        const { formatters: r } = A.exports;
        r.o = function(o) {
          return this.inspectOpts.colors = this.useColors, E.inspect(o, this.inspectOpts).split(`
`).map((a) => a.trim()).join(" ");
        }, r.O = function(o) {
          return this.inspectOpts.colors = this.useColors, E.inspect(o, this.inspectOpts);
        };
      }(node, node.exports)), node.exports;
    }
    e(requireNode, "requireNode");
    var hasRequiredSrc;
    function requireSrc() {
      return hasRequiredSrc || (hasRequiredSrc = 1, typeof process > "u" || process.type === "renderer" || process.browser === true || process.__nwjs ? src.exports = requireBrowser() : src.exports = requireNode()), src.exports;
    }
    e(requireSrc, "requireSrc");
    var hasRequiredDist$1;
    function requireDist$1() {
      if (hasRequiredDist$1)
        return dist$1;
      hasRequiredDist$1 = 1;
      var A = dist$1.__createBinding || (Object.create ? function(a, g, d, N) {
        N === void 0 && (N = d);
        var M = Object.getOwnPropertyDescriptor(g, d);
        (!M || ("get" in M ? !g.__esModule : M.writable || M.configurable)) && (M = { enumerable: true, get: e(function() {
          return g[d];
        }, "get") }), Object.defineProperty(a, N, M);
      } : function(a, g, d, N) {
        N === void 0 && (N = d), a[N] = g[d];
      }), p = dist$1.__setModuleDefault || (Object.create ? function(a, g) {
        Object.defineProperty(a, "default", { enumerable: true, value: g });
      } : function(a, g) {
        a.default = g;
      }), c = dist$1.__importStar || function(a) {
        if (a && a.__esModule)
          return a;
        var g = {};
        if (a != null)
          for (var d in a)
            d !== "default" && Object.prototype.hasOwnProperty.call(a, d) && A(g, a, d);
        return p(g, a), g;
      }, E = dist$1.__importDefault || function(a) {
        return a && a.__esModule ? a : { default: a };
      };
      Object.defineProperty(dist$1, "__esModule", { value: true }), dist$1.HttpProxyAgent = void 0;
      const t = c(require$$0__default$6), B = c(require$$1__default$7), f = E(requireSrc()), l = require$$3__default, Q = requireDist$2(), u = require$$5__default$4, n = (0, f.default)("http-proxy-agent");
      class r extends Q.Agent {
        static {
          e(this, "HttpProxyAgent");
        }
        constructor(g, d) {
          super(d), this.proxy = typeof g == "string" ? new u.URL(g) : g, this.proxyHeaders = d?.headers ?? {}, n("Creating new HttpProxyAgent instance: %o", this.proxy.href);
          const N = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, ""), M = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
          this.connectOpts = { ...d ? o(d, "headers") : null, host: N, port: M };
        }
        addRequest(g, d) {
          g._header = null, this.setRequestProps(g, d), super.addRequest(g, d);
        }
        setRequestProps(g, d) {
          const { proxy: N } = this, M = d.secureEndpoint ? "https:" : "http:", Y = g.getHeader("host") || "localhost", J = `${M}//${Y}`, V = new u.URL(g.path, J);
          d.port !== 80 && (V.port = String(d.port)), g.path = String(V);
          const H = typeof this.proxyHeaders == "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
          if (N.username || N.password) {
            const h = `${decodeURIComponent(N.username)}:${decodeURIComponent(N.password)}`;
            H["Proxy-Authorization"] = `Basic ${Buffer.from(h).toString("base64")}`;
          }
          H["Proxy-Connection"] || (H["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close");
          for (const h of Object.keys(H)) {
            const I = H[h];
            I && g.setHeader(h, I);
          }
        }
        async connect(g, d) {
          g._header = null, g.path.includes("://") || this.setRequestProps(g, d);
          let N, M;
          n("Regenerating stored HTTP header string for request"), g._implicitHeader(), g.outputData && g.outputData.length > 0 && (n("Patching connection write() output buffer with updated header"), N = g.outputData[0].data, M = N.indexOf(`\r
\r
`) + 4, g.outputData[0].data = g._header + N.substring(M), n("Output buffer: %o", g.outputData[0].data));
          let Y;
          return this.proxy.protocol === "https:" ? (n("Creating `tls.Socket`: %o", this.connectOpts), Y = B.connect(this.connectOpts)) : (n("Creating `net.Socket`: %o", this.connectOpts), Y = t.connect(this.connectOpts)), await (0, l.once)(Y, "connect"), Y;
        }
      }
      r.protocols = ["http", "https"], dist$1.HttpProxyAgent = r;
      function o(a, ...g) {
        const d = {};
        let N;
        for (N in a)
          g.includes(N) || (d[N] = a[N]);
        return d;
      }
      return e(o, "omit"), dist$1;
    }
    e(requireDist$1, "requireDist$1");
    var distExports$1 = requireDist$1();
    var dist = {};
    var parseProxyResponse = {};
    var hasRequiredParseProxyResponse;
    function requireParseProxyResponse() {
      if (hasRequiredParseProxyResponse)
        return parseProxyResponse;
      hasRequiredParseProxyResponse = 1;
      var A = parseProxyResponse.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(parseProxyResponse, "__esModule", { value: true }), parseProxyResponse.parseProxyResponse = void 0;
      const c = (0, A(requireSrc()).default)("https-proxy-agent:parse-proxy-response");
      function E(t) {
        return new Promise((B, f) => {
          let l = 0;
          const Q = [];
          function u() {
            const g = t.read();
            g ? a(g) : t.once("readable", u);
          }
          e(u, "read");
          function n() {
            t.removeListener("end", r), t.removeListener("error", o), t.removeListener("readable", u);
          }
          e(n, "cleanup");
          function r() {
            n(), c("onend"), f(new Error("Proxy connection ended before receiving CONNECT response"));
          }
          e(r, "onend");
          function o(g) {
            n(), c("onerror %o", g), f(g);
          }
          e(o, "onerror");
          function a(g) {
            Q.push(g), l += g.length;
            const d = Buffer.concat(Q, l), N = d.indexOf(`\r
\r
`);
            if (N === -1) {
              c("have not received end of HTTP headers yet..."), u();
              return;
            }
            const M = d.slice(0, N).toString("ascii").split(`\r
`), Y = M.shift();
            if (!Y)
              return t.destroy(), f(new Error("No header received from proxy CONNECT response"));
            const J = Y.split(" "), V = +J[1], H = J.slice(2).join(" "), h = {};
            for (const I of M) {
              if (!I)
                continue;
              const k = I.indexOf(":");
              if (k === -1)
                return t.destroy(), f(new Error(`Invalid header from proxy CONNECT response: "${I}"`));
              const i = I.slice(0, k).toLowerCase(), F = I.slice(k + 1).trimStart(), m = h[i];
              typeof m == "string" ? h[i] = [m, F] : Array.isArray(m) ? m.push(F) : h[i] = F;
            }
            c("got proxy server response: %o %o", Y, h), n(), B({ connect: { statusCode: V, statusText: H, headers: h }, buffered: d });
          }
          e(a, "ondata"), t.on("error", o), t.on("end", r), u();
        });
      }
      return e(E, "parseProxyResponse$1"), parseProxyResponse.parseProxyResponse = E, parseProxyResponse;
    }
    e(requireParseProxyResponse, "requireParseProxyResponse");
    var hasRequiredDist;
    function requireDist() {
      if (hasRequiredDist)
        return dist;
      hasRequiredDist = 1;
      var A = dist.__createBinding || (Object.create ? function(N, M, Y, J) {
        J === void 0 && (J = Y);
        var V = Object.getOwnPropertyDescriptor(M, Y);
        (!V || ("get" in V ? !M.__esModule : V.writable || V.configurable)) && (V = { enumerable: true, get: e(function() {
          return M[Y];
        }, "get") }), Object.defineProperty(N, J, V);
      } : function(N, M, Y, J) {
        J === void 0 && (J = Y), N[J] = M[Y];
      }), p = dist.__setModuleDefault || (Object.create ? function(N, M) {
        Object.defineProperty(N, "default", { enumerable: true, value: M });
      } : function(N, M) {
        N.default = M;
      }), c = dist.__importStar || function(N) {
        if (N && N.__esModule)
          return N;
        var M = {};
        if (N != null)
          for (var Y in N)
            Y !== "default" && Object.prototype.hasOwnProperty.call(N, Y) && A(M, N, Y);
        return p(M, N), M;
      }, E = dist.__importDefault || function(N) {
        return N && N.__esModule ? N : { default: N };
      };
      Object.defineProperty(dist, "__esModule", { value: true }), dist.HttpsProxyAgent = void 0;
      const t = c(require$$0__default$6), B = c(require$$1__default$7), f = E(require$$2__default), l = E(requireSrc()), Q = requireDist$2(), u = require$$5__default$4, n = requireParseProxyResponse(), r = (0, l.default)("https-proxy-agent"), o = e((N) => N.servername === void 0 && N.host && !t.isIP(N.host) ? { ...N, servername: N.host } : N, "setServernameFromNonIpHost");
      class a extends Q.Agent {
        static {
          e(this, "HttpsProxyAgent");
        }
        constructor(M, Y) {
          super(Y), this.options = { path: void 0 }, this.proxy = typeof M == "string" ? new u.URL(M) : M, this.proxyHeaders = Y?.headers ?? {}, r("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
          const J = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, ""), V = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
          this.connectOpts = { ALPNProtocols: ["http/1.1"], ...Y ? d(Y, "headers") : null, host: J, port: V };
        }
        async connect(M, Y) {
          const { proxy: J } = this;
          if (!Y.host)
            throw new TypeError('No "host" provided');
          let V;
          J.protocol === "https:" ? (r("Creating `tls.Socket`: %o", this.connectOpts), V = B.connect(o(this.connectOpts))) : (r("Creating `net.Socket`: %o", this.connectOpts), V = t.connect(this.connectOpts));
          const H = typeof this.proxyHeaders == "function" ? this.proxyHeaders() : { ...this.proxyHeaders }, h = t.isIPv6(Y.host) ? `[${Y.host}]` : Y.host;
          let I = `CONNECT ${h}:${Y.port} HTTP/1.1\r
`;
          if (J.username || J.password) {
            const D = `${decodeURIComponent(J.username)}:${decodeURIComponent(J.password)}`;
            H["Proxy-Authorization"] = `Basic ${Buffer.from(D).toString("base64")}`;
          }
          H.Host = `${h}:${Y.port}`, H["Proxy-Connection"] || (H["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close");
          for (const D of Object.keys(H))
            I += `${D}: ${H[D]}\r
`;
          const k = (0, n.parseProxyResponse)(V);
          V.write(`${I}\r
`);
          const { connect: i, buffered: F } = await k;
          if (M.emit("proxyConnect", i), this.emit("proxyConnect", i, M), i.statusCode === 200)
            return M.once("socket", g), Y.secureEndpoint ? (r("Upgrading socket connection to TLS"), B.connect({ ...d(o(Y), "host", "path", "port"), socket: V })) : V;
          V.destroy();
          const m = new t.Socket({ writable: false });
          return m.readable = true, M.once("socket", (D) => {
            r("Replaying proxy buffer for failed request"), (0, f.default)(D.listenerCount("data") > 0), D.push(F), D.push(null);
          }), m;
        }
      }
      a.protocols = ["http", "https"], dist.HttpsProxyAgent = a;
      function g(N) {
        N.resume();
      }
      e(g, "resume");
      function d(N, ...M) {
        const Y = {};
        let J;
        for (J in N)
          M.includes(J) || (Y[J] = N[J]);
        return Y;
      }
      return e(d, "omit"), dist;
    }
    e(requireDist, "requireDist");
    var distExports = requireDist();
    var x = Object.defineProperty;
    var s = e((A, p) => x(A, "name", { value: p, configurable: true }), "s");
    function w(...A) {
      process.env.DEBUG && console.debug("[node-fetch-native] [proxy]", ...A);
    }
    e(w, "w"), s(w, "debug");
    function y(A, p) {
      if (!p)
        return false;
      for (const c of p)
        if (c === A || c[0] === "." && A.endsWith(c.slice(1)))
          return true;
      return false;
    }
    e(y, "y"), s(y, "bypassProxy");
    var v = class extends undiciExports.ProxyAgent {
      static {
        e(this, "v");
      }
      constructor(p) {
        super(p), this._options = p, this._agent = new undiciExports.Agent();
      }
      static {
        s(this, "UndiciProxyAgent");
      }
      _agent;
      dispatch(p, c) {
        const E = new require$$1$1.URL(p.origin).hostname;
        return y(E, this._options.noProxy) ? (w(`Bypassing proxy for: ${E}`), this._agent.dispatch(p, c)) : super.dispatch(p, c);
      }
    };
    var U = ["http", "https"];
    var C = { http: [distExports$1.HttpProxyAgent, distExports.HttpsProxyAgent], https: [distExports$1.HttpProxyAgent, distExports.HttpsProxyAgent] };
    function R(A) {
      return U.includes(A);
    }
    e(R, "R"), s(R, "isValidProtocol");
    var b = class extends distExports$2.Agent {
      static {
        e(this, "b");
      }
      constructor(p) {
        super({}), this._options = p, this.httpAgent = new http__namespace.Agent({}), this.httpsAgent = new https__namespace.Agent({});
      }
      static {
        s(this, "NodeProxyAgent");
      }
      cache = /* @__PURE__ */ new Map();
      httpAgent;
      httpsAgent;
      connect(p, c) {
        const E = p.getHeader("upgrade") === "websocket", t = c.secureEndpoint ? E ? "wss:" : "https:" : E ? "ws:" : "http:", B = p.getHeader("host");
        if (y(B, this._options.noProxy))
          return c.secureEndpoint ? this.httpsAgent : this.httpAgent;
        const f = `${t}+${this._options.uri}`;
        let l = this.cache.get(f);
        if (!l) {
          const Q = new require$$1$1.URL(this._options.uri).protocol.replace(":", "");
          if (!R(Q))
            throw new Error(`Unsupported protocol for proxy URL: ${this._options.uri}`);
          const u = C[Q][c.secureEndpoint || E ? 1 : 0];
          l = new u(this._options.uri, this._options), this.cache.set(f, l);
        }
        return l;
      }
      destroy() {
        for (const p of this.cache.values())
          p.destroy();
        super.destroy();
      }
    };
    function createProxy(A = {}) {
      const p = A.url || process.env.https_proxy || process.env.http_proxy || process.env.HTTPS_PROXY || process.env.HTTP_PROXY;
      if (!p)
        return { agent: void 0, dispatcher: void 0 };
      const c = A.noProxy || process.env.no_proxy || process.env.NO_PROXY, E = typeof c == "string" ? c.split(",") : c, t = new b({ uri: p, noProxy: E }), B = new v({ uri: p, noProxy: E });
      return { agent: t, dispatcher: B };
    }
    e(createProxy, "createProxy"), s(createProxy, "createProxy");
    function createFetch(A = {}) {
      const p = createProxy(A);
      return (c, E) => nodeFetchNative.fetch(c, { ...p, ...E });
    }
    e(createFetch, "createFetch"), s(createFetch, "createFetch");
    var fetch2 = createFetch({});
    exports.createFetch = createFetch, exports.createProxy = createProxy, exports.fetch = fetch2;
  }
});

// node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS({
  "node_modules/picocolors/picocolors.js"(exports, module2) {
    var p = process || {};
    var argv = p.argv || [];
    var env2 = p.env || {};
    var isColorSupported = !(!!env2.NO_COLOR || argv.includes("--no-color")) && (!!env2.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env2.TERM !== "dumb" || !!env2.CI);
    var formatter = (open, close, replace = open) => (input) => {
      let string = "" + input, index = string.indexOf(close, open.length);
      return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    };
    var replaceClose = (string, close, replace, index) => {
      let result = "", cursor = 0;
      do {
        result += string.substring(cursor, index) + replace;
        cursor = index + close.length;
        index = string.indexOf(close, cursor);
      } while (~index);
      return result + string.substring(cursor);
    };
    var createColors = (enabled = isColorSupported) => {
      let f = enabled ? formatter : () => String;
      return {
        isColorSupported: enabled,
        reset: f("\x1B[0m", "\x1B[0m"),
        bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
        dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
        italic: f("\x1B[3m", "\x1B[23m"),
        underline: f("\x1B[4m", "\x1B[24m"),
        inverse: f("\x1B[7m", "\x1B[27m"),
        hidden: f("\x1B[8m", "\x1B[28m"),
        strikethrough: f("\x1B[9m", "\x1B[29m"),
        black: f("\x1B[30m", "\x1B[39m"),
        red: f("\x1B[31m", "\x1B[39m"),
        green: f("\x1B[32m", "\x1B[39m"),
        yellow: f("\x1B[33m", "\x1B[39m"),
        blue: f("\x1B[34m", "\x1B[39m"),
        magenta: f("\x1B[35m", "\x1B[39m"),
        cyan: f("\x1B[36m", "\x1B[39m"),
        white: f("\x1B[37m", "\x1B[39m"),
        gray: f("\x1B[90m", "\x1B[39m"),
        bgBlack: f("\x1B[40m", "\x1B[49m"),
        bgRed: f("\x1B[41m", "\x1B[49m"),
        bgGreen: f("\x1B[42m", "\x1B[49m"),
        bgYellow: f("\x1B[43m", "\x1B[49m"),
        bgBlue: f("\x1B[44m", "\x1B[49m"),
        bgMagenta: f("\x1B[45m", "\x1B[49m"),
        bgCyan: f("\x1B[46m", "\x1B[49m"),
        bgWhite: f("\x1B[47m", "\x1B[49m"),
        blackBright: f("\x1B[90m", "\x1B[39m"),
        redBright: f("\x1B[91m", "\x1B[39m"),
        greenBright: f("\x1B[92m", "\x1B[39m"),
        yellowBright: f("\x1B[93m", "\x1B[39m"),
        blueBright: f("\x1B[94m", "\x1B[39m"),
        magentaBright: f("\x1B[95m", "\x1B[39m"),
        cyanBright: f("\x1B[96m", "\x1B[39m"),
        whiteBright: f("\x1B[97m", "\x1B[39m"),
        bgBlackBright: f("\x1B[100m", "\x1B[49m"),
        bgRedBright: f("\x1B[101m", "\x1B[49m"),
        bgGreenBright: f("\x1B[102m", "\x1B[49m"),
        bgYellowBright: f("\x1B[103m", "\x1B[49m"),
        bgBlueBright: f("\x1B[104m", "\x1B[49m"),
        bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
        bgCyanBright: f("\x1B[106m", "\x1B[49m"),
        bgWhiteBright: f("\x1B[107m", "\x1B[49m")
      };
    };
    module2.exports = createColors();
    module2.exports.createColors = createColors;
  }
});

// node_modules/nanospinner/dist/consts.js
var require_consts = __commonJS({
  "node_modules/nanospinner/dist/consts.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.symbols = exports.isTTY = void 0;
    var node_tty_1 = __importDefault(require("node:tty"));
    var node_process_1 = __importDefault(require("node:process"));
    var isCI = node_process_1.default.env.CI || node_process_1.default.env.WT_SESSION || node_process_1.default.env.ConEmuTask === "{cmd::Cmder}" || node_process_1.default.env.TERM_PROGRAM === "vscode" || node_process_1.default.env.TERM === "xterm-256color" || node_process_1.default.env.TERM === "alacritty";
    var isTTY = node_tty_1.default.isatty(1) && node_process_1.default.env.TERM !== "dumb" && !("CI" in node_process_1.default.env);
    exports.isTTY = isTTY;
    var supportUnicode = node_process_1.default.platform !== "win32" ? node_process_1.default.env.TERM !== "linux" : isCI;
    var symbols = {
      frames: isTTY ? supportUnicode ? (
        // https://github.com/sindresorhus/cli-spinners
        ["\u280B", "\u2819", "\u2839", "\u2838", "\u283C", "\u2834", "\u2826", "\u2827", "\u2807", "\u280F"]
      ) : ["-", "\\", "|", "/"] : ["-"],
      // https://github.com/sindresorhus/log-symbols/blob/main/index.js
      tick: supportUnicode ? "\u2714" : "\u221A",
      cross: supportUnicode ? "\u2716" : "\xD7",
      warn: supportUnicode ? "\u26A0" : "!!",
      info: supportUnicode ? "\u2139" : "i"
    };
    exports.symbols = symbols;
  }
});

// node_modules/nanospinner/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/nanospinner/dist/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createSpinner = createSpinner3;
    var picocolors_1 = __importDefault(require_picocolors());
    var consts_1 = require_consts();
    function getLines(str = "", width = 80) {
      return str.replace(/\u001b[^m]*?m/g, "").split("\n").reduce((col, line) => col += Math.max(1, Math.ceil(line.length / width)), 0);
    }
    function createSpinner3(text = "", opts = {}) {
      let current = 0, interval = opts.interval || 50, stream = opts.stream || process.stderr, frames = opts.frames && opts.frames.length ? opts.frames : consts_1.symbols.frames, color = opts.color || "yellow", spinning = false, lines2 = 0, timer = void 0, getText = (opts2 = {}) => typeof opts2 === "string" ? opts2 : opts2.text || text, getUpdate = (opts2 = {}) => typeof opts2 === "string" ? false : !!opts2.update, getColor = (opts2 = {}) => typeof opts2 === "string" || !opts2.color ? color : opts2.color, getMark = (opts2 = {}, fallback) => typeof opts2 === "string" || !opts2.mark ? fallback : opts2.mark, mountProcessEvents = () => {
        process.on("SIGINT", exit2);
        process.on("SIGTERM", exit2);
      }, cleanupProcessEvents = () => {
        process.off("SIGINT", exit2);
        process.off("SIGTERM", exit2);
      };
      let spinner = {
        reset() {
          current = 0;
          lines2 = 0;
          spinning = false;
          clearTimeout(timer);
          timer = void 0;
          return spinner;
        },
        clear() {
          spinner.write("\x1B[1G");
          for (let i = 0; i < lines2; i++) {
            i > 0 && spinner.write("\x1B[1A");
            spinner.write("\x1B[2K\x1B[1G");
          }
          lines2 = 0;
          return spinner;
        },
        write(str, clear = false) {
          if (clear && consts_1.isTTY)
            spinner.clear();
          stream.write(str);
          return spinner;
        },
        render() {
          let str = `${picocolors_1.default[color](frames[current])} ${text}`;
          consts_1.isTTY ? spinner.write(`\x1B[?25l`) : str += "\n";
          spinner.write(str, true);
          consts_1.isTTY && (lines2 = getLines(str, stream.columns));
          return spinner;
        },
        spin() {
          spinner.render();
          current = ++current % frames.length;
          return spinner;
        },
        update(opts2) {
          if (typeof opts2 === "string") {
            text = opts2;
          } else {
            text = opts2.text || text;
            frames = opts2.frames && opts2.frames.length ? opts2.frames : frames;
            interval = opts2.interval || interval;
            color = opts2.color || color;
          }
          if (frames.length - 1 < current)
            current = 0;
          return spinner;
        },
        loop() {
          consts_1.isTTY && (timer = setTimeout(() => spinner.loop(), interval));
          return spinner.spin();
        },
        start(opts2 = {}) {
          timer && spinner.reset();
          spinning = true;
          mountProcessEvents();
          return spinner.update({ text: getText(opts2), color: getColor(opts2) }).loop();
        },
        stop(opts2) {
          spinning = false;
          clearTimeout(timer);
          timer = void 0;
          cleanupProcessEvents();
          const update = getUpdate(opts2);
          const mark = picocolors_1.default[getColor(opts2)](getMark(opts2, frames[current]));
          const text2 = getText(opts2);
          spinner.write(opts2 ? `${mark} ${text2}${update ? "" : "\n"}` : "", true);
          return consts_1.isTTY && !update ? spinner.write(`\x1B[?25h`) : spinner;
        },
        success(opts2 = {}) {
          return spinner.stop({
            text: getText(opts2),
            mark: getMark(opts2, consts_1.symbols.tick),
            color: "green",
            update: getUpdate(opts2)
          });
        },
        error(opts2 = {}) {
          return spinner.stop({
            text: getText(opts2),
            mark: getMark(opts2, consts_1.symbols.cross),
            color: "red",
            update: getUpdate(opts2)
          });
        },
        warn(opts2 = {}) {
          return spinner.stop({
            text: getText(opts2),
            mark: getMark(opts2, consts_1.symbols.warn),
            color: "yellow",
            update: getUpdate(opts2)
          });
        },
        info(opts2 = {}) {
          return spinner.stop({
            text: getText(opts2),
            mark: getMark(opts2, consts_1.symbols.info),
            color: "blue",
            update: getUpdate(opts2)
          });
        },
        isSpinning() {
          return spinning;
        }
      };
      function exit2(signal) {
        if (spinning) {
          spinner.stop();
        }
        process.exit(signal === "SIGINT" ? 130 : signal === "SIGTERM" ? 143 : 1);
      }
      return spinner;
    }
  }
});

// src/index.ts
var import_node_events = __toESM(require("node:events"));
var import_node_fs6 = __toESM(require("node:fs"));
var import_node_path3 = __toESM(require("node:path"));

// node_modules/@inquirer/core/dist/esm/lib/key.mjs
var isUpKey = (key) => (
  // The up key
  key.name === "up" || // Vim keybinding
  key.name === "k" || // Emacs keybinding
  key.ctrl && key.name === "p"
);
var isDownKey = (key) => (
  // The down key
  key.name === "down" || // Vim keybinding
  key.name === "j" || // Emacs keybinding
  key.ctrl && key.name === "n"
);
var isBackspaceKey = (key) => key.name === "backspace";
var isNumberKey = (key) => "123456789".includes(key.name);
var isEnterKey = (key) => key.name === "enter" || key.name === "return";

// node_modules/@inquirer/core/dist/esm/lib/errors.mjs
var AbortPromptError = class extends Error {
  name = "AbortPromptError";
  message = "Prompt was aborted";
  constructor(options) {
    super();
    this.cause = options?.cause;
  }
};
var CancelPromptError = class extends Error {
  name = "CancelPromptError";
  message = "Prompt was canceled";
};
var ExitPromptError = class extends Error {
  name = "ExitPromptError";
};
var HookError = class extends Error {
  name = "HookError";
};
var ValidationError = class extends Error {
  name = "ValidationError";
};

// node_modules/@inquirer/core/dist/esm/lib/use-prefix.mjs
var import_node_async_hooks2 = require("node:async_hooks");

// node_modules/@inquirer/core/dist/esm/lib/hook-engine.mjs
var import_node_async_hooks = require("node:async_hooks");
var hookStorage = new import_node_async_hooks.AsyncLocalStorage();
function createStore(rl) {
  const store = {
    rl,
    hooks: [],
    hooksCleanup: [],
    hooksEffect: [],
    index: 0,
    handleChange() {
    }
  };
  return store;
}
function withHooks(rl, cb) {
  const store = createStore(rl);
  return hookStorage.run(store, () => {
    function cycle(render) {
      store.handleChange = () => {
        store.index = 0;
        render();
      };
      store.handleChange();
    }
    return cb(cycle);
  });
}
function getStore() {
  const store = hookStorage.getStore();
  if (!store) {
    throw new HookError("[Inquirer] Hook functions can only be called from within a prompt");
  }
  return store;
}
function readline() {
  return getStore().rl;
}
function withUpdates(fn) {
  const wrapped = (...args) => {
    const store = getStore();
    let shouldUpdate = false;
    const oldHandleChange = store.handleChange;
    store.handleChange = () => {
      shouldUpdate = true;
    };
    const returnValue = fn(...args);
    if (shouldUpdate) {
      oldHandleChange();
    }
    store.handleChange = oldHandleChange;
    return returnValue;
  };
  return import_node_async_hooks.AsyncResource.bind(wrapped);
}
function withPointer(cb) {
  const store = getStore();
  const { index } = store;
  const pointer = {
    get() {
      return store.hooks[index];
    },
    set(value) {
      store.hooks[index] = value;
    },
    initialized: index in store.hooks
  };
  const returnValue = cb(pointer);
  store.index++;
  return returnValue;
}
function handleChange() {
  getStore().handleChange();
}
var effectScheduler = {
  queue(cb) {
    const store = getStore();
    const { index } = store;
    store.hooksEffect.push(() => {
      store.hooksCleanup[index]?.();
      const cleanFn = cb(readline());
      if (cleanFn != null && typeof cleanFn !== "function") {
        throw new ValidationError("useEffect return value must be a cleanup function or nothing.");
      }
      store.hooksCleanup[index] = cleanFn;
    });
  },
  run() {
    const store = getStore();
    withUpdates(() => {
      store.hooksEffect.forEach((effect) => {
        effect();
      });
      store.hooksEffect.length = 0;
    })();
  },
  clearAll() {
    const store = getStore();
    store.hooksCleanup.forEach((cleanFn) => {
      cleanFn?.();
    });
    store.hooksEffect.length = 0;
    store.hooksCleanup.length = 0;
  }
};

// node_modules/@inquirer/core/dist/esm/lib/use-state.mjs
function useState(defaultValue) {
  return withPointer((pointer) => {
    const setFn = (newValue) => {
      if (pointer.get() !== newValue) {
        pointer.set(newValue);
        handleChange();
      }
    };
    if (pointer.initialized) {
      return [pointer.get(), setFn];
    }
    const value = typeof defaultValue === "function" ? defaultValue() : defaultValue;
    pointer.set(value);
    return [value, setFn];
  });
}

// node_modules/@inquirer/core/dist/esm/lib/use-effect.mjs
function useEffect(cb, depArray) {
  withPointer((pointer) => {
    const oldDeps = pointer.get();
    const hasChanged = !Array.isArray(oldDeps) || depArray.some((dep, i) => !Object.is(dep, oldDeps[i]));
    if (hasChanged) {
      effectScheduler.queue(cb);
    }
    pointer.set(depArray);
  });
}

// node_modules/@inquirer/core/dist/esm/lib/theme.mjs
var import_yoctocolors_cjs = __toESM(require_yoctocolors_cjs(), 1);

// node_modules/@inquirer/figures/dist/esm/index.js
var import_node_process = __toESM(require("node:process"), 1);
function isUnicodeSupported() {
  if (import_node_process.default.platform !== "win32") {
    return import_node_process.default.env["TERM"] !== "linux";
  }
  return Boolean(import_node_process.default.env["WT_SESSION"]) || // Windows Terminal
  Boolean(import_node_process.default.env["TERMINUS_SUBLIME"]) || // Terminus (<0.2.27)
  import_node_process.default.env["ConEmuTask"] === "{cmd::Cmder}" || // ConEmu and cmder
  import_node_process.default.env["TERM_PROGRAM"] === "Terminus-Sublime" || import_node_process.default.env["TERM_PROGRAM"] === "vscode" || import_node_process.default.env["TERM"] === "xterm-256color" || import_node_process.default.env["TERM"] === "alacritty" || import_node_process.default.env["TERMINAL_EMULATOR"] === "JetBrains-JediTerm";
}
var common = {
  circleQuestionMark: "(?)",
  questionMarkPrefix: "(?)",
  square: "\u2588",
  squareDarkShade: "\u2593",
  squareMediumShade: "\u2592",
  squareLightShade: "\u2591",
  squareTop: "\u2580",
  squareBottom: "\u2584",
  squareLeft: "\u258C",
  squareRight: "\u2590",
  squareCenter: "\u25A0",
  bullet: "\u25CF",
  dot: "\u2024",
  ellipsis: "\u2026",
  pointerSmall: "\u203A",
  triangleUp: "\u25B2",
  triangleUpSmall: "\u25B4",
  triangleDown: "\u25BC",
  triangleDownSmall: "\u25BE",
  triangleLeftSmall: "\u25C2",
  triangleRightSmall: "\u25B8",
  home: "\u2302",
  heart: "\u2665",
  musicNote: "\u266A",
  musicNoteBeamed: "\u266B",
  arrowUp: "\u2191",
  arrowDown: "\u2193",
  arrowLeft: "\u2190",
  arrowRight: "\u2192",
  arrowLeftRight: "\u2194",
  arrowUpDown: "\u2195",
  almostEqual: "\u2248",
  notEqual: "\u2260",
  lessOrEqual: "\u2264",
  greaterOrEqual: "\u2265",
  identical: "\u2261",
  infinity: "\u221E",
  subscriptZero: "\u2080",
  subscriptOne: "\u2081",
  subscriptTwo: "\u2082",
  subscriptThree: "\u2083",
  subscriptFour: "\u2084",
  subscriptFive: "\u2085",
  subscriptSix: "\u2086",
  subscriptSeven: "\u2087",
  subscriptEight: "\u2088",
  subscriptNine: "\u2089",
  oneHalf: "\xBD",
  oneThird: "\u2153",
  oneQuarter: "\xBC",
  oneFifth: "\u2155",
  oneSixth: "\u2159",
  oneEighth: "\u215B",
  twoThirds: "\u2154",
  twoFifths: "\u2156",
  threeQuarters: "\xBE",
  threeFifths: "\u2157",
  threeEighths: "\u215C",
  fourFifths: "\u2158",
  fiveSixths: "\u215A",
  fiveEighths: "\u215D",
  sevenEighths: "\u215E",
  line: "\u2500",
  lineBold: "\u2501",
  lineDouble: "\u2550",
  lineDashed0: "\u2504",
  lineDashed1: "\u2505",
  lineDashed2: "\u2508",
  lineDashed3: "\u2509",
  lineDashed4: "\u254C",
  lineDashed5: "\u254D",
  lineDashed6: "\u2574",
  lineDashed7: "\u2576",
  lineDashed8: "\u2578",
  lineDashed9: "\u257A",
  lineDashed10: "\u257C",
  lineDashed11: "\u257E",
  lineDashed12: "\u2212",
  lineDashed13: "\u2013",
  lineDashed14: "\u2010",
  lineDashed15: "\u2043",
  lineVertical: "\u2502",
  lineVerticalBold: "\u2503",
  lineVerticalDouble: "\u2551",
  lineVerticalDashed0: "\u2506",
  lineVerticalDashed1: "\u2507",
  lineVerticalDashed2: "\u250A",
  lineVerticalDashed3: "\u250B",
  lineVerticalDashed4: "\u254E",
  lineVerticalDashed5: "\u254F",
  lineVerticalDashed6: "\u2575",
  lineVerticalDashed7: "\u2577",
  lineVerticalDashed8: "\u2579",
  lineVerticalDashed9: "\u257B",
  lineVerticalDashed10: "\u257D",
  lineVerticalDashed11: "\u257F",
  lineDownLeft: "\u2510",
  lineDownLeftArc: "\u256E",
  lineDownBoldLeftBold: "\u2513",
  lineDownBoldLeft: "\u2512",
  lineDownLeftBold: "\u2511",
  lineDownDoubleLeftDouble: "\u2557",
  lineDownDoubleLeft: "\u2556",
  lineDownLeftDouble: "\u2555",
  lineDownRight: "\u250C",
  lineDownRightArc: "\u256D",
  lineDownBoldRightBold: "\u250F",
  lineDownBoldRight: "\u250E",
  lineDownRightBold: "\u250D",
  lineDownDoubleRightDouble: "\u2554",
  lineDownDoubleRight: "\u2553",
  lineDownRightDouble: "\u2552",
  lineUpLeft: "\u2518",
  lineUpLeftArc: "\u256F",
  lineUpBoldLeftBold: "\u251B",
  lineUpBoldLeft: "\u251A",
  lineUpLeftBold: "\u2519",
  lineUpDoubleLeftDouble: "\u255D",
  lineUpDoubleLeft: "\u255C",
  lineUpLeftDouble: "\u255B",
  lineUpRight: "\u2514",
  lineUpRightArc: "\u2570",
  lineUpBoldRightBold: "\u2517",
  lineUpBoldRight: "\u2516",
  lineUpRightBold: "\u2515",
  lineUpDoubleRightDouble: "\u255A",
  lineUpDoubleRight: "\u2559",
  lineUpRightDouble: "\u2558",
  lineUpDownLeft: "\u2524",
  lineUpBoldDownBoldLeftBold: "\u252B",
  lineUpBoldDownBoldLeft: "\u2528",
  lineUpDownLeftBold: "\u2525",
  lineUpBoldDownLeftBold: "\u2529",
  lineUpDownBoldLeftBold: "\u252A",
  lineUpDownBoldLeft: "\u2527",
  lineUpBoldDownLeft: "\u2526",
  lineUpDoubleDownDoubleLeftDouble: "\u2563",
  lineUpDoubleDownDoubleLeft: "\u2562",
  lineUpDownLeftDouble: "\u2561",
  lineUpDownRight: "\u251C",
  lineUpBoldDownBoldRightBold: "\u2523",
  lineUpBoldDownBoldRight: "\u2520",
  lineUpDownRightBold: "\u251D",
  lineUpBoldDownRightBold: "\u2521",
  lineUpDownBoldRightBold: "\u2522",
  lineUpDownBoldRight: "\u251F",
  lineUpBoldDownRight: "\u251E",
  lineUpDoubleDownDoubleRightDouble: "\u2560",
  lineUpDoubleDownDoubleRight: "\u255F",
  lineUpDownRightDouble: "\u255E",
  lineDownLeftRight: "\u252C",
  lineDownBoldLeftBoldRightBold: "\u2533",
  lineDownLeftBoldRightBold: "\u252F",
  lineDownBoldLeftRight: "\u2530",
  lineDownBoldLeftBoldRight: "\u2531",
  lineDownBoldLeftRightBold: "\u2532",
  lineDownLeftRightBold: "\u252E",
  lineDownLeftBoldRight: "\u252D",
  lineDownDoubleLeftDoubleRightDouble: "\u2566",
  lineDownDoubleLeftRight: "\u2565",
  lineDownLeftDoubleRightDouble: "\u2564",
  lineUpLeftRight: "\u2534",
  lineUpBoldLeftBoldRightBold: "\u253B",
  lineUpLeftBoldRightBold: "\u2537",
  lineUpBoldLeftRight: "\u2538",
  lineUpBoldLeftBoldRight: "\u2539",
  lineUpBoldLeftRightBold: "\u253A",
  lineUpLeftRightBold: "\u2536",
  lineUpLeftBoldRight: "\u2535",
  lineUpDoubleLeftDoubleRightDouble: "\u2569",
  lineUpDoubleLeftRight: "\u2568",
  lineUpLeftDoubleRightDouble: "\u2567",
  lineUpDownLeftRight: "\u253C",
  lineUpBoldDownBoldLeftBoldRightBold: "\u254B",
  lineUpDownBoldLeftBoldRightBold: "\u2548",
  lineUpBoldDownLeftBoldRightBold: "\u2547",
  lineUpBoldDownBoldLeftRightBold: "\u254A",
  lineUpBoldDownBoldLeftBoldRight: "\u2549",
  lineUpBoldDownLeftRight: "\u2540",
  lineUpDownBoldLeftRight: "\u2541",
  lineUpDownLeftBoldRight: "\u253D",
  lineUpDownLeftRightBold: "\u253E",
  lineUpBoldDownBoldLeftRight: "\u2542",
  lineUpDownLeftBoldRightBold: "\u253F",
  lineUpBoldDownLeftBoldRight: "\u2543",
  lineUpBoldDownLeftRightBold: "\u2544",
  lineUpDownBoldLeftBoldRight: "\u2545",
  lineUpDownBoldLeftRightBold: "\u2546",
  lineUpDoubleDownDoubleLeftDoubleRightDouble: "\u256C",
  lineUpDoubleDownDoubleLeftRight: "\u256B",
  lineUpDownLeftDoubleRightDouble: "\u256A",
  lineCross: "\u2573",
  lineBackslash: "\u2572",
  lineSlash: "\u2571"
};
var specialMainSymbols = {
  tick: "\u2714",
  info: "\u2139",
  warning: "\u26A0",
  cross: "\u2718",
  squareSmall: "\u25FB",
  squareSmallFilled: "\u25FC",
  circle: "\u25EF",
  circleFilled: "\u25C9",
  circleDotted: "\u25CC",
  circleDouble: "\u25CE",
  circleCircle: "\u24DE",
  circleCross: "\u24E7",
  circlePipe: "\u24BE",
  radioOn: "\u25C9",
  radioOff: "\u25EF",
  checkboxOn: "\u2612",
  checkboxOff: "\u2610",
  checkboxCircleOn: "\u24E7",
  checkboxCircleOff: "\u24BE",
  pointer: "\u276F",
  triangleUpOutline: "\u25B3",
  triangleLeft: "\u25C0",
  triangleRight: "\u25B6",
  lozenge: "\u25C6",
  lozengeOutline: "\u25C7",
  hamburger: "\u2630",
  smiley: "\u32E1",
  mustache: "\u0DF4",
  star: "\u2605",
  play: "\u25B6",
  nodejs: "\u2B22",
  oneSeventh: "\u2150",
  oneNinth: "\u2151",
  oneTenth: "\u2152"
};
var specialFallbackSymbols = {
  tick: "\u221A",
  info: "i",
  warning: "\u203C",
  cross: "\xD7",
  squareSmall: "\u25A1",
  squareSmallFilled: "\u25A0",
  circle: "( )",
  circleFilled: "(*)",
  circleDotted: "( )",
  circleDouble: "( )",
  circleCircle: "(\u25CB)",
  circleCross: "(\xD7)",
  circlePipe: "(\u2502)",
  radioOn: "(*)",
  radioOff: "( )",
  checkboxOn: "[\xD7]",
  checkboxOff: "[ ]",
  checkboxCircleOn: "(\xD7)",
  checkboxCircleOff: "( )",
  pointer: ">",
  triangleUpOutline: "\u2206",
  triangleLeft: "\u25C4",
  triangleRight: "\u25BA",
  lozenge: "\u2666",
  lozengeOutline: "\u25CA",
  hamburger: "\u2261",
  smiley: "\u263A",
  mustache: "\u250C\u2500\u2510",
  star: "\u2736",
  play: "\u25BA",
  nodejs: "\u2666",
  oneSeventh: "1/7",
  oneNinth: "1/9",
  oneTenth: "1/10"
};
var mainSymbols = { ...common, ...specialMainSymbols };
var fallbackSymbols = {
  ...common,
  ...specialFallbackSymbols
};
var shouldUseMain = isUnicodeSupported();
var figures = shouldUseMain ? mainSymbols : fallbackSymbols;
var esm_default = figures;
var replacements = Object.entries(specialMainSymbols);

// node_modules/@inquirer/core/dist/esm/lib/theme.mjs
var defaultTheme = {
  prefix: {
    idle: import_yoctocolors_cjs.default.blue("?"),
    // TODO: use figure
    done: import_yoctocolors_cjs.default.green(esm_default.tick)
  },
  spinner: {
    interval: 80,
    frames: ["\u280B", "\u2819", "\u2839", "\u2838", "\u283C", "\u2834", "\u2826", "\u2827", "\u2807", "\u280F"].map((frame) => import_yoctocolors_cjs.default.yellow(frame))
  },
  style: {
    answer: import_yoctocolors_cjs.default.cyan,
    message: import_yoctocolors_cjs.default.bold,
    error: (text) => import_yoctocolors_cjs.default.red(`> ${text}`),
    defaultAnswer: (text) => import_yoctocolors_cjs.default.dim(`(${text})`),
    help: import_yoctocolors_cjs.default.dim,
    highlight: import_yoctocolors_cjs.default.cyan,
    key: (text) => import_yoctocolors_cjs.default.cyan(import_yoctocolors_cjs.default.bold(`<${text}>`))
  }
};

// node_modules/@inquirer/core/dist/esm/lib/make-theme.mjs
function isPlainObject(value) {
  if (typeof value !== "object" || value === null)
    return false;
  let proto2 = value;
  while (Object.getPrototypeOf(proto2) !== null) {
    proto2 = Object.getPrototypeOf(proto2);
  }
  return Object.getPrototypeOf(value) === proto2;
}
function deepMerge(...objects) {
  const output = {};
  for (const obj of objects) {
    for (const [key, value] of Object.entries(obj)) {
      const prevValue = output[key];
      output[key] = isPlainObject(prevValue) && isPlainObject(value) ? deepMerge(prevValue, value) : value;
    }
  }
  return output;
}
function makeTheme(...themes) {
  const themesToMerge = [
    defaultTheme,
    ...themes.filter((theme) => theme != null)
  ];
  return deepMerge(...themesToMerge);
}

// node_modules/@inquirer/core/dist/esm/lib/use-prefix.mjs
function usePrefix({ status = "idle", theme }) {
  const [showLoader, setShowLoader] = useState(false);
  const [tick, setTick] = useState(0);
  const { prefix, spinner } = makeTheme(theme);
  useEffect(() => {
    if (status === "loading") {
      let tickInterval;
      let inc = -1;
      const delayTimeout = setTimeout(import_node_async_hooks2.AsyncResource.bind(() => {
        setShowLoader(true);
        tickInterval = setInterval(import_node_async_hooks2.AsyncResource.bind(() => {
          inc = inc + 1;
          setTick(inc % spinner.frames.length);
        }), spinner.interval);
      }), 300);
      return () => {
        clearTimeout(delayTimeout);
        clearInterval(tickInterval);
      };
    } else {
      setShowLoader(false);
    }
  }, [status]);
  if (showLoader) {
    return spinner.frames[tick];
  }
  const iconName = status === "loading" ? "idle" : status;
  return typeof prefix === "string" ? prefix : prefix[iconName];
}

// node_modules/@inquirer/core/dist/esm/lib/use-memo.mjs
function useMemo(fn, dependencies) {
  return withPointer((pointer) => {
    const prev = pointer.get();
    if (!prev || prev.dependencies.length !== dependencies.length || prev.dependencies.some((dep, i) => dep !== dependencies[i])) {
      const value = fn();
      pointer.set({ value, dependencies });
      return value;
    }
    return prev.value;
  });
}

// node_modules/@inquirer/core/dist/esm/lib/use-ref.mjs
function useRef(val) {
  return useState({ current: val })[0];
}

// node_modules/@inquirer/core/dist/esm/lib/use-keypress.mjs
function useKeypress(userHandler) {
  const signal = useRef(userHandler);
  signal.current = userHandler;
  useEffect((rl) => {
    let ignore = false;
    const handler = withUpdates((_input, event) => {
      if (ignore)
        return;
      void signal.current(event, rl);
    });
    rl.input.on("keypress", handler);
    return () => {
      ignore = true;
      rl.input.removeListener("keypress", handler);
    };
  }, []);
}

// node_modules/@inquirer/core/dist/esm/lib/utils.mjs
var import_cli_width = __toESM(require_cli_width(), 1);
var import_wrap_ansi = __toESM(require_wrap_ansi(), 1);
function breakLines(content, width) {
  return content.split("\n").flatMap((line) => (0, import_wrap_ansi.default)(line, width, { trim: false, hard: true }).split("\n").map((str) => str.trimEnd())).join("\n");
}
function readlineWidth() {
  return (0, import_cli_width.default)({ defaultWidth: 80, output: readline().output });
}

// node_modules/@inquirer/core/dist/esm/lib/pagination/lines.mjs
function split(content, width) {
  return breakLines(content, width).split("\n");
}
function rotate(count, items) {
  const max = items.length;
  const offset = (count % max + max) % max;
  return [...items.slice(offset), ...items.slice(0, offset)];
}
function lines({ items, width, renderItem, active, position: requested, pageSize }) {
  const layouts = items.map((item, index) => ({
    item,
    index,
    isActive: index === active
  }));
  const layoutsInPage = rotate(active - requested, layouts).slice(0, pageSize);
  const renderItemAt = (index) => layoutsInPage[index] == null ? [] : split(renderItem(layoutsInPage[index]), width);
  const pageBuffer = Array.from({ length: pageSize });
  const activeItem = renderItemAt(requested).slice(0, pageSize);
  const position = requested + activeItem.length <= pageSize ? requested : pageSize - activeItem.length;
  pageBuffer.splice(position, activeItem.length, ...activeItem);
  let bufferPointer = position + activeItem.length;
  let layoutPointer = requested + 1;
  while (bufferPointer < pageSize && layoutPointer < layoutsInPage.length) {
    for (const line of renderItemAt(layoutPointer)) {
      pageBuffer[bufferPointer++] = line;
      if (bufferPointer >= pageSize)
        break;
    }
    layoutPointer++;
  }
  bufferPointer = position - 1;
  layoutPointer = requested - 1;
  while (bufferPointer >= 0 && layoutPointer >= 0) {
    for (const line of renderItemAt(layoutPointer).reverse()) {
      pageBuffer[bufferPointer--] = line;
      if (bufferPointer < 0)
        break;
    }
    layoutPointer--;
  }
  return pageBuffer.filter((line) => typeof line === "string");
}

// node_modules/@inquirer/core/dist/esm/lib/pagination/position.mjs
function finite({ active, pageSize, total }) {
  const middle = Math.floor(pageSize / 2);
  if (total <= pageSize || active < middle)
    return active;
  if (active >= total - middle)
    return active + pageSize - total;
  return middle;
}
function infinite({ active, lastActive, total, pageSize, pointer }) {
  if (total <= pageSize)
    return active;
  if (lastActive < active && active - lastActive < pageSize) {
    return Math.min(Math.floor(pageSize / 2), pointer + active - lastActive);
  }
  return pointer;
}

// node_modules/@inquirer/core/dist/esm/lib/pagination/use-pagination.mjs
function usePagination({ items, active, renderItem, pageSize, loop = true }) {
  const state = useRef({ position: 0, lastActive: 0 });
  const position = loop ? infinite({
    active,
    lastActive: state.current.lastActive,
    total: items.length,
    pageSize,
    pointer: state.current.position
  }) : finite({
    active,
    total: items.length,
    pageSize
  });
  state.current.position = position;
  state.current.lastActive = active;
  return lines({
    items,
    width: readlineWidth(),
    renderItem,
    active,
    position,
    pageSize
  }).join("\n");
}

// node_modules/@inquirer/core/dist/esm/lib/create-prompt.mjs
var readline2 = __toESM(require("node:readline"), 1);
var import_node_async_hooks3 = require("node:async_hooks");
var import_mute_stream = __toESM(require_lib(), 1);
init_mjs();

// node_modules/@inquirer/core/dist/esm/lib/screen-manager.mjs
var import_strip_ansi = __toESM(require_strip_ansi(), 1);
var import_ansi_escapes = __toESM(require_ansi_escapes(), 1);
var height = (content) => content.split("\n").length;
var lastLine = (content) => content.split("\n").pop() ?? "";
function cursorDown(n) {
  return n > 0 ? import_ansi_escapes.default.cursorDown(n) : "";
}
var ScreenManager = class {
  rl;
  // These variables are keeping information to allow correct prompt re-rendering
  height = 0;
  extraLinesUnderPrompt = 0;
  cursorPos;
  constructor(rl) {
    this.rl = rl;
    this.rl = rl;
    this.cursorPos = rl.getCursorPos();
  }
  write(content) {
    this.rl.output.unmute();
    this.rl.output.write(content);
    this.rl.output.mute();
  }
  render(content, bottomContent = "") {
    const promptLine = lastLine(content);
    const rawPromptLine = (0, import_strip_ansi.default)(promptLine);
    let prompt = rawPromptLine;
    if (this.rl.line.length > 0) {
      prompt = prompt.slice(0, -this.rl.line.length);
    }
    this.rl.setPrompt(prompt);
    this.cursorPos = this.rl.getCursorPos();
    const width = readlineWidth();
    content = breakLines(content, width);
    bottomContent = breakLines(bottomContent, width);
    if (rawPromptLine.length % width === 0) {
      content += "\n";
    }
    let output = content + (bottomContent ? "\n" + bottomContent : "");
    const promptLineUpDiff = Math.floor(rawPromptLine.length / width) - this.cursorPos.rows;
    const bottomContentHeight = promptLineUpDiff + (bottomContent ? height(bottomContent) : 0);
    if (bottomContentHeight > 0)
      output += import_ansi_escapes.default.cursorUp(bottomContentHeight);
    output += import_ansi_escapes.default.cursorTo(this.cursorPos.cols);
    this.write(cursorDown(this.extraLinesUnderPrompt) + import_ansi_escapes.default.eraseLines(this.height) + output);
    this.extraLinesUnderPrompt = bottomContentHeight;
    this.height = height(output);
  }
  checkCursorPos() {
    const cursorPos = this.rl.getCursorPos();
    if (cursorPos.cols !== this.cursorPos.cols) {
      this.write(import_ansi_escapes.default.cursorTo(cursorPos.cols));
      this.cursorPos = cursorPos;
    }
  }
  done({ clearContent }) {
    this.rl.setPrompt("");
    let output = cursorDown(this.extraLinesUnderPrompt);
    output += clearContent ? import_ansi_escapes.default.eraseLines(this.height) : "\n";
    output += import_ansi_escapes.default.cursorShow;
    this.write(output);
    this.rl.close();
  }
};

// node_modules/@inquirer/core/dist/esm/lib/promise-polyfill.mjs
var PromisePolyfill = class extends Promise {
  // Available starting from Node 22
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers
  static withResolver() {
    let resolve2;
    let reject;
    const promise = new Promise((res, rej) => {
      resolve2 = res;
      reject = rej;
    });
    return { promise, resolve: resolve2, reject };
  }
};

// node_modules/@inquirer/core/dist/esm/lib/create-prompt.mjs
function createPrompt(view) {
  const prompt = (config2, context = {}) => {
    const { input = process.stdin, signal } = context;
    const cleanups = /* @__PURE__ */ new Set();
    const output = new import_mute_stream.default();
    output.pipe(context.output ?? process.stdout);
    const rl = readline2.createInterface({
      terminal: true,
      input,
      output
    });
    const screen = new ScreenManager(rl);
    const { promise, resolve: resolve2, reject } = PromisePolyfill.withResolver();
    const cancel = () => reject(new CancelPromptError());
    if (signal) {
      const abort = () => reject(new AbortPromptError({ cause: signal.reason }));
      if (signal.aborted) {
        abort();
        return Object.assign(promise, { cancel });
      }
      signal.addEventListener("abort", abort);
      cleanups.add(() => signal.removeEventListener("abort", abort));
    }
    cleanups.add(onExit((code, signal2) => {
      reject(new ExitPromptError(`User force closed the prompt with ${code} ${signal2}`));
    }));
    const checkCursorPos = () => screen.checkCursorPos();
    rl.input.on("keypress", checkCursorPos);
    cleanups.add(() => rl.input.removeListener("keypress", checkCursorPos));
    return withHooks(rl, (cycle) => {
      const hooksCleanup = import_node_async_hooks3.AsyncResource.bind(() => effectScheduler.clearAll());
      rl.on("close", hooksCleanup);
      cleanups.add(() => rl.removeListener("close", hooksCleanup));
      cycle(() => {
        try {
          const nextView = view(config2, (value) => {
            setImmediate(() => resolve2(value));
          });
          const [content, bottomContent] = typeof nextView === "string" ? [nextView] : nextView;
          screen.render(content, bottomContent);
          effectScheduler.run();
        } catch (error) {
          reject(error);
        }
      });
      return Object.assign(promise.then((answer) => {
        effectScheduler.clearAll();
        return answer;
      }, (error) => {
        effectScheduler.clearAll();
        throw error;
      }).finally(() => {
        cleanups.forEach((cleanup) => cleanup());
        screen.done({ clearContent: Boolean(context?.clearPromptOnDone) });
        output.end();
      }).then(() => promise), { cancel });
    });
  };
  return prompt;
}

// node_modules/@inquirer/core/dist/esm/lib/Separator.mjs
var import_yoctocolors_cjs2 = __toESM(require_yoctocolors_cjs(), 1);
var Separator = class {
  separator = import_yoctocolors_cjs2.default.dim(Array.from({ length: 15 }).join(esm_default.line));
  type = "separator";
  constructor(separator) {
    if (separator) {
      this.separator = separator;
    }
  }
  static isSeparator(choice) {
    return Boolean(choice && typeof choice === "object" && "type" in choice && choice.type === "separator");
  }
};

// node_modules/@inquirer/confirm/dist/esm/index.mjs
var esm_default2 = createPrompt((config2, done) => {
  const { transformer = (answer) => answer ? "yes" : "no" } = config2;
  const [status, setStatus] = useState("pending");
  const [value, setValue] = useState("");
  const theme = makeTheme(config2.theme);
  const prefix = usePrefix({ theme });
  useKeypress((key, rl) => {
    if (isEnterKey(key)) {
      let answer = config2.default !== false;
      if (/^(y|yes)/i.test(value))
        answer = true;
      else if (/^(n|no)/i.test(value))
        answer = false;
      setValue(transformer(answer));
      setStatus("done");
      done(answer);
    } else {
      setValue(rl.line);
    }
  });
  let formattedValue = value;
  let defaultValue = "";
  if (status === "done") {
    formattedValue = theme.style.answer(value);
  } else {
    defaultValue = ` ${theme.style.defaultAnswer(config2.default === false ? "y/N" : "Y/n")}`;
  }
  const message = theme.style.message(config2.message);
  return `${prefix} ${message}${defaultValue} ${formattedValue}`;
});

// node_modules/@inquirer/input/dist/esm/index.mjs
var esm_default3 = createPrompt((config2, done) => {
  const { required, validate = () => true } = config2;
  const theme = makeTheme(config2.theme);
  const [status, setStatus] = useState("pending");
  const [defaultValue = "", setDefaultValue] = useState(config2.default);
  const [errorMsg, setError] = useState();
  const [value, setValue] = useState("");
  const isLoading = status === "loading";
  const prefix = usePrefix({ isLoading, theme });
  useKeypress(async (key, rl) => {
    if (status !== "pending") {
      return;
    }
    if (isEnterKey(key)) {
      const answer = value || defaultValue;
      setStatus("loading");
      const isValid = required && !answer ? "You must provide a value" : await validate(answer);
      if (isValid === true) {
        setValue(answer);
        setStatus("done");
        done(answer);
      } else {
        rl.write(value);
        setError(isValid || "You must provide a valid value");
        setStatus("pending");
      }
    } else if (isBackspaceKey(key) && !value) {
      setDefaultValue(void 0);
    } else if (key.name === "tab" && !value) {
      setDefaultValue(void 0);
      rl.clearLine(0);
      rl.write(defaultValue);
      setValue(defaultValue);
    } else {
      setValue(rl.line);
      setError(void 0);
    }
  });
  const message = theme.style.message(config2.message);
  let formattedValue = value;
  if (typeof config2.transformer === "function") {
    formattedValue = config2.transformer(value, { isFinal: status === "done" });
  } else if (status === "done") {
    formattedValue = theme.style.answer(value);
  }
  let defaultStr;
  if (defaultValue && status !== "done" && !value) {
    defaultStr = theme.style.defaultAnswer(defaultValue);
  }
  let error = "";
  if (errorMsg) {
    error = theme.style.error(errorMsg);
  }
  return [
    [prefix, message, defaultStr, formattedValue].filter((v) => v !== void 0).join(" "),
    error
  ];
});

// node_modules/@inquirer/select/dist/esm/index.mjs
var import_yoctocolors_cjs3 = __toESM(require_yoctocolors_cjs(), 1);
var import_ansi_escapes2 = __toESM(require_ansi_escapes(), 1);
var selectTheme = {
  icon: { cursor: esm_default.pointer },
  style: {
    disabled: (text) => import_yoctocolors_cjs3.default.dim(`- ${text}`),
    description: (text) => import_yoctocolors_cjs3.default.cyan(text)
  },
  helpMode: "auto"
};
function isSelectable(item) {
  return !Separator.isSeparator(item) && !item.disabled;
}
function normalizeChoices(choices) {
  return choices.map((choice) => {
    if (Separator.isSeparator(choice))
      return choice;
    if (typeof choice === "string") {
      return {
        value: choice,
        name: choice,
        short: choice,
        disabled: false
      };
    }
    const name = choice.name ?? String(choice.value);
    return {
      value: choice.value,
      name,
      description: choice.description,
      short: choice.short ?? name,
      disabled: choice.disabled ?? false
    };
  });
}
var esm_default4 = createPrompt((config2, done) => {
  const { loop = true, pageSize = 7 } = config2;
  const firstRender = useRef(true);
  const theme = makeTheme(selectTheme, config2.theme);
  const prefix = usePrefix({ theme });
  const [status, setStatus] = useState("pending");
  const searchTimeoutRef = useRef();
  const items = useMemo(() => normalizeChoices(config2.choices), [config2.choices]);
  const bounds = useMemo(() => {
    const first = items.findIndex(isSelectable);
    const last = items.findLastIndex(isSelectable);
    if (first < 0) {
      throw new ValidationError("[select prompt] No selectable choices. All choices are disabled.");
    }
    return { first, last };
  }, [items]);
  const defaultItemIndex = useMemo(() => {
    if (!("default" in config2))
      return -1;
    return items.findIndex((item) => isSelectable(item) && item.value === config2.default);
  }, [config2.default, items]);
  const [active, setActive] = useState(defaultItemIndex === -1 ? bounds.first : defaultItemIndex);
  const selectedChoice = items[active];
  useKeypress((key, rl) => {
    clearTimeout(searchTimeoutRef.current);
    if (isEnterKey(key)) {
      setStatus("done");
      done(selectedChoice.value);
    } else if (isUpKey(key) || isDownKey(key)) {
      rl.clearLine(0);
      if (loop || isUpKey(key) && active !== bounds.first || isDownKey(key) && active !== bounds.last) {
        const offset = isUpKey(key) ? -1 : 1;
        let next = active;
        do {
          next = (next + offset + items.length) % items.length;
        } while (!isSelectable(items[next]));
        setActive(next);
      }
    } else if (isNumberKey(key)) {
      rl.clearLine(0);
      const position = Number(key.name) - 1;
      const item = items[position];
      if (item != null && isSelectable(item)) {
        setActive(position);
      }
    } else if (isBackspaceKey(key)) {
      rl.clearLine(0);
    } else {
      const searchTerm = rl.line.toLowerCase();
      const matchIndex = items.findIndex((item) => {
        if (Separator.isSeparator(item) || !isSelectable(item))
          return false;
        return item.name.toLowerCase().startsWith(searchTerm);
      });
      if (matchIndex >= 0) {
        setActive(matchIndex);
      }
      searchTimeoutRef.current = setTimeout(() => {
        rl.clearLine(0);
      }, 700);
    }
  });
  useEffect(() => () => {
    clearTimeout(searchTimeoutRef.current);
  }, []);
  const message = theme.style.message(config2.message);
  let helpTipTop = "";
  let helpTipBottom = "";
  if (theme.helpMode === "always" || theme.helpMode === "auto" && firstRender.current) {
    firstRender.current = false;
    if (items.length > pageSize) {
      helpTipBottom = `
${theme.style.help("(Use arrow keys to reveal more choices)")}`;
    } else {
      helpTipTop = theme.style.help("(Use arrow keys)");
    }
  }
  const page = usePagination({
    items,
    active,
    renderItem({ item, isActive }) {
      if (Separator.isSeparator(item)) {
        return ` ${item.separator}`;
      }
      if (item.disabled) {
        const disabledLabel = typeof item.disabled === "string" ? item.disabled : "(disabled)";
        return theme.style.disabled(`${item.name} ${disabledLabel}`);
      }
      const color = isActive ? theme.style.highlight : (x) => x;
      const cursor = isActive ? theme.icon.cursor : ` `;
      return color(`${cursor} ${item.name}`);
    },
    pageSize,
    loop
  });
  if (status === "done") {
    return `${prefix} ${message} ${theme.style.answer(selectedChoice.short)}`;
  }
  const choiceDescription = selectedChoice.description ? `
${theme.style.description(selectedChoice.description)}` : ``;
  return `${[prefix, message, helpTipTop].filter(Boolean).join(" ")}
${page}${helpTipBottom}${choiceDescription}${import_ansi_escapes2.default.cursorHide}`;
});

// node_modules/chalk/source/vendor/ansi-styles/index.js
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
var styles = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
var modifierNames = Object.keys(styles.modifier);
var foregroundColorNames = Object.keys(styles.color);
var backgroundColorNames = Object.keys(styles.bgColor);
var colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
  const codes = /* @__PURE__ */ new Map();
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          /* eslint-disable no-bitwise */
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
}
var ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

// node_modules/chalk/source/vendor/supports-color/index.js
var import_node_process2 = __toESM(require("node:process"), 1);
var import_node_os = __toESM(require("node:os"), 1);
var import_node_tty = __toESM(require("node:tty"), 1);
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : import_node_process2.default.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
var { env } = import_node_process2.default;
var flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
  flagForceColor = 0;
} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
  flagForceColor = 1;
}
function envForceColor() {
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      return 1;
    }
    if (env.FORCE_COLOR === "false") {
      return 0;
    }
    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== void 0) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if ("TF_BUILD" in env && "AGENT_NAME" in env) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === void 0) {
    return 0;
  }
  const min = forceColor || 0;
  if (env.TERM === "dumb") {
    return min;
  }
  if (import_node_process2.default.platform === "win32") {
    const osRelease = import_node_os.default.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env) {
    if (["GITHUB_ACTIONS", "GITEA_ACTIONS", "CIRCLECI"].some((key) => key in env)) {
      return 3;
    }
    if (["TRAVIS", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === "truecolor") {
    return 3;
  }
  if (env.TERM === "xterm-kitty") {
    return 3;
  }
  if ("TERM_PROGRAM" in env) {
    const version2 = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app": {
        return version2 >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env) {
    return 1;
  }
  return min;
}
function createSupportsColor(stream, options = {}) {
  const level = _supportsColor(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options
  });
  return translateLevel(level);
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: import_node_tty.default.isatty(1) }),
  stderr: createSupportsColor({ isTTY: import_node_tty.default.isatty(2) })
};
var supports_color_default = supportsColor;

// node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index + 1;
    index = string.indexOf("\n", endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}

// node_modules/chalk/source/index.js
var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
var GENERATOR = Symbol("GENERATOR");
var STYLER = Symbol("STYLER");
var IS_EMPTY = Symbol("IS_EMPTY");
var levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
var styles2 = /* @__PURE__ */ Object.create(null);
var applyOptions = (object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === void 0 ? colorLevel : options.level;
};
var chalkFactory = (options) => {
  const chalk2 = (...strings) => strings.join(" ");
  applyOptions(chalk2, options);
  Object.setPrototypeOf(chalk2, createChalk.prototype);
  return chalk2;
};
function createChalk(options) {
  return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default)) {
  styles2[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles2.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
var getModelAnsi = (model, level, type, ...arguments_) => {
  if (model === "rgb") {
    if (level === "ansi16m") {
      return ansi_styles_default[type].ansi16m(...arguments_);
    }
    if (level === "ansi256") {
      return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
    }
    return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
  }
  if (model === "hex") {
    return getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_));
  }
  return ansi_styles_default[type][model](...arguments_);
};
var usedModels = ["rgb", "hex", "ansi256"];
for (const model of usedModels) {
  styles2[model] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles2[bgModel] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
var proto = Object.defineProperties(() => {
}, {
  ...styles2,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level) {
      this[GENERATOR].level = level;
    }
  }
});
var createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === void 0) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
};
var createBuilder = (self2, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self2;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};
var applyStyle = (self2, string) => {
  if (self2.level <= 0 || !string) {
    return self2[IS_EMPTY] ? "" : string;
  }
  let styler = self2[STYLER];
  if (styler === void 0) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes("\x1B")) {
    while (styler !== void 0) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf("\n");
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk();
var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

// node_modules/commander/esm.mjs
var import_index = __toESM(require_commander(), 1);
var {
  program,
  createCommand,
  createArgument,
  createOption,
  CommanderError,
  InvalidArgumentError,
  InvalidOptionArgumentError,
  // deprecated old name
  Command,
  Argument,
  Option,
  Help
} = import_index.default;

// node_modules/giget/dist/index.mjs
var import_promises3 = require("node:fs/promises");
var import_node_fs4 = require("node:fs");
var import_tar = __toESM(require_tar(), 1);

// node_modules/pathe/dist/shared/pathe.ff20891b.mjs
var _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
function normalizeWindowsPath(input = "") {
  if (!input) {
    return input;
  }
  return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());
}
var _UNC_REGEX = /^[/\\]{2}/;
var _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
var _DRIVE_LETTER_RE = /^[A-Za-z]:$/;
var normalize = function(path6) {
  if (path6.length === 0) {
    return ".";
  }
  path6 = normalizeWindowsPath(path6);
  const isUNCPath = path6.match(_UNC_REGEX);
  const isPathAbsolute = isAbsolute(path6);
  const trailingSeparator = path6[path6.length - 1] === "/";
  path6 = normalizeString(path6, !isPathAbsolute);
  if (path6.length === 0) {
    if (isPathAbsolute) {
      return "/";
    }
    return trailingSeparator ? "./" : ".";
  }
  if (trailingSeparator) {
    path6 += "/";
  }
  if (_DRIVE_LETTER_RE.test(path6)) {
    path6 += "/";
  }
  if (isUNCPath) {
    if (!isPathAbsolute) {
      return `//./${path6}`;
    }
    return `//${path6}`;
  }
  return isPathAbsolute && !isAbsolute(path6) ? `/${path6}` : path6;
};
var join = function(...arguments_) {
  if (arguments_.length === 0) {
    return ".";
  }
  let joined;
  for (const argument of arguments_) {
    if (argument && argument.length > 0) {
      if (joined === void 0) {
        joined = argument;
      } else {
        joined += `/${argument}`;
      }
    }
  }
  if (joined === void 0) {
    return ".";
  }
  return normalize(joined.replace(/\/\/+/g, "/"));
};
function cwd() {
  if (typeof process !== "undefined" && typeof process.cwd === "function") {
    return process.cwd().replace(/\\/g, "/");
  }
  return "/";
}
var resolve = function(...arguments_) {
  arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {
    const path6 = index >= 0 ? arguments_[index] : cwd();
    if (!path6 || path6.length === 0) {
      continue;
    }
    resolvedPath = `${path6}/${resolvedPath}`;
    resolvedAbsolute = isAbsolute(path6);
  }
  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute && !isAbsolute(resolvedPath)) {
    return `/${resolvedPath}`;
  }
  return resolvedPath.length > 0 ? resolvedPath : ".";
};
function normalizeString(path6, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let char = null;
  for (let index = 0; index <= path6.length; ++index) {
    if (index < path6.length) {
      char = path6[index];
    } else if (char === "/") {
      break;
    } else {
      char = "/";
    }
    if (char === "/") {
      if (lastSlash === index - 1 || dots === 1)
        ;
      else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
            }
            lastSlash = index;
            dots = 0;
            continue;
          } else if (res.length > 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = index;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path6.slice(lastSlash + 1, index)}`;
        } else {
          res = path6.slice(lastSlash + 1, index);
        }
        lastSegmentLength = index - lastSlash - 1;
      }
      lastSlash = index;
      dots = 0;
    } else if (char === "." && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
var isAbsolute = function(p) {
  return _IS_ABSOLUTE_RE.test(p);
};
var dirname = function(p) {
  const segments = normalizeWindowsPath(p).replace(/\/$/, "").split("/").slice(0, -1);
  if (segments.length === 1 && _DRIVE_LETTER_RE.test(segments[0])) {
    segments[0] += "/";
  }
  return segments.join("/") || (isAbsolute(p) ? "/" : ".");
};
var basename = function(p, extension) {
  const lastSegment = normalizeWindowsPath(p).split("/").pop();
  return extension && lastSegment.endsWith(extension) ? lastSegment.slice(0, -extension.length) : lastSegment;
};

// node_modules/defu/dist/defu.mjs
function isPlainObject2(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {
    return false;
  }
  if (Symbol.iterator in value) {
    return false;
  }
  if (Symbol.toStringTag in value) {
    return Object.prototype.toString.call(value) === "[object Module]";
  }
  return true;
}
function _defu(baseObject, defaults, namespace = ".", merger) {
  if (!isPlainObject2(defaults)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object = Object.assign({}, defaults);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === void 0) {
      continue;
    }
    if (merger && merger(object, key, value, namespace)) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isPlainObject2(value) && isPlainObject2(object[key])) {
      object[key] = _defu(
        value,
        object[key],
        (namespace ? `${namespace}.` : "") + key.toString(),
        merger
      );
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p, c) => _defu(p, c, "", merger), {})
  );
}
var defu = createDefu();
var defuFn = createDefu((object, key, currentValue) => {
  if (object[key] !== void 0 && typeof currentValue === "function") {
    object[key] = currentValue(object[key]);
    return true;
  }
});
var defuArrayFn = createDefu((object, key, currentValue) => {
  if (Array.isArray(object[key]) && typeof currentValue === "function") {
    object[key] = currentValue(object[key]);
    return true;
  }
});

// node_modules/nypm/dist/index.mjs
var import_node_fs3 = require("node:fs");
var import_promises2 = require("node:fs/promises");
async function findup(cwd2, match, options = {}) {
  const segments = normalize(cwd2).split("/");
  while (segments.length > 0) {
    const path6 = segments.join("/") || "/";
    const result = await match(path6);
    if (result || !options.includeParentDirs) {
      return result;
    }
    segments.pop();
  }
}
function cached(fn) {
  let v;
  return () => {
    if (v === void 0) {
      v = fn().then((r) => {
        v = r;
        return v;
      });
    }
    return v;
  };
}
var importExeca = cached(() => Promise.resolve().then(() => (init_execa(), execa_exports)).then((r) => r.execa));
var hasCorepack = cached(async () => {
  try {
    const execa2 = await importExeca();
    await execa2("corepack", ["--version"]);
    return true;
  } catch {
    return false;
  }
});
async function executeCommand(command, args, options = {}) {
  const execaArgs = command === "npm" || command === "bun" || !await hasCorepack() ? [command, args] : ["corepack", [command, ...args]];
  const execa2 = await importExeca();
  await execa2(execaArgs[0], execaArgs[1], {
    cwd: resolve(options.cwd || process.cwd()),
    stdio: options.silent ? "pipe" : "inherit"
  });
}
var NO_PACKAGE_MANAGER_DETECTED_ERROR_MSG = "No package manager auto-detected.";
async function resolveOperationOptions(options = {}) {
  const cwd2 = options.cwd || process.cwd();
  const packageManager = (typeof options.packageManager === "string" ? packageManagers.find((pm) => pm.name === options.packageManager) : options.packageManager) || await detectPackageManager(options.cwd || process.cwd());
  if (!packageManager) {
    throw new Error(NO_PACKAGE_MANAGER_DETECTED_ERROR_MSG);
  }
  return {
    cwd: cwd2,
    silent: options.silent ?? false,
    packageManager,
    dev: options.dev ?? false,
    workspace: options.workspace,
    global: options.global ?? false
  };
}
var packageManagers = [
  {
    name: "npm",
    command: "npm",
    lockFile: "package-lock.json"
  },
  {
    name: "pnpm",
    command: "pnpm",
    lockFile: "pnpm-lock.yaml",
    files: ["pnpm-workspace.yaml"]
  },
  {
    name: "bun",
    command: "bun",
    lockFile: ["bun.lockb", "bun.lock"]
  },
  {
    name: "yarn",
    command: "yarn",
    majorVersion: "1",
    lockFile: "yarn.lock"
  },
  {
    name: "yarn",
    command: "yarn",
    majorVersion: "3",
    lockFile: "yarn.lock",
    files: [".yarnrc.yml"]
  }
];
async function detectPackageManager(cwd2, options = {}) {
  const detected = await findup(
    resolve(cwd2 || "."),
    async (path6) => {
      if (!options.ignorePackageJSON) {
        const packageJSONPath = join(path6, "package.json");
        if ((0, import_node_fs3.existsSync)(packageJSONPath)) {
          const packageJSON = JSON.parse(
            await (0, import_promises2.readFile)(packageJSONPath, "utf8")
          );
          if (packageJSON?.packageManager) {
            const [name, version2 = "0.0.0"] = packageJSON.packageManager.split("@");
            const majorVersion = version2.split(".")[0];
            const packageManager = packageManagers.find(
              (pm) => pm.name === name && pm.majorVersion === majorVersion
            ) || packageManagers.find((pm) => pm.name === name);
            return {
              ...packageManager,
              name,
              command: name,
              version: version2,
              majorVersion
            };
          }
        }
      }
      if (!options.ignoreLockFile) {
        for (const packageManager of packageManagers) {
          const detectionsFiles = [
            packageManager.lockFile,
            packageManager.files
          ].flat().filter(Boolean);
          if (detectionsFiles.some((file) => (0, import_node_fs3.existsSync)(resolve(path6, file)))) {
            return {
              ...packageManager
            };
          }
        }
      }
    },
    {
      includeParentDirs: options.includeParentDirs ?? true
    }
  );
  if (!detected && !options.ignoreArgv) {
    const scriptArg = process.argv[1];
    if (scriptArg) {
      for (const packageManager of packageManagers) {
        const re = new RegExp(`[/\\\\]\\.?${packageManager.command}`);
        if (re.test(scriptArg)) {
          return packageManager;
        }
      }
    }
  }
  return detected;
}
async function installDependencies(options = {}) {
  const resolvedOptions = await resolveOperationOptions(options);
  const pmToFrozenLockfileInstallCommand = {
    npm: ["ci"],
    yarn: ["install", "--immutable"],
    bun: ["install", "--frozen-lockfile"],
    pnpm: ["install", "--frozen-lockfile"]
  };
  const commandArgs = options.frozenLockFile ? pmToFrozenLockfileInstallCommand[resolvedOptions.packageManager.name] : ["install"];
  await executeCommand(resolvedOptions.packageManager.command, commandArgs, {
    cwd: resolvedOptions.cwd,
    silent: resolvedOptions.silent
  });
}

// node_modules/giget/dist/index.mjs
var import_node_stream = require("node:stream");
var import_node_os5 = require("node:os");
var import_node_util2 = require("node:util");
var import_proxy = __toESM(require_proxy(), 1);
async function download(url, filePath, options = {}) {
  const infoPath = filePath + ".json";
  const info = JSON.parse(
    await (0, import_promises3.readFile)(infoPath, "utf8").catch(() => "{}")
  );
  const headResponse = await sendFetch(url, {
    method: "HEAD",
    headers: options.headers
  }).catch(() => void 0);
  const etag = headResponse?.headers.get("etag");
  if (info.etag === etag && (0, import_node_fs4.existsSync)(filePath)) {
    return;
  }
  if (typeof etag === "string") {
    info.etag = etag;
  }
  const response = await sendFetch(url, { headers: options.headers });
  if (response.status >= 400) {
    throw new Error(
      `Failed to download ${url}: ${response.status} ${response.statusText}`
    );
  }
  const stream = (0, import_node_fs4.createWriteStream)(filePath);
  await (0, import_node_util2.promisify)(import_node_stream.pipeline)(response.body, stream);
  await (0, import_promises3.writeFile)(infoPath, JSON.stringify(info), "utf8");
}
var inputRegex = /^(?<repo>[\w.-]+\/[\w.-]+)(?<subdir>[^#]+)?(?<ref>#[\w./@-]+)?/;
function parseGitURI(input) {
  const m = input.match(inputRegex)?.groups || {};
  return {
    repo: m.repo,
    subdir: m.subdir || "/",
    ref: m.ref ? m.ref.slice(1) : "main"
  };
}
function debug(...args) {
  if (process.env.DEBUG) {
    console.debug("[giget]", ...args);
  }
}
async function sendFetch(url, options = {}) {
  if (options.headers?.["sec-fetch-mode"]) {
    options.mode = options.headers["sec-fetch-mode"];
  }
  const res = await (0, import_proxy.fetch)(url, {
    ...options,
    headers: normalizeHeaders(options.headers)
  }).catch((error) => {
    throw new Error(`Failed to download ${url}: ${error}`, { cause: error });
  });
  if (options.validateStatus && res.status >= 400) {
    throw new Error(`Failed to fetch ${url}: ${res.status} ${res.statusText}`);
  }
  return res;
}
function cacheDirectory() {
  return process.env.XDG_CACHE_HOME ? resolve(process.env.XDG_CACHE_HOME, "giget") : resolve((0, import_node_os5.homedir)(), ".cache/giget");
}
function normalizeHeaders(headers = {}) {
  const normalized = {};
  for (const [key, value] of Object.entries(headers)) {
    if (!value) {
      continue;
    }
    normalized[key.toLowerCase()] = value;
  }
  return normalized;
}
var http = async (input, options) => {
  if (input.endsWith(".json")) {
    return await _httpJSON(input, options);
  }
  const url = new URL(input);
  let name = basename(url.pathname);
  try {
    const head = await sendFetch(url.href, {
      method: "HEAD",
      validateStatus: true,
      headers: {
        authorization: options.auth ? `Bearer ${options.auth}` : void 0
      }
    });
    const _contentType = head.headers.get("content-type") || "";
    if (_contentType.includes("application/json")) {
      return await _httpJSON(input, options);
    }
    const filename = head.headers.get("content-disposition")?.match(/filename="?(.+)"?/)?.[1];
    if (filename) {
      name = filename.split(".")[0];
    }
  } catch (error) {
    debug(`Failed to fetch HEAD for ${url.href}:`, error);
  }
  return {
    name: `${name}-${url.href.slice(0, 8)}`,
    version: "",
    subdir: "",
    tar: url.href,
    defaultDir: name,
    headers: {
      Authorization: options.auth ? `Bearer ${options.auth}` : void 0
    }
  };
};
var _httpJSON = async (input, options) => {
  const result = await sendFetch(input, {
    validateStatus: true,
    headers: {
      authorization: options.auth ? `Bearer ${options.auth}` : void 0
    }
  });
  const info = await result.json();
  if (!info.tar || !info.name) {
    throw new Error(
      `Invalid template info from ${input}. name or tar fields are missing!`
    );
  }
  return info;
};
var github = (input, options) => {
  const parsed = parseGitURI(input);
  const githubAPIURL = process.env.GIGET_GITHUB_URL || "https://api.github.com";
  return {
    name: parsed.repo.replace("/", "-"),
    version: parsed.ref,
    subdir: parsed.subdir,
    headers: {
      Authorization: options.auth ? `Bearer ${options.auth}` : void 0,
      Accept: "application/vnd.github+json",
      "X-GitHub-Api-Version": "2022-11-28"
    },
    url: `${githubAPIURL.replace("api.github.com", "github.com")}/${parsed.repo}/tree/${parsed.ref}${parsed.subdir}`,
    tar: `${githubAPIURL}/repos/${parsed.repo}/tarball/${parsed.ref}`
  };
};
var gitlab = (input, options) => {
  const parsed = parseGitURI(input);
  const gitlab2 = process.env.GIGET_GITLAB_URL || "https://gitlab.com";
  return {
    name: parsed.repo.replace("/", "-"),
    version: parsed.ref,
    subdir: parsed.subdir,
    headers: {
      authorization: options.auth ? `Bearer ${options.auth}` : void 0,
      // https://gitlab.com/gitlab-org/gitlab/-/commit/50c11f278d18fe1f3fb12eb595067216bb58ade2
      "sec-fetch-mode": "same-origin"
    },
    url: `${gitlab2}/${parsed.repo}/tree/${parsed.ref}${parsed.subdir}`,
    tar: `${gitlab2}/${parsed.repo}/-/archive/${parsed.ref}.tar.gz`
  };
};
var bitbucket = (input, options) => {
  const parsed = parseGitURI(input);
  return {
    name: parsed.repo.replace("/", "-"),
    version: parsed.ref,
    subdir: parsed.subdir,
    headers: {
      authorization: options.auth ? `Bearer ${options.auth}` : void 0
    },
    url: `https://bitbucket.com/${parsed.repo}/src/${parsed.ref}${parsed.subdir}`,
    tar: `https://bitbucket.org/${parsed.repo}/get/${parsed.ref}.tar.gz`
  };
};
var sourcehut = (input, options) => {
  const parsed = parseGitURI(input);
  return {
    name: parsed.repo.replace("/", "-"),
    version: parsed.ref,
    subdir: parsed.subdir,
    headers: {
      authorization: options.auth ? `Bearer ${options.auth}` : void 0
    },
    url: `https://git.sr.ht/~${parsed.repo}/tree/${parsed.ref}/item${parsed.subdir}`,
    tar: `https://git.sr.ht/~${parsed.repo}/archive/${parsed.ref}.tar.gz`
  };
};
var providers = {
  http,
  https: http,
  github,
  gh: github,
  gitlab,
  bitbucket,
  sourcehut
};
var DEFAULT_REGISTRY = "https://raw.githubusercontent.com/unjs/giget/main/templates";
var registryProvider = (registryEndpoint = DEFAULT_REGISTRY, options = {}) => {
  return async (input) => {
    const start = Date.now();
    const registryURL = `${registryEndpoint}/${input}.json`;
    const result = await sendFetch(registryURL, {
      headers: {
        authorization: options.auth ? `Bearer ${options.auth}` : void 0
      }
    });
    if (result.status >= 400) {
      throw new Error(
        `Failed to download ${input} template info from ${registryURL}: ${result.status} ${result.statusText}`
      );
    }
    const info = await result.json();
    if (!info.tar || !info.name) {
      throw new Error(
        `Invalid template info from ${registryURL}. name or tar fields are missing!`
      );
    }
    debug(
      `Fetched ${input} template info from ${registryURL} in ${Date.now() - start}ms`
    );
    return info;
  };
};
var sourceProtoRe = /^([\w-.]+):/;
async function downloadTemplate(input, options = {}) {
  options = defu(
    {
      registry: process.env.GIGET_REGISTRY,
      auth: process.env.GIGET_AUTH
    },
    options
  );
  const registry = options.registry === false ? void 0 : registryProvider(options.registry, { auth: options.auth });
  let providerName = options.provider || (registry ? "registry" : "github");
  let source = input;
  const sourceProvierMatch = input.match(sourceProtoRe);
  if (sourceProvierMatch) {
    providerName = sourceProvierMatch[1];
    source = input.slice(sourceProvierMatch[0].length);
    if (providerName === "http" || providerName === "https") {
      source = input;
    }
  }
  const provider = options.providers?.[providerName] || providers[providerName] || registry;
  if (!provider) {
    throw new Error(`Unsupported provider: ${providerName}`);
  }
  const template = await Promise.resolve().then(() => provider(source, { auth: options.auth })).catch((error) => {
    throw new Error(
      `Failed to download template from ${providerName}: ${error.message}`
    );
  });
  if (!template) {
    throw new Error(`Failed to resolve template from ${providerName}`);
  }
  template.name = (template.name || "template").replace(/[^\da-z-]/gi, "-");
  template.defaultDir = (template.defaultDir || template.name).replace(
    /[^\da-z-]/gi,
    "-"
  );
  const temporaryDirectory = resolve(
    cacheDirectory(),
    providerName,
    template.name
  );
  const tarPath = resolve(
    temporaryDirectory,
    (template.version || template.name) + ".tar.gz"
  );
  if (options.preferOffline && (0, import_node_fs4.existsSync)(tarPath)) {
    options.offline = true;
  }
  if (!options.offline) {
    await (0, import_promises3.mkdir)(dirname(tarPath), { recursive: true });
    const s2 = Date.now();
    await download(template.tar, tarPath, {
      headers: {
        Authorization: options.auth ? `Bearer ${options.auth}` : void 0,
        ...normalizeHeaders(template.headers)
      }
    }).catch((error) => {
      if (!(0, import_node_fs4.existsSync)(tarPath)) {
        throw error;
      }
      debug("Download error. Using cached version:", error);
      options.offline = true;
    });
    debug(`Downloaded ${template.tar} to ${tarPath} in ${Date.now() - s2}ms`);
  }
  if (!(0, import_node_fs4.existsSync)(tarPath)) {
    throw new Error(
      `Tarball not found: ${tarPath} (offline: ${options.offline})`
    );
  }
  const cwd2 = resolve(options.cwd || ".");
  const extractPath = resolve(cwd2, options.dir || template.defaultDir);
  if (options.forceClean) {
    await (0, import_promises3.rm)(extractPath, { recursive: true, force: true });
  }
  if (!options.force && (0, import_node_fs4.existsSync)(extractPath) && (0, import_node_fs4.readdirSync)(extractPath).length > 0) {
    throw new Error(`Destination ${extractPath} already exists.`);
  }
  await (0, import_promises3.mkdir)(extractPath, { recursive: true });
  const s = Date.now();
  const subdir = template.subdir?.replace(/^\//, "") || "";
  await (0, import_tar.extract)({
    file: tarPath,
    cwd: extractPath,
    onentry(entry) {
      entry.path = entry.path.split("/").splice(1).join("/");
      if (subdir) {
        if (entry.path.startsWith(subdir + "/")) {
          entry.path = entry.path.slice(subdir.length);
        } else {
          entry.path = "";
        }
      }
    }
  });
  debug(`Extracted to ${extractPath} in ${Date.now() - s}ms`);
  if (options.install) {
    debug("Installing dependencies...");
    await installDependencies({
      cwd: extractPath,
      silent: options.silent
    });
  }
  return {
    ...template,
    source,
    dir: extractPath
  };
}

// src/index.ts
var import_nanospinner2 = __toESM(require_dist2());

// package.json
var version = "0.15.4";

// src/hook.ts
var Hook = class {
  #hookMap;
  constructor() {
    this.#hookMap = /* @__PURE__ */ new Map();
  }
  addHook(templateName, hook) {
    const names = Array.isArray(templateName) ? templateName : [templateName];
    for (const name of names) {
      const hooks = this.#hookMap.get(name) || [];
      hooks.push(hook);
      this.#hookMap.set(name, hooks);
    }
  }
  applyHook(templateName, ...hookOptions) {
    const hooks = this.#hookMap.get(templateName);
    const results = [];
    if (hooks) {
      hooks.forEach((hook) => {
        results.push(hook(...hookOptions));
      });
    }
    return results;
  }
};
var afterCreateHook = new Hook();
var projectDependenciesHook = new Hook();

// src/hooks/after-create.ts
var import_node_fs5 = require("node:fs");
var path4 = __toESM(require("node:path"));
var PROJECT_NAME = new RegExp(/%%PROJECT_NAME.*%%/g);
var WRANGLER_FILES = ["wrangler.toml", "wrangler.json", "wrangler.jsonc"];
afterCreateHook.addHook(
  ["cloudflare-workers", "cloudflare-pages", "x-basic"],
  ({ projectName, directoryPath }) => {
    for (const filename of WRANGLER_FILES) {
      try {
        const wranglerPath = path4.join(directoryPath, filename);
        const wrangler = (0, import_node_fs5.readFileSync)(wranglerPath, "utf-8");
        const convertProjectName = projectName.toLowerCase().replaceAll(/[^a-z0-9\-_]/gm, "-");
        const rewritten = wrangler.replaceAll(PROJECT_NAME, convertProjectName);
        (0, import_node_fs5.writeFileSync)(wranglerPath, rewritten);
      } catch {
      }
    }
  }
);
var PACKAGE_MANAGER = new RegExp(/\$npm_execpath/g);
afterCreateHook.addHook(
  ["cloudflare-pages", "x-basic"],
  ({ packageManager, directoryPath }) => {
    const packageJsonPath = path4.join(directoryPath, "package.json");
    const packageJson = (0, import_node_fs5.readFileSync)(packageJsonPath, "utf-8");
    const rewritten = packageJson.replaceAll(PACKAGE_MANAGER, packageManager);
    (0, import_node_fs5.writeFileSync)(packageJsonPath, rewritten);
  }
);
var COMPATIBILITY_DATE_TOML = /compatibility_date\s*=\s*"\d{4}-\d{2}-\d{2}"/;
var COMPATIBILITY_DATE_JSON = /"compatibility_date"\s*:\s*"\d{4}-\d{2}-\d{2}"/;
afterCreateHook.addHook(
  ["cloudflare-workers", "cloudflare-pages", "x-basic"],
  ({ directoryPath }) => {
    for (const filename of WRANGLER_FILES) {
      try {
        const wranglerPath = path4.join(directoryPath, filename);
        const wrangler = (0, import_node_fs5.readFileSync)(wranglerPath, "utf-8");
        const currentDate = new Date().toISOString().split("T")[0];
        const rewritten = wrangler.replace(
          COMPATIBILITY_DATE_TOML,
          `compatibility_date = "${currentDate}"`
        ).replace(
          COMPATIBILITY_DATE_JSON,
          `"compatibility_date": "${currentDate}"`
        );
        (0, import_node_fs5.writeFileSync)(wranglerPath, rewritten);
      } catch {
      }
    }
  }
);

// src/hooks/dependencies.ts
var import_node_child_process4 = require("node:child_process");
var import_node_process7 = require("node:process");
init_execa();
var import_nanospinner = __toESM(require_dist2());
var knownPackageManagers = {
  npm: "npm install",
  bun: "bun install",
  deno: "deno install",
  pnpm: "pnpm install",
  yarn: "yarn"
};
var knownPackageManagerNames = Object.keys(knownPackageManagers);
var currentPackageManager = getCurrentPackageManager();
var excludeTemplate = ["deno", "netlify"];
var registerInstallationHook = (template, installArg, pmArg, emitter) => {
  if (excludeTemplate.includes(template))
    return;
  projectDependenciesHook.addHook(template, async ({ directoryPath }) => {
    let installDeps = false;
    const installedPackageManagerNames = await Promise.all(
      knownPackageManagerNames.map(checkPackageManagerInstalled)
    ).then(
      (results) => knownPackageManagerNames.filter((_, index) => results[index])
    );
    if (!installedPackageManagerNames.length)
      return;
    if (installedPackageManagerNames.includes("deno")) {
      let isVersion1 = false;
      try {
        const { stdout } = await execa("deno", ["-v"]);
        isVersion1 = stdout.split(" ")[1].split(".")[0] === "1";
      } catch {
        isVersion1 = true;
      }
      if (isVersion1) {
        installedPackageManagerNames.splice(
          installedPackageManagerNames.indexOf("deno"),
          1
        );
      }
    }
    if (typeof installArg === "boolean") {
      installDeps = installArg;
    } else {
      installDeps = await esm_default2({
        message: "Do you want to install project dependencies?",
        default: true
      });
    }
    if (!installDeps)
      return;
    let packageManager;
    if (pmArg && installedPackageManagerNames.includes(pmArg)) {
      packageManager = pmArg;
    } else {
      packageManager = await esm_default4({
        message: "Which package manager do you want to use?",
        choices: installedPackageManagerNames.map((template2) => ({
          title: template2,
          value: template2
        })),
        default: currentPackageManager
      });
    }
    emitter.emit("packageManager", packageManager);
    emitter.on("dependencies", async () => {
      (0, import_node_process7.chdir)(directoryPath);
      if (!knownPackageManagers[packageManager]) {
        (0, import_node_process7.exit)(1);
      }
      const spinner = (0, import_nanospinner.createSpinner)("Installing project dependencies").start();
      const proc = (0, import_node_child_process4.exec)(knownPackageManagers[packageManager]);
      const procExit = await new Promise((res) => {
        proc.on("exit", (code) => res(code == null ? 255 : code));
      });
      if (procExit === 0) {
        spinner.success();
      } else {
        spinner.stop({
          mark: source_default.red("\xD7"),
          text: "Failed to install project dependencies"
        });
        (0, import_node_process7.exit)(procExit);
      }
      emitter.emit("completed");
    });
    return;
  });
};
function getCurrentPackageManager() {
  const agent = process.env.npm_config_user_agent || "npm";
  if (agent.startsWith("bun"))
    return "bun";
  if (agent.startsWith("deno"))
    return "deno";
  if (agent.startsWith("pnpm"))
    return "pnpm";
  if (agent.startsWith("yarn"))
    return "yarn";
  return "npm";
}
function checkPackageManagerInstalled(packageManager) {
  return new Promise((resolve2) => {
    execa(packageManager, ["--version"]).then(() => resolve2(true)).catch(() => resolve2(false));
  });
}

// src/index.ts
var [major, minor] = version.split(".");
var ref = `v${major}.${minor}`;
var isCurrentDirRegex = /^(\.\/|\.\\|\.)$/;
var directoryName = "templates";
var config = {
  directory: directoryName,
  repository: "starter",
  user: "honojs",
  ref
};
var templates = [
  "aws-lambda",
  "bun",
  "cloudflare-pages",
  "cloudflare-workers",
  "deno",
  "fastly",
  "lambda-edge",
  "netlify",
  "nextjs",
  "nodejs",
  "vercel",
  "x-basic"
];
function mkdirp(dir) {
  try {
    import_node_fs6.default.mkdirSync(dir, { recursive: true });
  } catch (e) {
    if (e instanceof Error) {
      if ("code" in e && e.code === "EEXIST")
        return;
    }
    throw e;
  }
}
program.name("create-hono").version(version).arguments("[target]").addOption(new Option("-i, --install", "Install dependencies")).addOption(
  new Option("-p, --pm <pm>", "Package manager to use").choices(
    knownPackageManagerNames
  )
).addOption(
  new Option("-t, --template <template>", "Template to use").choices(
    templates
  )
).addOption(new Option("-o, --offline", "Use offline mode").default(false)).action(main);
async function main(targetDir, options, command) {
  console.log(source_default.gray(`${command.name()} version ${command.version()}`));
  const { install, pm, offline, template: templateArg } = options;
  let target = "";
  if (targetDir) {
    target = targetDir;
    console.log(
      `${source_default.bold(`${source_default.green("\u2714")} Using target directory`)} \u2026 ${target}`
    );
  } else {
    const answer = await esm_default3({
      message: "Target directory",
      default: "my-app"
    });
    target = answer;
  }
  let projectName = "";
  if (isCurrentDirRegex.test(target)) {
    projectName = import_node_path3.default.basename(process.cwd());
  } else {
    projectName = import_node_path3.default.basename(target);
  }
  const templateName = templateArg || await esm_default4({
    loop: true,
    message: "Which template do you want to use?",
    choices: templates.map((template) => ({
      title: template,
      value: template
    })),
    default: 0
  });
  if (!templateName) {
    throw new Error("No template selected");
  }
  if (!templates.includes(templateName)) {
    throw new Error(`Invalid template selected: ${templateName}`);
  }
  if (import_node_fs6.default.existsSync(target)) {
    if (import_node_fs6.default.readdirSync(target).length > 0) {
      const response = await esm_default2({
        message: "Directory not empty. Continue?",
        default: false
      });
      if (!response) {
        process.exit(1);
      }
    }
  } else {
    mkdirp(target);
  }
  const targetDirectoryPath = import_node_path3.default.join(process.cwd(), target);
  const emitter = new import_node_events.default();
  let packageManager = pm ?? "npm";
  emitter.addListener("packageManager", (pm2) => {
    packageManager = String(pm2);
  });
  registerInstallationHook(templateName, install, pm, emitter);
  try {
    await Promise.all(
      projectDependenciesHook.applyHook(templateName, {
        directoryPath: targetDirectoryPath
      })
    );
    const spinner = (0, import_nanospinner2.createSpinner)("Cloning the template").start();
    await downloadTemplate(
      `gh:${config.user}/${config.repository}/${config.directory}/${templateName}#${config.ref}`,
      {
        dir: targetDirectoryPath,
        offline,
        force: true
      }
    );
    spinner.success();
    emitter.emit("dependencies");
    afterCreateHook.applyHook(templateName, {
      projectName,
      directoryPath: targetDirectoryPath,
      packageManager
    });
  } catch (e) {
    throw new Error(
      `Error running hook for ${templateName}: ${e instanceof Error ? e.message : e}`
    );
  }
  const packageJsonPath = import_node_path3.default.join(targetDirectoryPath, "package.json");
  if (import_node_fs6.default.existsSync(packageJsonPath)) {
    const packageJson = import_node_fs6.default.readFileSync(packageJsonPath, "utf-8");
    const packageJsonParsed = JSON.parse(packageJson);
    const newPackageJson = {
      name: projectName,
      ...packageJsonParsed
    };
    import_node_fs6.default.writeFileSync(packageJsonPath, JSON.stringify(newPackageJson, null, 2));
  }
  emitter.on("completed", () => {
    console.log(source_default.green(`\u{1F389} ${source_default.bold("Copied project files")}`));
    console.log(source_default.gray("Get started with:"), source_default.bold(`cd ${target}`));
    process.exit(0);
  });
}
program.parse();
/*! Bundled license information:

node-fetch-native/dist/node.cjs:
  (**
  * @license
  * web-streams-polyfill v3.3.3
  * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
  * This code is released under the MIT license.
  * SPDX-License-Identifier: MIT
  *)
  (*! fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)
  (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)
  (*! node-domexception. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

node-fetch-native/dist/proxy.cjs:
  (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)
  (*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> *)
*/
